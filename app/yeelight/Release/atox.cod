; Listing generated by Microsoft (R) Optimizing Compiler Version 19.13.26128.0 

	TITLE	C:\HelloX\personal\HelloX_OS\app\yeelight\hxlib\atox.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_atol
PUBLIC	_atoi
PUBLIC	_itoa
EXTRN	__hx_malloc:PROC
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\atox.c
;	COMDAT _isdigit
_TEXT	SEGMENT
_x$ = 8							; size = 4
_isdigit PROC						; COMDAT

; 65   : {    

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 66   :     if(x<='9'&&x>='0')             

  00003	83 7d 08 39	 cmp	 DWORD PTR _x$[ebp], 57	; 00000039H
  00007	7f 0f		 jg	 SHORT $LN2@isdigit
  00009	83 7d 08 30	 cmp	 DWORD PTR _x$[ebp], 48	; 00000030H
  0000d	7c 09		 jl	 SHORT $LN2@isdigit

; 67   :         return 1;     

  0000f	b8 01 00 00 00	 mov	 eax, 1
  00014	eb 04		 jmp	 SHORT $LN1@isdigit
  00016	eb 02		 jmp	 SHORT $LN1@isdigit
$LN2@isdigit:

; 68   :     else     
; 69   :         return 0;    

  00018	33 c0		 xor	 eax, eax
$LN1@isdigit:

; 70   : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_isdigit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\atox.c
;	COMDAT _isspace
_TEXT	SEGMENT
_x$ = 8							; size = 4
_isspace PROC						; COMDAT

; 57   : {    

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 58   :     if(x==' '||x=='\t'||x=='\n'||x=='\f'||x=='\b'||x=='\r')    

  00003	83 7d 08 20	 cmp	 DWORD PTR _x$[ebp], 32	; 00000020H
  00007	74 1e		 je	 SHORT $LN4@isspace
  00009	83 7d 08 09	 cmp	 DWORD PTR _x$[ebp], 9
  0000d	74 18		 je	 SHORT $LN4@isspace
  0000f	83 7d 08 0a	 cmp	 DWORD PTR _x$[ebp], 10	; 0000000aH
  00013	74 12		 je	 SHORT $LN4@isspace
  00015	83 7d 08 0c	 cmp	 DWORD PTR _x$[ebp], 12	; 0000000cH
  00019	74 0c		 je	 SHORT $LN4@isspace
  0001b	83 7d 08 08	 cmp	 DWORD PTR _x$[ebp], 8
  0001f	74 06		 je	 SHORT $LN4@isspace
  00021	83 7d 08 0d	 cmp	 DWORD PTR _x$[ebp], 13	; 0000000dH
  00025	75 09		 jne	 SHORT $LN2@isspace
$LN4@isspace:

; 59   :         return 1;    

  00027	b8 01 00 00 00	 mov	 eax, 1
  0002c	eb 04		 jmp	 SHORT $LN1@isspace
  0002e	eb 02		 jmp	 SHORT $LN1@isspace
$LN2@isspace:

; 60   :     else     
; 61   :         return 0;    

  00030	33 c0		 xor	 eax, eax
$LN1@isspace:

; 62   : }    

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
_isspace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\atox.c
;	COMDAT _itoa
_TEXT	SEGMENT
_tmp$ = -60						; size = 33
tv68 = -24						; size = 4
_sign$ = -20						; size = 4
_i$ = -16						; size = 4
_v$ = -12						; size = 4
_sp$ = -8						; size = 4
_tp$ = -4						; size = 4
_value$ = 8						; size = 4
_string$ = 12						; size = 4
_radix$ = 16						; size = 4
_itoa	PROC						; COMDAT

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 128  : 	char tmp[33];
; 129  : 	char* tp = tmp;

  00006	8d 45 c4	 lea	 eax, DWORD PTR _tmp$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _tp$[ebp], eax

; 130  : 	int i;
; 131  : 	unsigned v;
; 132  : 	int sign;
; 133  : 	char* sp;
; 134  : 
; 135  : 	if (radix > 36 || radix <= 1)

  0000c	83 7d 10 24	 cmp	 DWORD PTR _radix$[ebp], 36 ; 00000024H
  00010	7f 06		 jg	 SHORT $LN7@itoa
  00012	83 7d 10 01	 cmp	 DWORD PTR _radix$[ebp], 1
  00016	7f 07		 jg	 SHORT $LN6@itoa
$LN7@itoa:

; 136  : 	{
; 137  : 		//__set_errno(EDOM);
; 138  : 		return 0;

  00018	33 c0		 xor	 eax, eax
  0001a	e9 f9 00 00 00	 jmp	 $LN1@itoa
$LN6@itoa:

; 139  : 	}
; 140  : 	sign = (radix == 10 && value < 0);

  0001f	83 7d 10 0a	 cmp	 DWORD PTR _radix$[ebp], 10 ; 0000000aH
  00023	75 0f		 jne	 SHORT $LN16@itoa
  00025	83 7d 08 00	 cmp	 DWORD PTR _value$[ebp], 0
  00029	7d 09		 jge	 SHORT $LN16@itoa
  0002b	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00032	eb 07		 jmp	 SHORT $LN17@itoa
$LN16@itoa:
  00034	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN17@itoa:
  0003b	8b 4d e8	 mov	 ecx, DWORD PTR tv68[ebp]
  0003e	89 4d ec	 mov	 DWORD PTR _sign$[ebp], ecx

; 141  : 	if (sign)

  00041	83 7d ec 00	 cmp	 DWORD PTR _sign$[ebp], 0
  00045	74 0a		 je	 SHORT $LN8@itoa

; 142  : 		v = -value;

  00047	8b 55 08	 mov	 edx, DWORD PTR _value$[ebp]
  0004a	f7 da		 neg	 edx
  0004c	89 55 f4	 mov	 DWORD PTR _v$[ebp], edx
  0004f	eb 06		 jmp	 SHORT $LN2@itoa
$LN8@itoa:

; 143  : 	else
; 144  : 		v = (unsigned)value;

  00051	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00054	89 45 f4	 mov	 DWORD PTR _v$[ebp], eax
$LN2@itoa:

; 145  : 	while (v || tp == tmp)

  00057	83 7d f4 00	 cmp	 DWORD PTR _v$[ebp], 0
  0005b	75 08		 jne	 SHORT $LN10@itoa
  0005d	8d 4d c4	 lea	 ecx, DWORD PTR _tmp$[ebp]
  00060	39 4d fc	 cmp	 DWORD PTR _tp$[ebp], ecx
  00063	75 48		 jne	 SHORT $LN3@itoa
$LN10@itoa:

; 146  : 	{
; 147  : 		i = v % radix;

  00065	8b 45 f4	 mov	 eax, DWORD PTR _v$[ebp]
  00068	33 d2		 xor	 edx, edx
  0006a	f7 75 10	 div	 DWORD PTR _radix$[ebp]
  0006d	89 55 f0	 mov	 DWORD PTR _i$[ebp], edx

; 148  : 		v = v / radix;

  00070	8b 45 f4	 mov	 eax, DWORD PTR _v$[ebp]
  00073	33 d2		 xor	 edx, edx
  00075	f7 75 10	 div	 DWORD PTR _radix$[ebp]
  00078	89 45 f4	 mov	 DWORD PTR _v$[ebp], eax

; 149  : 		if (i < 10)

  0007b	83 7d f0 0a	 cmp	 DWORD PTR _i$[ebp], 10	; 0000000aH
  0007f	7d 16		 jge	 SHORT $LN11@itoa

; 150  : 			*tp++ = i+'0';

  00081	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  00084	83 c2 30	 add	 edx, 48			; 00000030H
  00087	8b 45 fc	 mov	 eax, DWORD PTR _tp$[ebp]
  0008a	88 10		 mov	 BYTE PTR [eax], dl
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _tp$[ebp]
  0008f	83 c1 01	 add	 ecx, 1
  00092	89 4d fc	 mov	 DWORD PTR _tp$[ebp], ecx
  00095	eb 14		 jmp	 SHORT $LN12@itoa
$LN11@itoa:

; 151  : 		else
; 152  : 			*tp++ = i + 'a' - 10;

  00097	8b 55 f0	 mov	 edx, DWORD PTR _i$[ebp]
  0009a	83 c2 57	 add	 edx, 87			; 00000057H
  0009d	8b 45 fc	 mov	 eax, DWORD PTR _tp$[ebp]
  000a0	88 10		 mov	 BYTE PTR [eax], dl
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _tp$[ebp]
  000a5	83 c1 01	 add	 ecx, 1
  000a8	89 4d fc	 mov	 DWORD PTR _tp$[ebp], ecx
$LN12@itoa:

; 153  : 	}

  000ab	eb aa		 jmp	 SHORT $LN2@itoa
$LN3@itoa:

; 154  : 
; 155  : 	if (string == 0)

  000ad	83 7d 0c 00	 cmp	 DWORD PTR _string$[ebp], 0
  000b1	75 1b		 jne	 SHORT $LN13@itoa

; 156  : 		string = (char*)_hx_malloc((tp-tmp)+sign+1);

  000b3	8b 55 fc	 mov	 edx, DWORD PTR _tp$[ebp]
  000b6	8d 45 c4	 lea	 eax, DWORD PTR _tmp$[ebp]
  000b9	2b d0		 sub	 edx, eax
  000bb	8b 4d ec	 mov	 ecx, DWORD PTR _sign$[ebp]
  000be	8d 54 0a 01	 lea	 edx, DWORD PTR [edx+ecx+1]
  000c2	52		 push	 edx
  000c3	e8 00 00 00 00	 call	 __hx_malloc
  000c8	83 c4 04	 add	 esp, 4
  000cb	89 45 0c	 mov	 DWORD PTR _string$[ebp], eax
$LN13@itoa:

; 157  : 	sp = string;

  000ce	8b 45 0c	 mov	 eax, DWORD PTR _string$[ebp]
  000d1	89 45 f8	 mov	 DWORD PTR _sp$[ebp], eax

; 158  : 
; 159  : 	if (sign)

  000d4	83 7d ec 00	 cmp	 DWORD PTR _sign$[ebp], 0
  000d8	74 0f		 je	 SHORT $LN4@itoa

; 160  : 		*sp++ = '-';

  000da	8b 4d f8	 mov	 ecx, DWORD PTR _sp$[ebp]
  000dd	c6 01 2d	 mov	 BYTE PTR [ecx], 45	; 0000002dH
  000e0	8b 55 f8	 mov	 edx, DWORD PTR _sp$[ebp]
  000e3	83 c2 01	 add	 edx, 1
  000e6	89 55 f8	 mov	 DWORD PTR _sp$[ebp], edx
$LN4@itoa:

; 161  : 	while (tp > tmp)

  000e9	8d 45 c4	 lea	 eax, DWORD PTR _tmp$[ebp]
  000ec	39 45 fc	 cmp	 DWORD PTR _tp$[ebp], eax
  000ef	76 1e		 jbe	 SHORT $LN5@itoa

; 162  : 		*sp++ = *--tp;

  000f1	8b 4d fc	 mov	 ecx, DWORD PTR _tp$[ebp]
  000f4	83 e9 01	 sub	 ecx, 1
  000f7	89 4d fc	 mov	 DWORD PTR _tp$[ebp], ecx
  000fa	8b 55 f8	 mov	 edx, DWORD PTR _sp$[ebp]
  000fd	8b 45 fc	 mov	 eax, DWORD PTR _tp$[ebp]
  00100	8a 08		 mov	 cl, BYTE PTR [eax]
  00102	88 0a		 mov	 BYTE PTR [edx], cl
  00104	8b 55 f8	 mov	 edx, DWORD PTR _sp$[ebp]
  00107	83 c2 01	 add	 edx, 1
  0010a	89 55 f8	 mov	 DWORD PTR _sp$[ebp], edx
  0010d	eb da		 jmp	 SHORT $LN4@itoa
$LN5@itoa:

; 163  : 	*sp = 0;

  0010f	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  00112	c6 00 00	 mov	 BYTE PTR [eax], 0

; 164  : 	return string;

  00115	8b 45 0c	 mov	 eax, DWORD PTR _string$[ebp]
$LN1@itoa:

; 165  : }

  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c3		 ret	 0
_itoa	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\atox.c
;	COMDAT _atoi
_TEXT	SEGMENT
_nptr$ = 8						; size = 4
_atoi	PROC						; COMDAT

; 122  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 123  : 	return (int)atol(nptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR _nptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _atol
  0000c	83 c4 04	 add	 esp, 4

; 124  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
_atoi	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\atox.c
;	COMDAT _atol
_TEXT	SEGMENT
_sign$ = -12						; size = 4
_total$ = -8						; size = 4
_c$ = -4						; size = 4
_nptr$ = 8						; size = 4
_atol	PROC						; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
$LN2@atol:

; 74   : 	int c; /* current char */  
; 75   : 	long total; /* current total */  
; 76   : 	int sign; /* if ''-'', then negative, otherwise positive */  
; 77   : 
; 78   : 	/* skip whitespace */
; 79   : 	while (isspace((int)(unsigned char)*nptr))

  00006	8b 45 08	 mov	 eax, DWORD PTR _nptr$[ebp]
  00009	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _isspace
  00012	83 c4 04	 add	 esp, 4
  00015	85 c0		 test	 eax, eax
  00017	74 0b		 je	 SHORT $LN3@atol

; 80   : 	{
; 81   : 		++nptr;

  00019	8b 55 08	 mov	 edx, DWORD PTR _nptr$[ebp]
  0001c	83 c2 01	 add	 edx, 1
  0001f	89 55 08	 mov	 DWORD PTR _nptr$[ebp], edx

; 82   : 	}

  00022	eb e2		 jmp	 SHORT $LN2@atol
$LN3@atol:

; 83   : 	c = (int)(unsigned char)*nptr++;  

  00024	8b 45 08	 mov	 eax, DWORD PTR _nptr$[ebp]
  00027	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0002a	89 4d fc	 mov	 DWORD PTR _c$[ebp], ecx
  0002d	8b 55 08	 mov	 edx, DWORD PTR _nptr$[ebp]
  00030	83 c2 01	 add	 edx, 1
  00033	89 55 08	 mov	 DWORD PTR _nptr$[ebp], edx

; 84   : 	sign = c; /* save sign indication */  

  00036	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00039	89 45 f4	 mov	 DWORD PTR _sign$[ebp], eax

; 85   : 	if (c == '-' || c == '+')  

  0003c	83 7d fc 2d	 cmp	 DWORD PTR _c$[ebp], 45	; 0000002dH
  00040	74 06		 je	 SHORT $LN7@atol
  00042	83 7d fc 2b	 cmp	 DWORD PTR _c$[ebp], 43	; 0000002bH
  00046	75 12		 jne	 SHORT $LN6@atol
$LN7@atol:

; 86   : 	{
; 87   : 		c = (int)(unsigned char)*nptr++; /* skip sign */  

  00048	8b 4d 08	 mov	 ecx, DWORD PTR _nptr$[ebp]
  0004b	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0004e	89 55 fc	 mov	 DWORD PTR _c$[ebp], edx
  00051	8b 45 08	 mov	 eax, DWORD PTR _nptr$[ebp]
  00054	83 c0 01	 add	 eax, 1
  00057	89 45 08	 mov	 DWORD PTR _nptr$[ebp], eax
$LN6@atol:

; 88   : 	}
; 89   : 	total = 0;  

  0005a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _total$[ebp], 0
$LN4@atol:

; 90   : 	
; 91   : 	while (isdigit(c)) {

  00061	8b 4d fc	 mov	 ecx, DWORD PTR _c$[ebp]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 _isdigit
  0006a	83 c4 04	 add	 esp, 4
  0006d	85 c0		 test	 eax, eax
  0006f	74 22		 je	 SHORT $LN5@atol

; 92   : 		total = 10 * total + (c - '0'); /* accumulate digit */  

  00071	6b 55 f8 0a	 imul	 edx, DWORD PTR _total$[ebp], 10
  00075	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00078	8d 4c 02 d0	 lea	 ecx, DWORD PTR [edx+eax-48]
  0007c	89 4d f8	 mov	 DWORD PTR _total$[ebp], ecx

; 93   : 		c = (int)(unsigned char)*nptr++; /* get next char */  

  0007f	8b 55 08	 mov	 edx, DWORD PTR _nptr$[ebp]
  00082	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00085	89 45 fc	 mov	 DWORD PTR _c$[ebp], eax
  00088	8b 4d 08	 mov	 ecx, DWORD PTR _nptr$[ebp]
  0008b	83 c1 01	 add	 ecx, 1
  0008e	89 4d 08	 mov	 DWORD PTR _nptr$[ebp], ecx

; 94   : 	}

  00091	eb ce		 jmp	 SHORT $LN4@atol
$LN5@atol:

; 95   : 	
; 96   : 	if (sign == '-')

  00093	83 7d f4 2d	 cmp	 DWORD PTR _sign$[ebp], 45 ; 0000002dH
  00097	75 09		 jne	 SHORT $LN8@atol

; 97   : 		return -total;  

  00099	8b 45 f8	 mov	 eax, DWORD PTR _total$[ebp]
  0009c	f7 d8		 neg	 eax
  0009e	eb 05		 jmp	 SHORT $LN1@atol
  000a0	eb 03		 jmp	 SHORT $LN1@atol
$LN8@atol:

; 98   : 	else  
; 99   : 		return total; /* return result, negated if necessary */  

  000a2	8b 45 f8	 mov	 eax, DWORD PTR _total$[ebp]
$LN1@atol:

; 100  : }  

  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
_atol	ENDP
_TEXT	ENDS
END
