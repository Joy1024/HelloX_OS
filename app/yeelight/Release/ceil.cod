; Listing generated by Microsoft (R) Optimizing Compiler Version 19.13.26128.0 

	TITLE	C:\HelloX\personal\HelloX_OS\app\yeelight\hxlib\ceil.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_ceil
PUBLIC	__real@0000000000000000
PUBLIC	__real@7e37e43c8800759c
EXTRN	__fltused:DWORD
;	COMDAT __real@7e37e43c8800759c
CONST	SEGMENT
__real@7e37e43c8800759c DQ 07e37e43c8800759cr	; 1e+300
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\ceil.c
;	COMDAT _ceil
_TEXT	SEGMENT
_j$ = -20						; size = 4
_i$ = -16						; size = 4
_j0$ = -12						; size = 4
_i1$ = -8						; size = 4
_i0$ = -4						; size = 4
_x$ = 8							; size = 8
_ceil	PROC						; COMDAT

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 46   :   int i0, i1, j0;
; 47   :   unsigned i, j;
; 48   : 
; 49   :   i0 = __HI (x);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp+4]
  00009	89 45 fc	 mov	 DWORD PTR _i0$[ebp], eax

; 50   :   i1 = __LO (x);

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0000f	89 4d f8	 mov	 DWORD PTR _i1$[ebp], ecx

; 51   :   j0 = ((i0 >> 20) & 0x7ff) - 0x3ff;

  00012	8b 55 fc	 mov	 edx, DWORD PTR _i0$[ebp]
  00015	c1 fa 14	 sar	 edx, 20			; 00000014H
  00018	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  0001e	81 ea ff 03 00
	00		 sub	 edx, 1023		; 000003ffH
  00024	89 55 f4	 mov	 DWORD PTR _j0$[ebp], edx

; 52   :   if (j0 < 20)

  00027	83 7d f4 14	 cmp	 DWORD PTR _j0$[ebp], 20	; 00000014H
  0002b	0f 8d ad 00 00
	00		 jge	 $LN2@ceil

; 53   :   {
; 54   :     if (j0 < 0) /* raise inexact if x != 0 */

  00031	83 7d f4 00	 cmp	 DWORD PTR _j0$[ebp], 0
  00035	7d 44		 jge	 SHORT $LN4@ceil

; 55   :     {
; 56   :       if (huge + x > 0.0) /* return 0 * sign(x) if |x| < 1 */

  00037	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@7e37e43c8800759c
  0003d	dc 45 08	 fadd	 QWORD PTR _x$[ebp]
  00040	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  00046	df e0		 fnstsw	 ax
  00048	f6 c4 41	 test	 ah, 65			; 00000041H
  0004b	75 2c		 jne	 SHORT $LN9@ceil

; 57   :       {
; 58   :         if (i0 < 0)

  0004d	83 7d fc 00	 cmp	 DWORD PTR _i0$[ebp], 0
  00051	7d 10		 jge	 SHORT $LN7@ceil

; 59   :         {
; 60   :           i0 = 0x80000000;

  00053	c7 45 fc 00 00
	00 80		 mov	 DWORD PTR _i0$[ebp], -2147483648 ; 80000000H

; 61   :           i1 = 0;

  0005a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i1$[ebp], 0

; 62   :         }

  00061	eb 16		 jmp	 SHORT $LN9@ceil
$LN7@ceil:

; 63   :         else if ((i0 | i1) != 0)

  00063	8b 45 fc	 mov	 eax, DWORD PTR _i0$[ebp]
  00066	0b 45 f8	 or	 eax, DWORD PTR _i1$[ebp]
  00069	74 0e		 je	 SHORT $LN9@ceil

; 64   :         {
; 65   :           i0 = 0x3ff00000;

  0006b	c7 45 fc 00 00
	f0 3f		 mov	 DWORD PTR _i0$[ebp], 1072693248 ; 3ff00000H

; 66   :           i1 = 0;

  00072	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i1$[ebp], 0
$LN9@ceil:

; 67   :         }
; 68   :       }
; 69   :     }

  00079	eb 5e		 jmp	 SHORT $LN11@ceil
$LN4@ceil:

; 70   :     else
; 71   :     {
; 72   :       i = (0x000fffff) >> j0;

  0007b	ba ff ff 0f 00	 mov	 edx, 1048575		; 000fffffH
  00080	8b 4d f4	 mov	 ecx, DWORD PTR _j0$[ebp]
  00083	d3 fa		 sar	 edx, cl
  00085	89 55 f0	 mov	 DWORD PTR _i$[ebp], edx

; 73   :       if (((i0 & i) | i1) == 0) /* x is integral */

  00088	8b 45 fc	 mov	 eax, DWORD PTR _i0$[ebp]
  0008b	23 45 f0	 and	 eax, DWORD PTR _i$[ebp]
  0008e	0b 45 f8	 or	 eax, DWORD PTR _i1$[ebp]
  00091	75 08		 jne	 SHORT $LN10@ceil

; 74   :       {
; 75   :         return x;

  00093	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  00096	e9 f7 00 00 00	 jmp	 $LN1@ceil
$LN10@ceil:

; 76   :       }
; 77   :       if (huge + x > 0.0) /* raise inexact flag */

  0009b	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@7e37e43c8800759c
  000a1	dc 45 08	 fadd	 QWORD PTR _x$[ebp]
  000a4	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  000aa	df e0		 fnstsw	 ax
  000ac	f6 c4 41	 test	 ah, 65			; 00000041H
  000af	75 28		 jne	 SHORT $LN11@ceil

; 78   :       {
; 79   :         if (i0 > 0)

  000b1	83 7d fc 00	 cmp	 DWORD PTR _i0$[ebp], 0
  000b5	7e 10		 jle	 SHORT $LN12@ceil

; 80   :         {
; 81   :           i0 += (0x00100000) >> j0;

  000b7	ba 00 00 10 00	 mov	 edx, 1048576		; 00100000H
  000bc	8b 4d f4	 mov	 ecx, DWORD PTR _j0$[ebp]
  000bf	d3 fa		 sar	 edx, cl
  000c1	03 55 fc	 add	 edx, DWORD PTR _i0$[ebp]
  000c4	89 55 fc	 mov	 DWORD PTR _i0$[ebp], edx
$LN12@ceil:

; 82   :         }
; 83   :         i0 &= (~i);

  000c7	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  000ca	f7 d0		 not	 eax
  000cc	23 45 fc	 and	 eax, DWORD PTR _i0$[ebp]
  000cf	89 45 fc	 mov	 DWORD PTR _i0$[ebp], eax

; 84   :         i1 = 0;

  000d2	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i1$[ebp], 0
$LN11@ceil:

; 85   :       }
; 86   :     }
; 87   :   }

  000d9	e9 a5 00 00 00	 jmp	 $LN18@ceil
$LN2@ceil:

; 88   :   else if (j0 > 51)

  000de	83 7d f4 33	 cmp	 DWORD PTR _j0$[ebp], 51	; 00000033H
  000e2	7e 20		 jle	 SHORT $LN13@ceil

; 89   :   {
; 90   :     if (j0 == 0x400) /* inf or NaN */

  000e4	81 7d f4 00 04
	00 00		 cmp	 DWORD PTR _j0$[ebp], 1024 ; 00000400H
  000eb	75 0d		 jne	 SHORT $LN15@ceil

; 91   :     {
; 92   :       return x + x;

  000ed	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  000f0	dc 45 08	 fadd	 QWORD PTR _x$[ebp]
  000f3	e9 9a 00 00 00	 jmp	 $LN1@ceil

; 93   :     }

  000f8	eb 08		 jmp	 SHORT $LN16@ceil
$LN15@ceil:

; 94   :     else /* x is integral */
; 95   :     {
; 96   :       return x;

  000fa	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  000fd	e9 90 00 00 00	 jmp	 $LN1@ceil
$LN16@ceil:

; 97   :     }
; 98   :   }

  00102	eb 7f		 jmp	 SHORT $LN18@ceil
$LN13@ceil:

; 99   :   else
; 100  :   {
; 101  :     i = ((unsigned) (0xffffffff)) >> (j0 - 20);

  00104	8b 4d f4	 mov	 ecx, DWORD PTR _j0$[ebp]
  00107	83 e9 14	 sub	 ecx, 20			; 00000014H
  0010a	83 ca ff	 or	 edx, -1
  0010d	d3 ea		 shr	 edx, cl
  0010f	89 55 f0	 mov	 DWORD PTR _i$[ebp], edx

; 102  :     if ((i1 & i) == 0) /* x is integral */

  00112	8b 45 f8	 mov	 eax, DWORD PTR _i1$[ebp]
  00115	23 45 f0	 and	 eax, DWORD PTR _i$[ebp]
  00118	75 05		 jne	 SHORT $LN17@ceil

; 103  :     {
; 104  :       return x;

  0011a	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  0011d	eb 73		 jmp	 SHORT $LN1@ceil
$LN17@ceil:

; 105  :     }
; 106  :     if (huge + x > 0.0) /* raise inexact flag */

  0011f	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@7e37e43c8800759c
  00125	dc 45 08	 fadd	 QWORD PTR _x$[ebp]
  00128	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  0012e	df e0		 fnstsw	 ax
  00130	f6 c4 41	 test	 ah, 65			; 00000041H
  00133	75 4e		 jne	 SHORT $LN18@ceil

; 107  :     {
; 108  :       if (i0 > 0)

  00135	83 7d fc 00	 cmp	 DWORD PTR _i0$[ebp], 0
  00139	7e 3d		 jle	 SHORT $LN21@ceil

; 109  :       {
; 110  :         if (j0 == 20)

  0013b	83 7d f4 14	 cmp	 DWORD PTR _j0$[ebp], 20	; 00000014H
  0013f	75 0b		 jne	 SHORT $LN20@ceil

; 111  :         {
; 112  :           i0 += 1;

  00141	8b 4d fc	 mov	 ecx, DWORD PTR _i0$[ebp]
  00144	83 c1 01	 add	 ecx, 1
  00147	89 4d fc	 mov	 DWORD PTR _i0$[ebp], ecx

; 113  :         }

  0014a	eb 2c		 jmp	 SHORT $LN21@ceil
$LN20@ceil:

; 114  :         else
; 115  :         {
; 116  :           j = i1 + (1 << (52 - j0));

  0014c	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00151	2b 4d f4	 sub	 ecx, DWORD PTR _j0$[ebp]
  00154	ba 01 00 00 00	 mov	 edx, 1
  00159	d3 e2		 shl	 edx, cl
  0015b	03 55 f8	 add	 edx, DWORD PTR _i1$[ebp]
  0015e	89 55 ec	 mov	 DWORD PTR _j$[ebp], edx

; 117  :           if (j < i1) /* got a carry */

  00161	8b 45 ec	 mov	 eax, DWORD PTR _j$[ebp]
  00164	3b 45 f8	 cmp	 eax, DWORD PTR _i1$[ebp]
  00167	73 09		 jae	 SHORT $LN22@ceil

; 118  :           {
; 119  :             i0 += 1;

  00169	8b 4d fc	 mov	 ecx, DWORD PTR _i0$[ebp]
  0016c	83 c1 01	 add	 ecx, 1
  0016f	89 4d fc	 mov	 DWORD PTR _i0$[ebp], ecx
$LN22@ceil:

; 120  :           }
; 121  :           i1 = j;

  00172	8b 55 ec	 mov	 edx, DWORD PTR _j$[ebp]
  00175	89 55 f8	 mov	 DWORD PTR _i1$[ebp], edx
$LN21@ceil:

; 122  :         }
; 123  :       }
; 124  :       i1 &= (~i);

  00178	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0017b	f7 d0		 not	 eax
  0017d	23 45 f8	 and	 eax, DWORD PTR _i1$[ebp]
  00180	89 45 f8	 mov	 DWORD PTR _i1$[ebp], eax
$LN18@ceil:

; 125  :     }
; 126  :   }
; 127  :   __HI (x) = i0;

  00183	8b 4d fc	 mov	 ecx, DWORD PTR _i0$[ebp]
  00186	89 4d 0c	 mov	 DWORD PTR _x$[ebp+4], ecx

; 128  :   __LO (x) = i1;

  00189	8b 55 f8	 mov	 edx, DWORD PTR _i1$[ebp]
  0018c	89 55 08	 mov	 DWORD PTR _x$[ebp], edx

; 129  :   return x;

  0018f	dd 45 08	 fld	 QWORD PTR _x$[ebp]
$LN1@ceil:

; 130  : } /* ceil */

  00192	8b e5		 mov	 esp, ebp
  00194	5d		 pop	 ebp
  00195	c3		 ret	 0
_ceil	ENDP
_TEXT	ENDS
END
