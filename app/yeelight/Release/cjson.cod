; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	C:\HelloX\personal\HelloX_OS\app\yeelight\hxlib\cjson\cjson.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_global_error DQ 01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
?default_buffer_size@?1??print@@9@9 DD 0100H		; `print'::`2'::default_buffer_size
CONST	ENDS
_DATA	SEGMENT
$SG2315	DB	'%i.%i.%i', 00H
	ORG $+3
_global_hooks DD FLAT:_internal_malloc
	DD	FLAT:_internal_free
	DD	FLAT:_internal_realloc
$SG2513	DB	'null', 00H
	ORG $+3
$SG2516	DB	'%1.15g', 00H
	ORG $+1
$SG2522	DB	'%lg', 00H
$SG2524	DB	'%1.17g', 00H
	ORG $+1
$SG2673	DB	'""', 00H
	ORG $+1
$SG2709	DB	'u%04x', 00H
	ORG $+2
$SG2766	DB	0efH, 0bbH, 0bfH, 00H
$SG2875	DB	'null', 00H
	ORG $+3
$SG2879	DB	'false', 00H
	ORG $+2
$SG2883	DB	'true', 00H
	ORG $+3
$SG2908	DB	'null', 00H
	ORG $+3
$SG2914	DB	'false', 00H
	ORG $+2
$SG2920	DB	'true', 00H
_DATA	ENDS
PUBLIC	_cJSON_Version@0
PUBLIC	_cJSON_InitHooks@4
PUBLIC	_cJSON_Parse@4
PUBLIC	_cJSON_ParseWithOpts@12
PUBLIC	_cJSON_Print@4
PUBLIC	_cJSON_PrintUnformatted@4
PUBLIC	_cJSON_PrintBuffered@12
PUBLIC	_cJSON_PrintPreallocated@16
PUBLIC	_cJSON_Delete@4
PUBLIC	_cJSON_GetArraySize@4
PUBLIC	_cJSON_GetArrayItem@8
PUBLIC	_cJSON_GetObjectItem@8
PUBLIC	_cJSON_GetObjectItemCaseSensitive@8
PUBLIC	_cJSON_HasObjectItem@8
PUBLIC	_cJSON_GetErrorPtr@0
PUBLIC	_cJSON_GetStringValue@4
PUBLIC	_cJSON_IsInvalid@4
PUBLIC	_cJSON_IsFalse@4
PUBLIC	_cJSON_IsTrue@4
PUBLIC	_cJSON_IsBool@4
PUBLIC	_cJSON_IsNull@4
PUBLIC	_cJSON_IsNumber@4
PUBLIC	_cJSON_IsString@4
PUBLIC	_cJSON_IsArray@4
PUBLIC	_cJSON_IsObject@4
PUBLIC	_cJSON_IsRaw@4
PUBLIC	_cJSON_CreateNull@0
PUBLIC	_cJSON_CreateTrue@0
PUBLIC	_cJSON_CreateFalse@0
PUBLIC	_cJSON_CreateBool@4
PUBLIC	_cJSON_CreateNumber@8
PUBLIC	_cJSON_CreateString@4
PUBLIC	_cJSON_CreateRaw@4
PUBLIC	_cJSON_CreateArray@0
PUBLIC	_cJSON_CreateObject@0
PUBLIC	_cJSON_CreateStringReference@4
PUBLIC	_cJSON_CreateObjectReference@4
PUBLIC	_cJSON_CreateArrayReference@4
PUBLIC	_cJSON_CreateIntArray@8
PUBLIC	_cJSON_CreateFloatArray@8
PUBLIC	_cJSON_CreateDoubleArray@8
PUBLIC	_cJSON_CreateStringArray@8
PUBLIC	_cJSON_AddItemToArray@8
PUBLIC	_cJSON_AddItemToObject@12
PUBLIC	_cJSON_AddItemToObjectCS@12
PUBLIC	_cJSON_AddItemReferenceToArray@8
PUBLIC	_cJSON_AddItemReferenceToObject@12
PUBLIC	_cJSON_DetachItemViaPointer@8
PUBLIC	_cJSON_DetachItemFromArray@8
PUBLIC	_cJSON_DeleteItemFromArray@8
PUBLIC	_cJSON_DetachItemFromObject@8
PUBLIC	_cJSON_DetachItemFromObjectCaseSensitive@8
PUBLIC	_cJSON_DeleteItemFromObject@8
PUBLIC	_cJSON_DeleteItemFromObjectCaseSensitive@8
PUBLIC	_cJSON_InsertItemInArray@12
PUBLIC	_cJSON_ReplaceItemViaPointer@12
PUBLIC	_cJSON_ReplaceItemInArray@12
PUBLIC	_cJSON_ReplaceItemInObject@12
PUBLIC	_cJSON_ReplaceItemInObjectCaseSensitive@12
PUBLIC	_cJSON_Duplicate@8
PUBLIC	_cJSON_Compare@12
PUBLIC	_cJSON_Minify@4
PUBLIC	_cJSON_AddNullToObject@8
PUBLIC	_cJSON_AddTrueToObject@8
PUBLIC	_cJSON_AddFalseToObject@8
PUBLIC	_cJSON_AddBoolToObject@12
PUBLIC	_cJSON_AddNumberToObject@16
PUBLIC	_cJSON_AddStringToObject@12
PUBLIC	_cJSON_AddRawToObject@12
PUBLIC	_cJSON_AddObjectToObject@8
PUBLIC	_cJSON_AddArrayToObject@8
PUBLIC	_cJSON_SetNumberHelper@12
PUBLIC	_cJSON_malloc@4
PUBLIC	_cJSON_free@4
PUBLIC	__real@0000000000000000
PUBLIC	__real@41dfffffffc00000
PUBLIC	__real@c1e0000000000000
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	_strncmp:PROC
EXTRN	__hx_sprintf:PROC
EXTRN	__hx_malloc:PROC
EXTRN	__hx_free:PROC
EXTRN	__hx_realloc:PROC
EXTRN	_strtod:PROC
EXTRN	_sscanf:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	__fltused:DWORD
_BSS	SEGMENT
?version@?1??cJSON_Version@@9@9 DB 0fH DUP (?)		; `cJSON_Version'::`2'::version
_BSS	ENDS
;	COMDAT __real@c1e0000000000000
CONST	SEGMENT
__real@c1e0000000000000 DQ 0c1e0000000000000r	; -2.14748e+009
CONST	ENDS
;	COMDAT __real@41dfffffffc00000
CONST	SEGMENT
__real@41dfffffffc00000 DQ 041dfffffffc00000r	; 2.14748e+009
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _replace_item_in_object
_TEXT	SEGMENT
_object$ = 8						; size = 4
_string$ = 12						; size = 4
_replacement$ = 16					; size = 4
_case_sensitive$ = 20					; size = 4
_replace_item_in_object PROC				; COMDAT

; 2211 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2212 : 	if ((replacement == NULL) || (string == NULL))

  00003	83 7d 10 00	 cmp	 DWORD PTR _replacement$[ebp], 0
  00007	74 06		 je	 SHORT $LN2@replace_it
  00009	83 7d 0c 00	 cmp	 DWORD PTR _string$[ebp], 0
  0000d	75 04		 jne	 SHORT $LN3@replace_it
$LN2@replace_it:

; 2213 : 	{
; 2214 : 		return false;

  0000f	33 c0		 xor	 eax, eax
  00011	eb 72		 jmp	 SHORT $LN4@replace_it
$LN3@replace_it:

; 2215 : 	}
; 2216 : 
; 2217 : 	/* replace the name in the replacement */
; 2218 : 	if (!(replacement->type & cJSON_StringIsConst) && (replacement->string != NULL))

  00013	8b 45 10	 mov	 eax, DWORD PTR _replacement$[ebp]
  00016	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00019	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  0001f	75 15		 jne	 SHORT $LN1@replace_it
  00021	8b 55 10	 mov	 edx, DWORD PTR _replacement$[ebp]
  00024	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  00028	74 0c		 je	 SHORT $LN1@replace_it

; 2219 : 	{
; 2220 : 		cJSON_free(replacement->string);

  0002a	8b 45 10	 mov	 eax, DWORD PTR _replacement$[ebp]
  0002d	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 _cJSON_free@4
$LN1@replace_it:

; 2221 : 	}
; 2222 : 	replacement->string = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);

  00036	68 00 00 00 00	 push	 OFFSET _global_hooks
  0003b	8b 55 0c	 mov	 edx, DWORD PTR _string$[ebp]
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 _cJSON_strdup
  00044	83 c4 08	 add	 esp, 8
  00047	8b 4d 10	 mov	 ecx, DWORD PTR _replacement$[ebp]
  0004a	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 2223 : 	replacement->type &= ~cJSON_StringIsConst;

  0004d	8b 55 10	 mov	 edx, DWORD PTR _replacement$[ebp]
  00050	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00053	25 ff fd ff ff	 and	 eax, -513		; fffffdffH
  00058	8b 4d 10	 mov	 ecx, DWORD PTR _replacement$[ebp]
  0005b	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 2224 : 
; 2225 : 	cJSON_ReplaceItemViaPointer(object, get_object_item(object, string, case_sensitive), replacement);

  0005e	8b 55 10	 mov	 edx, DWORD PTR _replacement$[ebp]
  00061	52		 push	 edx
  00062	8b 45 14	 mov	 eax, DWORD PTR _case_sensitive$[ebp]
  00065	50		 push	 eax
  00066	8b 4d 0c	 mov	 ecx, DWORD PTR _string$[ebp]
  00069	51		 push	 ecx
  0006a	8b 55 08	 mov	 edx, DWORD PTR _object$[ebp]
  0006d	52		 push	 edx
  0006e	e8 00 00 00 00	 call	 _get_object_item
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	50		 push	 eax
  00077	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _cJSON_ReplaceItemViaPointer@12

; 2226 : 
; 2227 : 	return true;

  00080	b8 01 00 00 00	 mov	 eax, 1
$LN4@replace_it:

; 2228 : }

  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
_replace_item_in_object ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _add_item_to_object
_TEXT	SEGMENT
_new_type$ = -8						; size = 4
_new_key$ = -4						; size = 4
_object$ = 8						; size = 4
_string$ = 12						; size = 4
_item$ = 16						; size = 4
_hooks$ = 20						; size = 4
_constant_key$ = 24					; size = 4
_add_item_to_object PROC				; COMDAT

; 1891 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1892 : 	char *new_key = NULL;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _new_key$[ebp], 0

; 1893 : 	int new_type = cJSON_Invalid;

  0000d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _new_type$[ebp], 0

; 1894 : 
; 1895 : 	if ((object == NULL) || (string == NULL) || (item == NULL))

  00014	83 7d 08 00	 cmp	 DWORD PTR _object$[ebp], 0
  00018	74 0c		 je	 SHORT $LN5@add_item_t
  0001a	83 7d 0c 00	 cmp	 DWORD PTR _string$[ebp], 0
  0001e	74 06		 je	 SHORT $LN5@add_item_t
  00020	83 7d 10 00	 cmp	 DWORD PTR _item$[ebp], 0
  00024	75 07		 jne	 SHORT $LN6@add_item_t
$LN5@add_item_t:

; 1896 : 	{
; 1897 : 		return false;

  00026	33 c0		 xor	 eax, eax
  00028	e9 9c 00 00 00	 jmp	 $LN7@add_item_t
$LN6@add_item_t:

; 1898 : 	}
; 1899 : 
; 1900 : 	if (constant_key)

  0002d	83 7d 18 00	 cmp	 DWORD PTR _constant_key$[ebp], 0
  00031	74 20		 je	 SHORT $LN4@add_item_t

; 1901 : 	{
; 1902 : 		new_key = (char*)cast_away_const(string);

  00033	8b 45 0c	 mov	 eax, DWORD PTR _string$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 _cast_away_const
  0003c	83 c4 04	 add	 esp, 4
  0003f	89 45 fc	 mov	 DWORD PTR _new_key$[ebp], eax

; 1903 : 		new_type = item->type | cJSON_StringIsConst;

  00042	8b 4d 10	 mov	 ecx, DWORD PTR _item$[ebp]
  00045	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00048	81 ca 00 02 00
	00		 or	 edx, 512		; 00000200H
  0004e	89 55 f8	 mov	 DWORD PTR _new_type$[ebp], edx

; 1904 : 	}
; 1905 : 	else

  00051	eb 2b		 jmp	 SHORT $LN3@add_item_t
$LN4@add_item_t:

; 1906 : 	{
; 1907 : 		new_key = (char*)cJSON_strdup((const unsigned char*)string, hooks);

  00053	8b 45 14	 mov	 eax, DWORD PTR _hooks$[ebp]
  00056	50		 push	 eax
  00057	8b 4d 0c	 mov	 ecx, DWORD PTR _string$[ebp]
  0005a	51		 push	 ecx
  0005b	e8 00 00 00 00	 call	 _cJSON_strdup
  00060	83 c4 08	 add	 esp, 8
  00063	89 45 fc	 mov	 DWORD PTR _new_key$[ebp], eax

; 1908 : 		if (new_key == NULL)

  00066	83 7d fc 00	 cmp	 DWORD PTR _new_key$[ebp], 0
  0006a	75 04		 jne	 SHORT $LN2@add_item_t

; 1909 : 		{
; 1910 : 			return false;

  0006c	33 c0		 xor	 eax, eax
  0006e	eb 59		 jmp	 SHORT $LN7@add_item_t
$LN2@add_item_t:

; 1911 : 		}
; 1912 : 
; 1913 : 		new_type = item->type & ~cJSON_StringIsConst;

  00070	8b 55 10	 mov	 edx, DWORD PTR _item$[ebp]
  00073	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00076	25 ff fd ff ff	 and	 eax, -513		; fffffdffH
  0007b	89 45 f8	 mov	 DWORD PTR _new_type$[ebp], eax
$LN3@add_item_t:

; 1914 : 	}
; 1915 : 
; 1916 : 	if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))

  0007e	8b 4d 10	 mov	 ecx, DWORD PTR _item$[ebp]
  00081	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00084	81 e2 00 02 00
	00		 and	 edx, 512		; 00000200H
  0008a	75 1b		 jne	 SHORT $LN1@add_item_t
  0008c	8b 45 10	 mov	 eax, DWORD PTR _item$[ebp]
  0008f	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00093	74 12		 je	 SHORT $LN1@add_item_t

; 1917 : 	{
; 1918 : 		hooks->deallocate(item->string);

  00095	8b 4d 10	 mov	 ecx, DWORD PTR _item$[ebp]
  00098	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0009b	52		 push	 edx
  0009c	8b 45 14	 mov	 eax, DWORD PTR _hooks$[ebp]
  0009f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000a2	ff d1		 call	 ecx
  000a4	83 c4 04	 add	 esp, 4
$LN1@add_item_t:

; 1919 : 	}
; 1920 : 
; 1921 : 	item->string = new_key;

  000a7	8b 55 10	 mov	 edx, DWORD PTR _item$[ebp]
  000aa	8b 45 fc	 mov	 eax, DWORD PTR _new_key$[ebp]
  000ad	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 1922 : 	item->type = new_type;

  000b0	8b 4d 10	 mov	 ecx, DWORD PTR _item$[ebp]
  000b3	8b 55 f8	 mov	 edx, DWORD PTR _new_type$[ebp]
  000b6	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 1923 : 
; 1924 : 	return add_item_to_array(object, item);

  000b9	8b 45 10	 mov	 eax, DWORD PTR _item$[ebp]
  000bc	50		 push	 eax
  000bd	8b 4d 08	 mov	 ecx, DWORD PTR _object$[ebp]
  000c0	51		 push	 ecx
  000c1	e8 00 00 00 00	 call	 _add_item_to_array
  000c6	83 c4 08	 add	 esp, 8
$LN7@add_item_t:

; 1925 : }

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
_add_item_to_object ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cast_away_const
_TEXT	SEGMENT
_string$ = 8						; size = 4
_cast_away_const PROC					; COMDAT

; 1882 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1883 : 	return (void*)string;

  00003	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]

; 1884 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
_cast_away_const ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _add_item_to_array
_TEXT	SEGMENT
_child$ = -4						; size = 4
_array$ = 8						; size = 4
_item$ = 12						; size = 4
_add_item_to_array PROC					; COMDAT

; 1840 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1841 : 	cJSON *child = NULL;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _child$[ebp], 0

; 1842 : 
; 1843 : 	if ((item == NULL) || (array == NULL))

  0000b	83 7d 0c 00	 cmp	 DWORD PTR _item$[ebp], 0
  0000f	74 06		 je	 SHORT $LN5@add_item_t
  00011	83 7d 08 00	 cmp	 DWORD PTR _array$[ebp], 0
  00015	75 04		 jne	 SHORT $LN6@add_item_t
$LN5@add_item_t:

; 1844 : 	{
; 1845 : 		return false;

  00017	33 c0		 xor	 eax, eax
  00019	eb 41		 jmp	 SHORT $LN7@add_item_t
$LN6@add_item_t:

; 1846 : 	}
; 1847 : 
; 1848 : 	child = array->child;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _array$[ebp]
  0001e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00021	89 4d fc	 mov	 DWORD PTR _child$[ebp], ecx

; 1849 : 
; 1850 : 	if (child == NULL)

  00024	83 7d fc 00	 cmp	 DWORD PTR _child$[ebp], 0
  00028	75 0b		 jne	 SHORT $LN2@add_item_t

; 1851 : 	{
; 1852 : 		/* list is empty, start new one */
; 1853 : 		array->child = item;

  0002a	8b 55 08	 mov	 edx, DWORD PTR _array$[ebp]
  0002d	8b 45 0c	 mov	 eax, DWORD PTR _item$[ebp]
  00030	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 1854 : 	}
; 1855 : 	else

  00033	eb 22		 jmp	 SHORT $LN3@add_item_t
$LN2@add_item_t:

; 1856 : 	{
; 1857 : 		/* append to the end */
; 1858 : 		while (child->next)

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _child$[ebp]
  00038	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0003b	74 0a		 je	 SHORT $LN1@add_item_t

; 1859 : 		{
; 1860 : 			child = child->next;

  0003d	8b 55 fc	 mov	 edx, DWORD PTR _child$[ebp]
  00040	8b 02		 mov	 eax, DWORD PTR [edx]
  00042	89 45 fc	 mov	 DWORD PTR _child$[ebp], eax

; 1861 : 		}

  00045	eb ee		 jmp	 SHORT $LN2@add_item_t
$LN1@add_item_t:

; 1862 : 		suffix_object(child, item);

  00047	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  0004a	51		 push	 ecx
  0004b	8b 55 fc	 mov	 edx, DWORD PTR _child$[ebp]
  0004e	52		 push	 edx
  0004f	e8 00 00 00 00	 call	 _suffix_object
  00054	83 c4 08	 add	 esp, 8
$LN3@add_item_t:

; 1863 : 	}
; 1864 : 
; 1865 : 	return true;

  00057	b8 01 00 00 00	 mov	 eax, 1
$LN7@add_item_t:

; 1866 : }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_add_item_to_array ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _create_reference
_TEXT	SEGMENT
_reference$ = -4					; size = 4
_item$ = 8						; size = 4
_hooks$ = 12						; size = 4
_create_reference PROC					; COMDAT

; 1819 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1820 : 	cJSON *reference = NULL;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _reference$[ebp], 0

; 1821 : 	if (item == NULL)

  0000b	83 7d 08 00	 cmp	 DWORD PTR _item$[ebp], 0
  0000f	75 04		 jne	 SHORT $LN2@create_ref

; 1822 : 	{
; 1823 : 		return NULL;

  00011	33 c0		 xor	 eax, eax
  00013	eb 5d		 jmp	 SHORT $LN3@create_ref
$LN2@create_ref:

; 1824 : 	}
; 1825 : 
; 1826 : 	reference = cJSON_New_Item(hooks);

  00015	8b 45 0c	 mov	 eax, DWORD PTR _hooks$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _cJSON_New_Item
  0001e	83 c4 04	 add	 esp, 4
  00021	89 45 fc	 mov	 DWORD PTR _reference$[ebp], eax

; 1827 : 	if (reference == NULL)

  00024	83 7d fc 00	 cmp	 DWORD PTR _reference$[ebp], 0
  00028	75 04		 jne	 SHORT $LN1@create_ref

; 1828 : 	{
; 1829 : 		return NULL;

  0002a	33 c0		 xor	 eax, eax
  0002c	eb 44		 jmp	 SHORT $LN3@create_ref
$LN1@create_ref:

; 1830 : 	}
; 1831 : 
; 1832 : 	memcpy(reference, item, sizeof(cJSON));

  0002e	6a 28		 push	 40			; 00000028H
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00033	51		 push	 ecx
  00034	8b 55 fc	 mov	 edx, DWORD PTR _reference$[ebp]
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 _memcpy
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1833 : 	reference->string = NULL;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _reference$[ebp]
  00043	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 1834 : 	reference->type |= cJSON_IsReference;

  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _reference$[ebp]
  0004d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00050	81 ca 00 01 00
	00		 or	 edx, 256		; 00000100H
  00056	8b 45 fc	 mov	 eax, DWORD PTR _reference$[ebp]
  00059	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 1835 : 	reference->next = reference->prev = NULL;

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _reference$[ebp]
  0005f	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00066	8b 55 fc	 mov	 edx, DWORD PTR _reference$[ebp]
  00069	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1836 : 	return reference;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _reference$[ebp]
$LN3@create_ref:

; 1837 : }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
_create_reference ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _suffix_object
_TEXT	SEGMENT
_prev$ = 8						; size = 4
_item$ = 12						; size = 4
_suffix_object PROC					; COMDAT

; 1812 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1813 : 	prev->next = item;

  00003	8b 45 08	 mov	 eax, DWORD PTR _prev$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 1814 : 	item->prev = prev;

  0000b	8b 55 0c	 mov	 edx, DWORD PTR _item$[ebp]
  0000e	8b 45 08	 mov	 eax, DWORD PTR _prev$[ebp]
  00011	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1815 : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
_suffix_object ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _get_object_item
_TEXT	SEGMENT
_current_element$ = -4					; size = 4
_object$ = 8						; size = 4
_name$ = 12						; size = 4
_case_sensitive$ = 16					; size = 4
_get_object_item PROC					; COMDAT

; 1768 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1769 : 	cJSON *current_element = NULL;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _current_element$[ebp], 0

; 1770 : 
; 1771 : 	if ((object == NULL) || (name == NULL))

  0000b	83 7d 08 00	 cmp	 DWORD PTR _object$[ebp], 0
  0000f	74 06		 je	 SHORT $LN7@get_object
  00011	83 7d 0c 00	 cmp	 DWORD PTR _name$[ebp], 0
  00015	75 04		 jne	 SHORT $LN8@get_object
$LN7@get_object:

; 1772 : 	{
; 1773 : 		return NULL;

  00017	33 c0		 xor	 eax, eax
  00019	eb 62		 jmp	 SHORT $LN9@get_object
$LN8@get_object:

; 1774 : 	}
; 1775 : 
; 1776 : 	current_element = object->child;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  0001e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00021	89 4d fc	 mov	 DWORD PTR _current_element$[ebp], ecx

; 1777 : 	if (case_sensitive)

  00024	83 7d 10 00	 cmp	 DWORD PTR _case_sensitive$[ebp], 0
  00028	74 29		 je	 SHORT $LN2@get_object
$LN5@get_object:

; 1778 : 	{
; 1779 : 		while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))

  0002a	83 7d fc 00	 cmp	 DWORD PTR _current_element$[ebp], 0
  0002e	74 21		 je	 SHORT $LN4@get_object
  00030	8b 55 fc	 mov	 edx, DWORD PTR _current_element$[ebp]
  00033	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00036	50		 push	 eax
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _name$[ebp]
  0003a	51		 push	 ecx
  0003b	e8 00 00 00 00	 call	 _strcmp
  00040	83 c4 08	 add	 esp, 8
  00043	85 c0		 test	 eax, eax
  00045	74 0a		 je	 SHORT $LN4@get_object

; 1780 : 		{
; 1781 : 			current_element = current_element->next;

  00047	8b 55 fc	 mov	 edx, DWORD PTR _current_element$[ebp]
  0004a	8b 02		 mov	 eax, DWORD PTR [edx]
  0004c	89 45 fc	 mov	 DWORD PTR _current_element$[ebp], eax

; 1782 : 		}

  0004f	eb d9		 jmp	 SHORT $LN5@get_object
$LN4@get_object:

; 1783 : 	}
; 1784 : 	else

  00051	eb 27		 jmp	 SHORT $LN3@get_object
$LN2@get_object:

; 1785 : 	{
; 1786 : 		while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))

  00053	83 7d fc 00	 cmp	 DWORD PTR _current_element$[ebp], 0
  00057	74 21		 je	 SHORT $LN3@get_object
  00059	8b 4d fc	 mov	 ecx, DWORD PTR _current_element$[ebp]
  0005c	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0005f	52		 push	 edx
  00060	8b 45 0c	 mov	 eax, DWORD PTR _name$[ebp]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _case_insensitive_strcmp
  00069	83 c4 08	 add	 esp, 8
  0006c	85 c0		 test	 eax, eax
  0006e	74 0a		 je	 SHORT $LN3@get_object

; 1787 : 		{
; 1788 : 			current_element = current_element->next;

  00070	8b 4d fc	 mov	 ecx, DWORD PTR _current_element$[ebp]
  00073	8b 11		 mov	 edx, DWORD PTR [ecx]
  00075	89 55 fc	 mov	 DWORD PTR _current_element$[ebp], edx

; 1789 : 		}

  00078	eb d9		 jmp	 SHORT $LN2@get_object
$LN3@get_object:

; 1790 : 	}
; 1791 : 
; 1792 : 	return current_element;

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _current_element$[ebp]
$LN9@get_object:

; 1793 : }

  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
_get_object_item ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _get_array_item
_TEXT	SEGMENT
_current_child$ = -4					; size = 4
_array$ = 8						; size = 4
_index$ = 12						; size = 4
_get_array_item PROC					; COMDAT

; 1739 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1740 : 	cJSON *current_child = NULL;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _current_child$[ebp], 0

; 1741 : 
; 1742 : 	if (array == NULL)

  0000b	83 7d 08 00	 cmp	 DWORD PTR _array$[ebp], 0
  0000f	75 04		 jne	 SHORT $LN3@get_array_

; 1743 : 	{
; 1744 : 		return NULL;

  00011	33 c0		 xor	 eax, eax
  00013	eb 2b		 jmp	 SHORT $LN4@get_array_
$LN3@get_array_:

; 1745 : 	}
; 1746 : 
; 1747 : 	current_child = array->child;

  00015	8b 45 08	 mov	 eax, DWORD PTR _array$[ebp]
  00018	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001b	89 4d fc	 mov	 DWORD PTR _current_child$[ebp], ecx
$LN2@get_array_:

; 1748 : 	while ((current_child != NULL) && (index > 0))

  0001e	83 7d fc 00	 cmp	 DWORD PTR _current_child$[ebp], 0
  00022	74 19		 je	 SHORT $LN1@get_array_
  00024	83 7d 0c 00	 cmp	 DWORD PTR _index$[ebp], 0
  00028	76 13		 jbe	 SHORT $LN1@get_array_

; 1749 : 	{
; 1750 : 		index--;

  0002a	8b 55 0c	 mov	 edx, DWORD PTR _index$[ebp]
  0002d	83 ea 01	 sub	 edx, 1
  00030	89 55 0c	 mov	 DWORD PTR _index$[ebp], edx

; 1751 : 		current_child = current_child->next;

  00033	8b 45 fc	 mov	 eax, DWORD PTR _current_child$[ebp]
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	89 4d fc	 mov	 DWORD PTR _current_child$[ebp], ecx

; 1752 : 	}

  0003b	eb e1		 jmp	 SHORT $LN2@get_array_
$LN1@get_array_:

; 1753 : 
; 1754 : 	return current_child;

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _current_child$[ebp]
$LN4@get_array_:

; 1755 : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
_get_array_item ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _print
_TEXT	SEGMENT
_buffer$ = -44						; size = 36
tv94 = -8						; size = 4
_printed$ = -4						; size = 4
_item$ = 8						; size = 4
_format$ = 12						; size = 4
_hooks$ = 16						; size = 4
_print	PROC						; COMDAT

; 1085 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 1086 : 	static const size_t default_buffer_size = 256;
; 1087 : 	printbuffer buffer[1];
; 1088 : 	unsigned char *printed = NULL;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _printed$[ebp], 0

; 1089 : 
; 1090 : 	memset(buffer, 0, sizeof(buffer));

  0000d	6a 24		 push	 36			; 00000024H
  0000f	6a 00		 push	 0
  00011	8d 45 d4	 lea	 eax, DWORD PTR _buffer$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _memset
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1091 : 
; 1092 : 	/* create buffer */
; 1093 : 	buffer->buffer = (unsigned char*)hooks->allocate(default_buffer_size);

  0001d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?default_buffer_size@?1??print@@9@9
  00023	51		 push	 ecx
  00024	8b 55 10	 mov	 edx, DWORD PTR _hooks$[ebp]
  00027	8b 02		 mov	 eax, DWORD PTR [edx]
  00029	ff d0		 call	 eax
  0002b	83 c4 04	 add	 esp, 4
  0002e	89 45 d4	 mov	 DWORD PTR _buffer$[ebp], eax

; 1094 : 	buffer->length = default_buffer_size;

  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?default_buffer_size@?1??print@@9@9
  00037	89 4d d8	 mov	 DWORD PTR _buffer$[ebp+4], ecx

; 1095 : 	buffer->format = format;

  0003a	8b 55 0c	 mov	 edx, DWORD PTR _format$[ebp]
  0003d	89 55 e8	 mov	 DWORD PTR _buffer$[ebp+20], edx

; 1096 : 	buffer->hooks = *hooks;

  00040	8b 45 10	 mov	 eax, DWORD PTR _hooks$[ebp]
  00043	8b 08		 mov	 ecx, DWORD PTR [eax]
  00045	89 4d ec	 mov	 DWORD PTR _buffer$[ebp+24], ecx
  00048	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0004b	89 55 f0	 mov	 DWORD PTR _buffer$[ebp+28], edx
  0004e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00051	89 45 f4	 mov	 DWORD PTR _buffer$[ebp+32], eax

; 1097 : 	if (buffer->buffer == NULL)

  00054	83 7d d4 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  00058	75 05		 jne	 SHORT $LN8@print

; 1098 : 	{
; 1099 : 		goto fail;

  0005a	e9 c1 00 00 00	 jmp	 $fail$13
$LN8@print:

; 1100 : 	}
; 1101 : 
; 1102 : 	/* print the value */
; 1103 : 	if (!print_value(item, buffer))

  0005f	8d 4d d4	 lea	 ecx, DWORD PTR _buffer$[ebp]
  00062	51		 push	 ecx
  00063	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00066	52		 push	 edx
  00067	e8 00 00 00 00	 call	 _print_value
  0006c	83 c4 08	 add	 esp, 8
  0006f	85 c0		 test	 eax, eax
  00071	75 05		 jne	 SHORT $LN7@print

; 1104 : 	{
; 1105 : 		goto fail;

  00073	e9 a8 00 00 00	 jmp	 $fail$13
$LN7@print:

; 1106 : 	}
; 1107 : 	update_offset(buffer);

  00078	8d 45 d4	 lea	 eax, DWORD PTR _buffer$[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 _update_offset
  00081	83 c4 04	 add	 esp, 4

; 1108 : 
; 1109 : 	/* check if reallocate is available */
; 1110 : 	if (hooks->reallocate != NULL)

  00084	8b 4d 10	 mov	 ecx, DWORD PTR _hooks$[ebp]
  00087	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  0008b	74 2a		 je	 SHORT $LN6@print

; 1111 : 	{
; 1112 : 		printed = (unsigned char*)hooks->reallocate(buffer->buffer, buffer->offset + 1);

  0008d	8b 55 dc	 mov	 edx, DWORD PTR _buffer$[ebp+8]
  00090	83 c2 01	 add	 edx, 1
  00093	52		 push	 edx
  00094	8b 45 d4	 mov	 eax, DWORD PTR _buffer$[ebp]
  00097	50		 push	 eax
  00098	8b 4d 10	 mov	 ecx, DWORD PTR _hooks$[ebp]
  0009b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0009e	ff d2		 call	 edx
  000a0	83 c4 08	 add	 esp, 8
  000a3	89 45 fc	 mov	 DWORD PTR _printed$[ebp], eax

; 1113 : 		buffer->buffer = NULL;

  000a6	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _buffer$[ebp], 0

; 1114 : 		if (printed == NULL) {

  000ad	83 7d fc 00	 cmp	 DWORD PTR _printed$[ebp], 0
  000b1	75 02		 jne	 SHORT $LN5@print

; 1115 : 			goto fail;

  000b3	eb 6b		 jmp	 SHORT $fail$13
$LN5@print:

; 1116 : 		}
; 1117 : 	}
; 1118 : 	else /* otherwise copy the JSON over to a new buffer */

  000b5	eb 64		 jmp	 SHORT $LN4@print
$LN6@print:

; 1119 : 	{
; 1120 : 		printed = (unsigned char*)hooks->allocate(buffer->offset + 1);

  000b7	8b 45 dc	 mov	 eax, DWORD PTR _buffer$[ebp+8]
  000ba	83 c0 01	 add	 eax, 1
  000bd	50		 push	 eax
  000be	8b 4d 10	 mov	 ecx, DWORD PTR _hooks$[ebp]
  000c1	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c3	ff d2		 call	 edx
  000c5	83 c4 04	 add	 esp, 4
  000c8	89 45 fc	 mov	 DWORD PTR _printed$[ebp], eax

; 1121 : 		if (printed == NULL)

  000cb	83 7d fc 00	 cmp	 DWORD PTR _printed$[ebp], 0
  000cf	75 02		 jne	 SHORT $LN3@print

; 1122 : 		{
; 1123 : 			goto fail;

  000d1	eb 4d		 jmp	 SHORT $fail$13
$LN3@print:

; 1124 : 		}
; 1125 : 		memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset + 1));

  000d3	8b 45 dc	 mov	 eax, DWORD PTR _buffer$[ebp+8]
  000d6	83 c0 01	 add	 eax, 1
  000d9	39 45 d8	 cmp	 DWORD PTR _buffer$[ebp+4], eax
  000dc	73 08		 jae	 SHORT $LN11@print
  000de	8b 4d d8	 mov	 ecx, DWORD PTR _buffer$[ebp+4]
  000e1	89 4d f8	 mov	 DWORD PTR tv94[ebp], ecx
  000e4	eb 09		 jmp	 SHORT $LN12@print
$LN11@print:
  000e6	8b 55 dc	 mov	 edx, DWORD PTR _buffer$[ebp+8]
  000e9	83 c2 01	 add	 edx, 1
  000ec	89 55 f8	 mov	 DWORD PTR tv94[ebp], edx
$LN12@print:
  000ef	8b 45 f8	 mov	 eax, DWORD PTR tv94[ebp]
  000f2	50		 push	 eax
  000f3	8b 4d d4	 mov	 ecx, DWORD PTR _buffer$[ebp]
  000f6	51		 push	 ecx
  000f7	8b 55 fc	 mov	 edx, DWORD PTR _printed$[ebp]
  000fa	52		 push	 edx
  000fb	e8 00 00 00 00	 call	 _memcpy
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1126 : 		printed[buffer->offset] = '\0'; /* just to be sure */

  00103	8b 45 fc	 mov	 eax, DWORD PTR _printed$[ebp]
  00106	03 45 dc	 add	 eax, DWORD PTR _buffer$[ebp+8]
  00109	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1127 : 
; 1128 : 		/* free the buffer */
; 1129 : 		hooks->deallocate(buffer->buffer);

  0010c	8b 4d d4	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0010f	51		 push	 ecx
  00110	8b 55 10	 mov	 edx, DWORD PTR _hooks$[ebp]
  00113	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00116	ff d0		 call	 eax
  00118	83 c4 04	 add	 esp, 4
$LN4@print:

; 1130 : 	}
; 1131 : 
; 1132 : 	return printed;

  0011b	8b 45 fc	 mov	 eax, DWORD PTR _printed$[ebp]
  0011e	eb 2c		 jmp	 SHORT $LN9@print
$fail$13:

; 1133 : 
; 1134 : fail:
; 1135 : 	if (buffer->buffer != NULL)

  00120	83 7d d4 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  00124	74 0f		 je	 SHORT $LN2@print

; 1136 : 	{
; 1137 : 		hooks->deallocate(buffer->buffer);

  00126	8b 4d d4	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00129	51		 push	 ecx
  0012a	8b 55 10	 mov	 edx, DWORD PTR _hooks$[ebp]
  0012d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00130	ff d0		 call	 eax
  00132	83 c4 04	 add	 esp, 4
$LN2@print:

; 1138 : 	}
; 1139 : 
; 1140 : 	if (printed != NULL)

  00135	83 7d fc 00	 cmp	 DWORD PTR _printed$[ebp], 0
  00139	74 0f		 je	 SHORT $LN1@print

; 1141 : 	{
; 1142 : 		hooks->deallocate(printed);

  0013b	8b 4d fc	 mov	 ecx, DWORD PTR _printed$[ebp]
  0013e	51		 push	 ecx
  0013f	8b 55 10	 mov	 edx, DWORD PTR _hooks$[ebp]
  00142	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00145	ff d0		 call	 eax
  00147	83 c4 04	 add	 esp, 4
$LN1@print:

; 1143 : 	}
; 1144 : 
; 1145 : 	return NULL;

  0014a	33 c0		 xor	 eax, eax
$LN9@print:

; 1146 : }

  0014c	8b e5		 mov	 esp, ebp
  0014e	5d		 pop	 ebp
  0014f	c3		 ret	 0
_print	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _skip_utf8_bom
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_skip_utf8_bom PROC					; COMDAT

; 982  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 983  : 	if ((buffer == NULL) || (buffer->content == NULL) || (buffer->offset != 0))

  00003	83 7d 08 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  00007	74 11		 je	 SHORT $LN2@skip_utf8_
  00009	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 09		 je	 SHORT $LN2@skip_utf8_
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00014	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00018	74 04		 je	 SHORT $LN3@skip_utf8_
$LN2@skip_utf8_:

; 984  : 	{
; 985  : 		return NULL;

  0001a	33 c0		 xor	 eax, eax
  0001c	eb 48		 jmp	 SHORT $LN4@skip_utf8_
$LN3@skip_utf8_:

; 986  : 	}
; 987  : 
; 988  : 	if (can_access_at_index(buffer, 4) && (strncmp((const char*)buffer_at_offset(buffer), "\xEF\xBB\xBF", 3) == 0))

  0001e	83 7d 08 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  00022	74 3f		 je	 SHORT $LN1@skip_utf8_
  00024	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00027	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0002a	83 c0 04	 add	 eax, 4
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00030	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00033	73 2e		 jae	 SHORT $LN1@skip_utf8_
  00035	6a 03		 push	 3
  00037	68 00 00 00 00	 push	 OFFSET $SG2766
  0003c	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  0003f	8b 02		 mov	 eax, DWORD PTR [edx]
  00041	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00044	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _strncmp
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	85 c0		 test	 eax, eax
  00052	75 0f		 jne	 SHORT $LN1@skip_utf8_

; 989  : 	{
; 990  : 		buffer->offset += 3;

  00054	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00057	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0005a	83 c0 03	 add	 eax, 3
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00060	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN1@skip_utf8_:

; 991  : 	}
; 992  : 
; 993  : 	return buffer;

  00063	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
$LN4@skip_utf8_:

; 994  : }

  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
_skip_utf8_bom ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _buffer_skip_whitespace
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_buffer_skip_whitespace PROC				; COMDAT

; 961  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 962  : 	if ((buffer == NULL) || (buffer->content == NULL))

  00003	83 7d 08 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  00007	74 08		 je	 SHORT $LN4@buffer_ski
  00009	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	75 04		 jne	 SHORT $LN3@buffer_ski
$LN4@buffer_ski:

; 963  : 	{
; 964  : 		return NULL;

  00011	33 c0		 xor	 eax, eax
  00013	eb 61		 jmp	 SHORT $LN6@buffer_ski
$LN3@buffer_ski:

; 965  : 	}
; 966  : 
; 967  : 	while (can_access_at_index(buffer, 0) && (buffer_at_offset(buffer)[0] <= 32))

  00015	83 7d 08 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  00019	74 3b		 je	 SHORT $LN2@buffer_ski
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0001e	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00021	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00024	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00027	73 2d		 jae	 SHORT $LN2@buffer_ski
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0002c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002e	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00031	03 50 08	 add	 edx, DWORD PTR [eax+8]
  00034	b9 01 00 00 00	 mov	 ecx, 1
  00039	6b c1 00	 imul	 eax, ecx, 0
  0003c	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  00040	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00043	7f 11		 jg	 SHORT $LN2@buffer_ski

; 968  : 	{
; 969  : 		buffer->offset++;

  00045	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00048	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0004b	83 c0 01	 add	 eax, 1
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00051	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 970  : 	}

  00054	eb bf		 jmp	 SHORT $LN3@buffer_ski
$LN2@buffer_ski:

; 971  : 
; 972  : 	if (buffer->offset == buffer->length)

  00056	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00059	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  0005c	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0005f	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00062	75 0f		 jne	 SHORT $LN1@buffer_ski

; 973  : 	{
; 974  : 		buffer->offset--;

  00064	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00067	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0006a	83 e8 01	 sub	 eax, 1
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00070	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN1@buffer_ski:

; 975  : 	}
; 976  : 
; 977  : 	return buffer;

  00073	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
$LN6@buffer_ski:

; 978  : }

  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
_buffer_skip_whitespace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _print_object
_TEXT	SEGMENT
tv185 = -40						; size = 4
tv163 = -36						; size = 4
tv160 = -32						; size = 4
tv141 = -28						; size = 4
tv68 = -24						; size = 4
_i$1 = -20						; size = 4
_i$2 = -16						; size = 4
_current_item$ = -12					; size = 4
_length$ = -8						; size = 4
_output_pointer$ = -4					; size = 4
_item$ = 8						; size = 4
_output_buffer$ = 12					; size = 4
_print_object PROC					; COMDAT

; 1602 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 1603 : 	unsigned char *output_pointer = NULL;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _output_pointer$[ebp], 0

; 1604 : 	size_t length = 0;

  0000d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _length$[ebp], 0

; 1605 : 	cJSON *current_item = item->child;

  00014	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00017	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001a	89 4d f4	 mov	 DWORD PTR _current_item$[ebp], ecx

; 1606 : 
; 1607 : 	if (output_buffer == NULL)

  0001d	83 7d 0c 00	 cmp	 DWORD PTR _output_buffer$[ebp], 0
  00021	75 07		 jne	 SHORT $LN22@print_obje

; 1608 : 	{
; 1609 : 		return false;

  00023	33 c0		 xor	 eax, eax
  00025	e9 0f 03 00 00	 jmp	 $LN23@print_obje
$LN22@print_obje:

; 1610 : 	}
; 1611 : 
; 1612 : 	/* Compose the output: */
; 1613 : 	length = (size_t)(output_buffer->format ? 2 : 1); /* fmt: {\n */

  0002a	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  0002d	83 7a 14 00	 cmp	 DWORD PTR [edx+20], 0
  00031	74 09		 je	 SHORT $LN25@print_obje
  00033	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR tv68[ebp], 2
  0003a	eb 07		 jmp	 SHORT $LN26@print_obje
$LN25@print_obje:
  0003c	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
$LN26@print_obje:
  00043	8b 45 e8	 mov	 eax, DWORD PTR tv68[ebp]
  00046	89 45 f8	 mov	 DWORD PTR _length$[ebp], eax

; 1614 : 	output_pointer = ensure(output_buffer, length + 1);

  00049	8b 4d f8	 mov	 ecx, DWORD PTR _length$[ebp]
  0004c	83 c1 01	 add	 ecx, 1
  0004f	51		 push	 ecx
  00050	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 _ensure
  00059	83 c4 08	 add	 esp, 8
  0005c	89 45 fc	 mov	 DWORD PTR _output_pointer$[ebp], eax

; 1615 : 	if (output_pointer == NULL)

  0005f	83 7d fc 00	 cmp	 DWORD PTR _output_pointer$[ebp], 0
  00063	75 07		 jne	 SHORT $LN21@print_obje

; 1616 : 	{
; 1617 : 		return false;

  00065	33 c0		 xor	 eax, eax
  00067	e9 cd 02 00 00	 jmp	 $LN23@print_obje
$LN21@print_obje:

; 1618 : 	}
; 1619 : 
; 1620 : 	*output_pointer++ = '{';

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  0006f	c6 00 7b	 mov	 BYTE PTR [eax], 123	; 0000007bH
  00072	8b 4d fc	 mov	 ecx, DWORD PTR _output_pointer$[ebp]
  00075	83 c1 01	 add	 ecx, 1
  00078	89 4d fc	 mov	 DWORD PTR _output_pointer$[ebp], ecx

; 1621 : 	output_buffer->depth++;

  0007b	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  0007e	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00081	83 c0 01	 add	 eax, 1
  00084	8b 4d 0c	 mov	 ecx, DWORD PTR _output_buffer$[ebp]
  00087	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1622 : 	if (output_buffer->format)

  0008a	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  0008d	83 7a 14 00	 cmp	 DWORD PTR [edx+20], 0
  00091	74 0f		 je	 SHORT $LN20@print_obje

; 1623 : 	{
; 1624 : 		*output_pointer++ = '\n';

  00093	8b 45 fc	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  00096	c6 00 0a	 mov	 BYTE PTR [eax], 10	; 0000000aH
  00099	8b 4d fc	 mov	 ecx, DWORD PTR _output_pointer$[ebp]
  0009c	83 c1 01	 add	 ecx, 1
  0009f	89 4d fc	 mov	 DWORD PTR _output_pointer$[ebp], ecx
$LN20@print_obje:

; 1625 : 	}
; 1626 : 	output_buffer->offset += length;

  000a2	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  000a5	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000a8	03 45 f8	 add	 eax, DWORD PTR _length$[ebp]
  000ab	8b 4d 0c	 mov	 ecx, DWORD PTR _output_buffer$[ebp]
  000ae	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN19@print_obje:

; 1627 : 
; 1628 : 	while (current_item)

  000b1	83 7d f4 00	 cmp	 DWORD PTR _current_item$[ebp], 0
  000b5	0f 84 e0 01 00
	00		 je	 $LN18@print_obje

; 1629 : 	{
; 1630 : 		if (output_buffer->format)

  000bb	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  000be	83 7a 14 00	 cmp	 DWORD PTR [edx+20], 0
  000c2	74 63		 je	 SHORT $LN17@print_obje

; 1631 : 		{
; 1632 : 			size_t i;
; 1633 : 			output_pointer = ensure(output_buffer, output_buffer->depth);

  000c4	8b 45 0c	 mov	 eax, DWORD PTR _output_buffer$[ebp]
  000c7	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000ca	51		 push	 ecx
  000cb	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  000ce	52		 push	 edx
  000cf	e8 00 00 00 00	 call	 _ensure
  000d4	83 c4 08	 add	 esp, 8
  000d7	89 45 fc	 mov	 DWORD PTR _output_pointer$[ebp], eax

; 1634 : 			if (output_pointer == NULL)

  000da	83 7d fc 00	 cmp	 DWORD PTR _output_pointer$[ebp], 0
  000de	75 07		 jne	 SHORT $LN16@print_obje

; 1635 : 			{
; 1636 : 				return false;

  000e0	33 c0		 xor	 eax, eax
  000e2	e9 52 02 00 00	 jmp	 $LN23@print_obje
$LN16@print_obje:

; 1637 : 			}
; 1638 : 			for (i = 0; i < output_buffer->depth; i++)

  000e7	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$2[ebp], 0
  000ee	eb 09		 jmp	 SHORT $LN15@print_obje
$LN14@print_obje:
  000f0	8b 45 f0	 mov	 eax, DWORD PTR _i$2[ebp]
  000f3	83 c0 01	 add	 eax, 1
  000f6	89 45 f0	 mov	 DWORD PTR _i$2[ebp], eax
$LN15@print_obje:
  000f9	8b 4d 0c	 mov	 ecx, DWORD PTR _output_buffer$[ebp]
  000fc	8b 55 f0	 mov	 edx, DWORD PTR _i$2[ebp]
  000ff	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00102	73 11		 jae	 SHORT $LN13@print_obje

; 1639 : 			{
; 1640 : 				*output_pointer++ = '\t';

  00104	8b 45 fc	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  00107	c6 00 09	 mov	 BYTE PTR [eax], 9
  0010a	8b 4d fc	 mov	 ecx, DWORD PTR _output_pointer$[ebp]
  0010d	83 c1 01	 add	 ecx, 1
  00110	89 4d fc	 mov	 DWORD PTR _output_pointer$[ebp], ecx

; 1641 : 			}

  00113	eb db		 jmp	 SHORT $LN14@print_obje
$LN13@print_obje:

; 1642 : 			output_buffer->offset += output_buffer->depth;

  00115	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  00118	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0011b	8b 4d 0c	 mov	 ecx, DWORD PTR _output_buffer$[ebp]
  0011e	03 41 0c	 add	 eax, DWORD PTR [ecx+12]
  00121	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  00124	89 42 08	 mov	 DWORD PTR [edx+8], eax
$LN17@print_obje:

; 1643 : 		}
; 1644 : 
; 1645 : 		/* print key */
; 1646 : 		if (!print_string_ptr((unsigned char*)current_item->string, output_buffer))

  00127	8b 45 0c	 mov	 eax, DWORD PTR _output_buffer$[ebp]
  0012a	50		 push	 eax
  0012b	8b 4d f4	 mov	 ecx, DWORD PTR _current_item$[ebp]
  0012e	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00131	52		 push	 edx
  00132	e8 00 00 00 00	 call	 _print_string_ptr
  00137	83 c4 08	 add	 esp, 8
  0013a	85 c0		 test	 eax, eax
  0013c	75 07		 jne	 SHORT $LN12@print_obje

; 1647 : 		{
; 1648 : 			return false;

  0013e	33 c0		 xor	 eax, eax
  00140	e9 f4 01 00 00	 jmp	 $LN23@print_obje
$LN12@print_obje:

; 1649 : 		}
; 1650 : 		update_offset(output_buffer);

  00145	8b 45 0c	 mov	 eax, DWORD PTR _output_buffer$[ebp]
  00148	50		 push	 eax
  00149	e8 00 00 00 00	 call	 _update_offset
  0014e	83 c4 04	 add	 esp, 4

; 1651 : 
; 1652 : 		length = (size_t)(output_buffer->format ? 2 : 1);

  00151	8b 4d 0c	 mov	 ecx, DWORD PTR _output_buffer$[ebp]
  00154	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  00158	74 09		 je	 SHORT $LN27@print_obje
  0015a	c7 45 e4 02 00
	00 00		 mov	 DWORD PTR tv141[ebp], 2
  00161	eb 07		 jmp	 SHORT $LN28@print_obje
$LN27@print_obje:
  00163	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv141[ebp], 1
$LN28@print_obje:
  0016a	8b 55 e4	 mov	 edx, DWORD PTR tv141[ebp]
  0016d	89 55 f8	 mov	 DWORD PTR _length$[ebp], edx

; 1653 : 		output_pointer = ensure(output_buffer, length);

  00170	8b 45 f8	 mov	 eax, DWORD PTR _length$[ebp]
  00173	50		 push	 eax
  00174	8b 4d 0c	 mov	 ecx, DWORD PTR _output_buffer$[ebp]
  00177	51		 push	 ecx
  00178	e8 00 00 00 00	 call	 _ensure
  0017d	83 c4 08	 add	 esp, 8
  00180	89 45 fc	 mov	 DWORD PTR _output_pointer$[ebp], eax

; 1654 : 		if (output_pointer == NULL)

  00183	83 7d fc 00	 cmp	 DWORD PTR _output_pointer$[ebp], 0
  00187	75 07		 jne	 SHORT $LN11@print_obje

; 1655 : 		{
; 1656 : 			return false;

  00189	33 c0		 xor	 eax, eax
  0018b	e9 a9 01 00 00	 jmp	 $LN23@print_obje
$LN11@print_obje:

; 1657 : 		}
; 1658 : 		*output_pointer++ = ':';

  00190	8b 55 fc	 mov	 edx, DWORD PTR _output_pointer$[ebp]
  00193	c6 02 3a	 mov	 BYTE PTR [edx], 58	; 0000003aH
  00196	8b 45 fc	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  00199	83 c0 01	 add	 eax, 1
  0019c	89 45 fc	 mov	 DWORD PTR _output_pointer$[ebp], eax

; 1659 : 		if (output_buffer->format)

  0019f	8b 4d 0c	 mov	 ecx, DWORD PTR _output_buffer$[ebp]
  001a2	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  001a6	74 0f		 je	 SHORT $LN10@print_obje

; 1660 : 		{
; 1661 : 			*output_pointer++ = '\t';

  001a8	8b 55 fc	 mov	 edx, DWORD PTR _output_pointer$[ebp]
  001ab	c6 02 09	 mov	 BYTE PTR [edx], 9
  001ae	8b 45 fc	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  001b1	83 c0 01	 add	 eax, 1
  001b4	89 45 fc	 mov	 DWORD PTR _output_pointer$[ebp], eax
$LN10@print_obje:

; 1662 : 		}
; 1663 : 		output_buffer->offset += length;

  001b7	8b 4d 0c	 mov	 ecx, DWORD PTR _output_buffer$[ebp]
  001ba	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  001bd	03 55 f8	 add	 edx, DWORD PTR _length$[ebp]
  001c0	8b 45 0c	 mov	 eax, DWORD PTR _output_buffer$[ebp]
  001c3	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1664 : 
; 1665 : 		/* print value */
; 1666 : 		if (!print_value(current_item, output_buffer))

  001c6	8b 4d 0c	 mov	 ecx, DWORD PTR _output_buffer$[ebp]
  001c9	51		 push	 ecx
  001ca	8b 55 f4	 mov	 edx, DWORD PTR _current_item$[ebp]
  001cd	52		 push	 edx
  001ce	e8 00 00 00 00	 call	 _print_value
  001d3	83 c4 08	 add	 esp, 8
  001d6	85 c0		 test	 eax, eax
  001d8	75 07		 jne	 SHORT $LN9@print_obje

; 1667 : 		{
; 1668 : 			return false;

  001da	33 c0		 xor	 eax, eax
  001dc	e9 58 01 00 00	 jmp	 $LN23@print_obje
$LN9@print_obje:

; 1669 : 		}
; 1670 : 		update_offset(output_buffer);

  001e1	8b 45 0c	 mov	 eax, DWORD PTR _output_buffer$[ebp]
  001e4	50		 push	 eax
  001e5	e8 00 00 00 00	 call	 _update_offset
  001ea	83 c4 04	 add	 esp, 4

; 1671 : 
; 1672 : 		/* print comma if not last */
; 1673 : 		length = (size_t)((output_buffer->format ? 1 : 0) + (current_item->next ? 1 : 0));

  001ed	8b 4d 0c	 mov	 ecx, DWORD PTR _output_buffer$[ebp]
  001f0	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  001f4	74 09		 je	 SHORT $LN29@print_obje
  001f6	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv160[ebp], 1
  001fd	eb 07		 jmp	 SHORT $LN30@print_obje
$LN29@print_obje:
  001ff	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv160[ebp], 0
$LN30@print_obje:
  00206	8b 55 f4	 mov	 edx, DWORD PTR _current_item$[ebp]
  00209	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0020c	74 09		 je	 SHORT $LN31@print_obje
  0020e	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv163[ebp], 1
  00215	eb 07		 jmp	 SHORT $LN32@print_obje
$LN31@print_obje:
  00217	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv163[ebp], 0
$LN32@print_obje:
  0021e	8b 45 e0	 mov	 eax, DWORD PTR tv160[ebp]
  00221	03 45 dc	 add	 eax, DWORD PTR tv163[ebp]
  00224	89 45 f8	 mov	 DWORD PTR _length$[ebp], eax

; 1674 : 		output_pointer = ensure(output_buffer, length + 1);

  00227	8b 4d f8	 mov	 ecx, DWORD PTR _length$[ebp]
  0022a	83 c1 01	 add	 ecx, 1
  0022d	51		 push	 ecx
  0022e	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  00231	52		 push	 edx
  00232	e8 00 00 00 00	 call	 _ensure
  00237	83 c4 08	 add	 esp, 8
  0023a	89 45 fc	 mov	 DWORD PTR _output_pointer$[ebp], eax

; 1675 : 		if (output_pointer == NULL)

  0023d	83 7d fc 00	 cmp	 DWORD PTR _output_pointer$[ebp], 0
  00241	75 07		 jne	 SHORT $LN8@print_obje

; 1676 : 		{
; 1677 : 			return false;

  00243	33 c0		 xor	 eax, eax
  00245	e9 ef 00 00 00	 jmp	 $LN23@print_obje
$LN8@print_obje:

; 1678 : 		}
; 1679 : 		if (current_item->next)

  0024a	8b 45 f4	 mov	 eax, DWORD PTR _current_item$[ebp]
  0024d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00250	74 0f		 je	 SHORT $LN7@print_obje

; 1680 : 		{
; 1681 : 			*output_pointer++ = ',';

  00252	8b 4d fc	 mov	 ecx, DWORD PTR _output_pointer$[ebp]
  00255	c6 01 2c	 mov	 BYTE PTR [ecx], 44	; 0000002cH
  00258	8b 55 fc	 mov	 edx, DWORD PTR _output_pointer$[ebp]
  0025b	83 c2 01	 add	 edx, 1
  0025e	89 55 fc	 mov	 DWORD PTR _output_pointer$[ebp], edx
$LN7@print_obje:

; 1682 : 		}
; 1683 : 
; 1684 : 		if (output_buffer->format)

  00261	8b 45 0c	 mov	 eax, DWORD PTR _output_buffer$[ebp]
  00264	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00268	74 0f		 je	 SHORT $LN6@print_obje

; 1685 : 		{
; 1686 : 			*output_pointer++ = '\n';

  0026a	8b 4d fc	 mov	 ecx, DWORD PTR _output_pointer$[ebp]
  0026d	c6 01 0a	 mov	 BYTE PTR [ecx], 10	; 0000000aH
  00270	8b 55 fc	 mov	 edx, DWORD PTR _output_pointer$[ebp]
  00273	83 c2 01	 add	 edx, 1
  00276	89 55 fc	 mov	 DWORD PTR _output_pointer$[ebp], edx
$LN6@print_obje:

; 1687 : 		}
; 1688 : 		*output_pointer = '\0';

  00279	8b 45 fc	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  0027c	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1689 : 		output_buffer->offset += length;

  0027f	8b 4d 0c	 mov	 ecx, DWORD PTR _output_buffer$[ebp]
  00282	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00285	03 55 f8	 add	 edx, DWORD PTR _length$[ebp]
  00288	8b 45 0c	 mov	 eax, DWORD PTR _output_buffer$[ebp]
  0028b	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1690 : 
; 1691 : 		current_item = current_item->next;

  0028e	8b 4d f4	 mov	 ecx, DWORD PTR _current_item$[ebp]
  00291	8b 11		 mov	 edx, DWORD PTR [ecx]
  00293	89 55 f4	 mov	 DWORD PTR _current_item$[ebp], edx

; 1692 : 	}

  00296	e9 16 fe ff ff	 jmp	 $LN19@print_obje
$LN18@print_obje:

; 1693 : 
; 1694 : 	output_pointer = ensure(output_buffer, output_buffer->format ? (output_buffer->depth + 1) : 2);

  0029b	8b 45 0c	 mov	 eax, DWORD PTR _output_buffer$[ebp]
  0029e	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  002a2	74 0e		 je	 SHORT $LN33@print_obje
  002a4	8b 4d 0c	 mov	 ecx, DWORD PTR _output_buffer$[ebp]
  002a7	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  002aa	83 c2 01	 add	 edx, 1
  002ad	89 55 d8	 mov	 DWORD PTR tv185[ebp], edx
  002b0	eb 07		 jmp	 SHORT $LN34@print_obje
$LN33@print_obje:
  002b2	c7 45 d8 02 00
	00 00		 mov	 DWORD PTR tv185[ebp], 2
$LN34@print_obje:
  002b9	8b 45 d8	 mov	 eax, DWORD PTR tv185[ebp]
  002bc	50		 push	 eax
  002bd	8b 4d 0c	 mov	 ecx, DWORD PTR _output_buffer$[ebp]
  002c0	51		 push	 ecx
  002c1	e8 00 00 00 00	 call	 _ensure
  002c6	83 c4 08	 add	 esp, 8
  002c9	89 45 fc	 mov	 DWORD PTR _output_pointer$[ebp], eax

; 1695 : 	if (output_pointer == NULL)

  002cc	83 7d fc 00	 cmp	 DWORD PTR _output_pointer$[ebp], 0
  002d0	75 04		 jne	 SHORT $LN5@print_obje

; 1696 : 	{
; 1697 : 		return false;

  002d2	33 c0		 xor	 eax, eax
  002d4	eb 63		 jmp	 SHORT $LN23@print_obje
$LN5@print_obje:

; 1698 : 	}
; 1699 : 	if (output_buffer->format)

  002d6	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  002d9	83 7a 14 00	 cmp	 DWORD PTR [edx+20], 0
  002dd	74 31		 je	 SHORT $LN4@print_obje

; 1700 : 	{
; 1701 : 		size_t i;
; 1702 : 		for (i = 0; i < (output_buffer->depth - 1); i++)

  002df	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  002e6	eb 09		 jmp	 SHORT $LN3@print_obje
$LN2@print_obje:
  002e8	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  002eb	83 c0 01	 add	 eax, 1
  002ee	89 45 ec	 mov	 DWORD PTR _i$1[ebp], eax
$LN3@print_obje:
  002f1	8b 4d 0c	 mov	 ecx, DWORD PTR _output_buffer$[ebp]
  002f4	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  002f7	83 ea 01	 sub	 edx, 1
  002fa	39 55 ec	 cmp	 DWORD PTR _i$1[ebp], edx
  002fd	73 11		 jae	 SHORT $LN4@print_obje

; 1703 : 		{
; 1704 : 			*output_pointer++ = '\t';

  002ff	8b 45 fc	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  00302	c6 00 09	 mov	 BYTE PTR [eax], 9
  00305	8b 4d fc	 mov	 ecx, DWORD PTR _output_pointer$[ebp]
  00308	83 c1 01	 add	 ecx, 1
  0030b	89 4d fc	 mov	 DWORD PTR _output_pointer$[ebp], ecx

; 1705 : 		}

  0030e	eb d8		 jmp	 SHORT $LN2@print_obje
$LN4@print_obje:

; 1706 : 	}
; 1707 : 	*output_pointer++ = '}';

  00310	8b 55 fc	 mov	 edx, DWORD PTR _output_pointer$[ebp]
  00313	c6 02 7d	 mov	 BYTE PTR [edx], 125	; 0000007dH
  00316	8b 45 fc	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  00319	83 c0 01	 add	 eax, 1
  0031c	89 45 fc	 mov	 DWORD PTR _output_pointer$[ebp], eax

; 1708 : 	*output_pointer = '\0';

  0031f	8b 4d fc	 mov	 ecx, DWORD PTR _output_pointer$[ebp]
  00322	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 1709 : 	output_buffer->depth--;

  00325	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  00328	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0032b	83 e8 01	 sub	 eax, 1
  0032e	8b 4d 0c	 mov	 ecx, DWORD PTR _output_buffer$[ebp]
  00331	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1710 : 
; 1711 : 	return true;

  00334	b8 01 00 00 00	 mov	 eax, 1
$LN23@print_obje:

; 1712 : }

  00339	8b e5		 mov	 esp, ebp
  0033b	5d		 pop	 ebp
  0033c	c3		 ret	 0
_print_object ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _parse_object
_TEXT	SEGMENT
_new_item$1 = -12					; size = 4
_head$ = -8						; size = 4
_current_item$ = -4					; size = 4
_item$ = 8						; size = 4
_input_buffer$ = 12					; size = 4
_parse_object PROC					; COMDAT

; 1494 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1495 : 	cJSON *head = NULL; /* linked list head */

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _head$[ebp], 0

; 1496 : 	cJSON *current_item = NULL;

  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _current_item$[ebp], 0

; 1497 : 
; 1498 : 	if (input_buffer->depth >= CJSON_NESTING_LIMIT)

  00014	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  00017	81 78 0c e8 03
	00 00		 cmp	 DWORD PTR [eax+12], 1000 ; 000003e8H
  0001e	72 07		 jb	 SHORT $LN20@parse_obje

; 1499 : 	{
; 1500 : 		return false; /* to deeply nested */

  00020	33 c0		 xor	 eax, eax
  00022	e9 8d 02 00 00	 jmp	 $LN21@parse_obje
$LN20@parse_obje:

; 1501 : 	}
; 1502 : 	input_buffer->depth++;

  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  0002a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0002d	83 c2 01	 add	 edx, 1
  00030	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  00033	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 1503 : 
; 1504 : 	if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '{'))

  00036	83 7d 0c 00	 cmp	 DWORD PTR _input_buffer$[ebp], 0
  0003a	74 2a		 je	 SHORT $LN18@parse_obje
  0003c	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  0003f	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  00042	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00045	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00048	73 1c		 jae	 SHORT $LN18@parse_obje
  0004a	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  0004d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004f	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  00052	03 50 08	 add	 edx, DWORD PTR [eax+8]
  00055	b9 01 00 00 00	 mov	 ecx, 1
  0005a	6b c1 00	 imul	 eax, ecx, 0
  0005d	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  00061	83 f9 7b	 cmp	 ecx, 123		; 0000007bH
  00064	74 05		 je	 SHORT $LN19@parse_obje
$LN18@parse_obje:

; 1505 : 	{
; 1506 : 		goto fail; /* not an object */

  00066	e9 38 02 00 00	 jmp	 $fail$23
$LN19@parse_obje:

; 1507 : 	}
; 1508 : 
; 1509 : 	input_buffer->offset++;

  0006b	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  0006e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00071	83 c0 01	 add	 eax, 1
  00074	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  00077	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1510 : 	buffer_skip_whitespace(input_buffer);

  0007a	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 _buffer_skip_whitespace
  00083	83 c4 04	 add	 esp, 4

; 1511 : 	if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '}'))

  00086	83 7d 0c 00	 cmp	 DWORD PTR _input_buffer$[ebp], 0
  0008a	74 2f		 je	 SHORT $LN17@parse_obje
  0008c	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  0008f	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  00092	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00095	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00098	73 21		 jae	 SHORT $LN17@parse_obje
  0009a	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  0009d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009f	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  000a2	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  000a5	b8 01 00 00 00	 mov	 eax, 1
  000aa	6b d0 00	 imul	 edx, eax, 0
  000ad	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  000b1	83 f8 7d	 cmp	 eax, 125		; 0000007dH
  000b4	75 05		 jne	 SHORT $LN17@parse_obje

; 1512 : 	{
; 1513 : 		goto success; /* empty object */

  000b6	e9 b0 01 00 00	 jmp	 $success$24
$LN17@parse_obje:

; 1514 : 	}
; 1515 : 
; 1516 : 	/* check if we skipped to the end of the buffer */
; 1517 : 	if (cannot_access_at_index(input_buffer, 0))

  000bb	83 7d 0c 00	 cmp	 DWORD PTR _input_buffer$[ebp], 0
  000bf	74 0e		 je	 SHORT $LN15@parse_obje
  000c1	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  000c4	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  000c7	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000ca	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  000cd	72 14		 jb	 SHORT $LN16@parse_obje
$LN15@parse_obje:

; 1518 : 	{
; 1519 : 		input_buffer->offset--;

  000cf	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  000d2	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000d5	83 ea 01	 sub	 edx, 1
  000d8	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  000db	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1520 : 		goto fail;

  000de	e9 c0 01 00 00	 jmp	 $fail$23
$LN16@parse_obje:

; 1521 : 	}
; 1522 : 
; 1523 : 	/* step back to character in front of the first element */
; 1524 : 	input_buffer->offset--;

  000e3	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  000e6	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000e9	83 ea 01	 sub	 edx, 1
  000ec	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  000ef	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN14@parse_obje:

; 1525 : 	/* loop through the comma separated array elements */
; 1526 : 	do
; 1527 : 	{
; 1528 : 		/* allocate next item */
; 1529 : 		cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));

  000f2	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  000f5	83 c1 10	 add	 ecx, 16			; 00000010H
  000f8	51		 push	 ecx
  000f9	e8 00 00 00 00	 call	 _cJSON_New_Item
  000fe	83 c4 04	 add	 esp, 4
  00101	89 45 f4	 mov	 DWORD PTR _new_item$1[ebp], eax

; 1530 : 		if (new_item == NULL)

  00104	83 7d f4 00	 cmp	 DWORD PTR _new_item$1[ebp], 0
  00108	75 05		 jne	 SHORT $LN11@parse_obje

; 1531 : 		{
; 1532 : 			goto fail; /* allocation failure */

  0010a	e9 94 01 00 00	 jmp	 $fail$23
$LN11@parse_obje:

; 1533 : 		}
; 1534 : 
; 1535 : 		/* attach next item to list */
; 1536 : 		if (head == NULL)

  0010f	83 7d f8 00	 cmp	 DWORD PTR _head$[ebp], 0
  00113	75 0e		 jne	 SHORT $LN10@parse_obje

; 1537 : 		{
; 1538 : 			/* start the linked list */
; 1539 : 			current_item = head = new_item;

  00115	8b 55 f4	 mov	 edx, DWORD PTR _new_item$1[ebp]
  00118	89 55 f8	 mov	 DWORD PTR _head$[ebp], edx
  0011b	8b 45 f8	 mov	 eax, DWORD PTR _head$[ebp]
  0011e	89 45 fc	 mov	 DWORD PTR _current_item$[ebp], eax

; 1540 : 		}
; 1541 : 		else

  00121	eb 17		 jmp	 SHORT $LN9@parse_obje
$LN10@parse_obje:

; 1542 : 		{
; 1543 : 			/* add to the end and advance */
; 1544 : 			current_item->next = new_item;

  00123	8b 4d fc	 mov	 ecx, DWORD PTR _current_item$[ebp]
  00126	8b 55 f4	 mov	 edx, DWORD PTR _new_item$1[ebp]
  00129	89 11		 mov	 DWORD PTR [ecx], edx

; 1545 : 			new_item->prev = current_item;

  0012b	8b 45 f4	 mov	 eax, DWORD PTR _new_item$1[ebp]
  0012e	8b 4d fc	 mov	 ecx, DWORD PTR _current_item$[ebp]
  00131	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1546 : 			current_item = new_item;

  00134	8b 55 f4	 mov	 edx, DWORD PTR _new_item$1[ebp]
  00137	89 55 fc	 mov	 DWORD PTR _current_item$[ebp], edx
$LN9@parse_obje:

; 1547 : 		}
; 1548 : 
; 1549 : 		/* parse the name of the child */
; 1550 : 		input_buffer->offset++;

  0013a	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  0013d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00140	83 c1 01	 add	 ecx, 1
  00143	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  00146	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1551 : 		buffer_skip_whitespace(input_buffer);

  00149	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  0014c	50		 push	 eax
  0014d	e8 00 00 00 00	 call	 _buffer_skip_whitespace
  00152	83 c4 04	 add	 esp, 4

; 1552 : 		if (!parse_string(current_item, input_buffer))

  00155	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  00158	51		 push	 ecx
  00159	8b 55 fc	 mov	 edx, DWORD PTR _current_item$[ebp]
  0015c	52		 push	 edx
  0015d	e8 00 00 00 00	 call	 _parse_string
  00162	83 c4 08	 add	 esp, 8
  00165	85 c0		 test	 eax, eax
  00167	75 05		 jne	 SHORT $LN8@parse_obje

; 1553 : 		{
; 1554 : 			goto fail; /* faile to parse name */

  00169	e9 35 01 00 00	 jmp	 $fail$23
$LN8@parse_obje:

; 1555 : 		}
; 1556 : 		buffer_skip_whitespace(input_buffer);

  0016e	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  00171	50		 push	 eax
  00172	e8 00 00 00 00	 call	 _buffer_skip_whitespace
  00177	83 c4 04	 add	 esp, 4

; 1557 : 
; 1558 : 		/* swap valuestring and string, because we parsed the name */
; 1559 : 		current_item->string = current_item->valuestring;

  0017a	8b 4d fc	 mov	 ecx, DWORD PTR _current_item$[ebp]
  0017d	8b 55 fc	 mov	 edx, DWORD PTR _current_item$[ebp]
  00180	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00183	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 1560 : 		current_item->valuestring = NULL;

  00186	8b 4d fc	 mov	 ecx, DWORD PTR _current_item$[ebp]
  00189	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1561 : 
; 1562 : 		if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != ':'))

  00190	83 7d 0c 00	 cmp	 DWORD PTR _input_buffer$[ebp], 0
  00194	74 2a		 je	 SHORT $LN6@parse_obje
  00196	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  00199	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  0019c	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0019f	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  001a2	73 1c		 jae	 SHORT $LN6@parse_obje
  001a4	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  001a7	8b 02		 mov	 eax, DWORD PTR [edx]
  001a9	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  001ac	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  001af	ba 01 00 00 00	 mov	 edx, 1
  001b4	6b ca 00	 imul	 ecx, edx, 0
  001b7	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  001bb	83 fa 3a	 cmp	 edx, 58			; 0000003aH
  001be	74 05		 je	 SHORT $LN7@parse_obje
$LN6@parse_obje:

; 1563 : 		{
; 1564 : 			goto fail; /* invalid object */

  001c0	e9 de 00 00 00	 jmp	 $fail$23
$LN7@parse_obje:

; 1565 : 		}
; 1566 : 
; 1567 : 		/* parse the value */
; 1568 : 		input_buffer->offset++;

  001c5	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  001c8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001cb	83 c1 01	 add	 ecx, 1
  001ce	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  001d1	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1569 : 		buffer_skip_whitespace(input_buffer);

  001d4	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  001d7	50		 push	 eax
  001d8	e8 00 00 00 00	 call	 _buffer_skip_whitespace
  001dd	83 c4 04	 add	 esp, 4

; 1570 : 		if (!parse_value(current_item, input_buffer))

  001e0	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  001e3	51		 push	 ecx
  001e4	8b 55 fc	 mov	 edx, DWORD PTR _current_item$[ebp]
  001e7	52		 push	 edx
  001e8	e8 00 00 00 00	 call	 _parse_value
  001ed	83 c4 08	 add	 esp, 8
  001f0	85 c0		 test	 eax, eax
  001f2	75 05		 jne	 SHORT $LN5@parse_obje

; 1571 : 		{
; 1572 : 			goto fail; /* failed to parse value */

  001f4	e9 aa 00 00 00	 jmp	 $fail$23
$LN5@parse_obje:

; 1573 : 		}
; 1574 : 		buffer_skip_whitespace(input_buffer);

  001f9	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  001fc	50		 push	 eax
  001fd	e8 00 00 00 00	 call	 _buffer_skip_whitespace
  00202	83 c4 04	 add	 esp, 4

; 1575 : 	} while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));

  00205	83 7d 0c 00	 cmp	 DWORD PTR _input_buffer$[ebp], 0
  00209	74 2e		 je	 SHORT $LN12@parse_obje
  0020b	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  0020e	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  00211	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00214	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00217	73 20		 jae	 SHORT $LN12@parse_obje
  00219	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  0021c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0021e	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  00221	03 50 08	 add	 edx, DWORD PTR [eax+8]
  00224	b9 01 00 00 00	 mov	 ecx, 1
  00229	6b c1 00	 imul	 eax, ecx, 0
  0022c	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  00230	83 f9 2c	 cmp	 ecx, 44			; 0000002cH
  00233	0f 84 b9 fe ff
	ff		 je	 $LN14@parse_obje
$LN12@parse_obje:

; 1576 : 
; 1577 : 	if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '}'))

  00239	83 7d 0c 00	 cmp	 DWORD PTR _input_buffer$[ebp], 0
  0023d	74 2a		 je	 SHORT $LN2@parse_obje
  0023f	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  00242	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  00245	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00248	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0024b	73 1c		 jae	 SHORT $LN2@parse_obje
  0024d	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  00250	8b 02		 mov	 eax, DWORD PTR [edx]
  00252	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  00255	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00258	ba 01 00 00 00	 mov	 edx, 1
  0025d	6b ca 00	 imul	 ecx, edx, 0
  00260	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  00264	83 fa 7d	 cmp	 edx, 125		; 0000007dH
  00267	74 02		 je	 SHORT $success$24
$LN2@parse_obje:

; 1578 : 	{
; 1579 : 		goto fail; /* expected end of object */

  00269	eb 38		 jmp	 SHORT $fail$23
$success$24:

; 1580 : 	}
; 1581 : 
; 1582 : success:
; 1583 : 	input_buffer->depth--;

  0026b	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  0026e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00271	83 e9 01	 sub	 ecx, 1
  00274	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  00277	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 1584 : 
; 1585 : 	item->type = cJSON_Object;

  0027a	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  0027d	c7 40 0c 40 00
	00 00		 mov	 DWORD PTR [eax+12], 64	; 00000040H

; 1586 : 	item->child = head;

  00284	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00287	8b 55 f8	 mov	 edx, DWORD PTR _head$[ebp]
  0028a	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 1587 : 
; 1588 : 	input_buffer->offset++;

  0028d	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  00290	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00293	83 c1 01	 add	 ecx, 1
  00296	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  00299	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1589 : 	return true;

  0029c	b8 01 00 00 00	 mov	 eax, 1
  002a1	eb 11		 jmp	 SHORT $LN21@parse_obje
$fail$23:

; 1590 : 
; 1591 : fail:
; 1592 : 	if (head != NULL)

  002a3	83 7d f8 00	 cmp	 DWORD PTR _head$[ebp], 0
  002a7	74 09		 je	 SHORT $LN1@parse_obje

; 1593 : 	{
; 1594 : 		cJSON_Delete(head);

  002a9	8b 45 f8	 mov	 eax, DWORD PTR _head$[ebp]
  002ac	50		 push	 eax
  002ad	e8 00 00 00 00	 call	 _cJSON_Delete@4
$LN1@parse_obje:

; 1595 : 	}
; 1596 : 
; 1597 : 	return false;

  002b2	33 c0		 xor	 eax, eax
$LN21@parse_obje:

; 1598 : }

  002b4	8b e5		 mov	 esp, ebp
  002b6	5d		 pop	 ebp
  002b7	c3		 ret	 0
_parse_object ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _print_array
_TEXT	SEGMENT
tv88 = -16						; size = 4
_length$ = -12						; size = 4
_current_element$ = -8					; size = 4
_output_pointer$ = -4					; size = 4
_item$ = 8						; size = 4
_output_buffer$ = 12					; size = 4
_print_array PROC					; COMDAT

; 1432 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1433 : 	unsigned char *output_pointer = NULL;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _output_pointer$[ebp], 0

; 1434 : 	size_t length = 0;

  0000d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _length$[ebp], 0

; 1435 : 	cJSON *current_element = item->child;

  00014	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00017	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001a	89 4d f8	 mov	 DWORD PTR _current_element$[ebp], ecx

; 1436 : 
; 1437 : 	if (output_buffer == NULL)

  0001d	83 7d 0c 00	 cmp	 DWORD PTR _output_buffer$[ebp], 0
  00021	75 07		 jne	 SHORT $LN9@print_arra

; 1438 : 	{
; 1439 : 		return false;

  00023	33 c0		 xor	 eax, eax
  00025	e9 4a 01 00 00	 jmp	 $LN10@print_arra
$LN9@print_arra:

; 1440 : 	}
; 1441 : 
; 1442 : 	/* Compose the output array. */
; 1443 : 	/* opening square bracket */
; 1444 : 	output_pointer = ensure(output_buffer, 1);

  0002a	6a 01		 push	 1
  0002c	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 _ensure
  00035	83 c4 08	 add	 esp, 8
  00038	89 45 fc	 mov	 DWORD PTR _output_pointer$[ebp], eax

; 1445 : 	if (output_pointer == NULL)

  0003b	83 7d fc 00	 cmp	 DWORD PTR _output_pointer$[ebp], 0
  0003f	75 07		 jne	 SHORT $LN8@print_arra

; 1446 : 	{
; 1447 : 		return false;

  00041	33 c0		 xor	 eax, eax
  00043	e9 2c 01 00 00	 jmp	 $LN10@print_arra
$LN8@print_arra:

; 1448 : 	}
; 1449 : 
; 1450 : 	*output_pointer = '[';

  00048	8b 45 fc	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  0004b	c6 00 5b	 mov	 BYTE PTR [eax], 91	; 0000005bH

; 1451 : 	output_buffer->offset++;

  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR _output_buffer$[ebp]
  00051	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00054	83 c2 01	 add	 edx, 1
  00057	8b 45 0c	 mov	 eax, DWORD PTR _output_buffer$[ebp]
  0005a	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1452 : 	output_buffer->depth++;

  0005d	8b 4d 0c	 mov	 ecx, DWORD PTR _output_buffer$[ebp]
  00060	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00063	83 c2 01	 add	 edx, 1
  00066	8b 45 0c	 mov	 eax, DWORD PTR _output_buffer$[ebp]
  00069	89 50 0c	 mov	 DWORD PTR [eax+12], edx
$LN7@print_arra:

; 1453 : 
; 1454 : 	while (current_element != NULL)

  0006c	83 7d f8 00	 cmp	 DWORD PTR _current_element$[ebp], 0
  00070	0f 84 ba 00 00
	00		 je	 $LN6@print_arra

; 1455 : 	{
; 1456 : 		if (!print_value(current_element, output_buffer))

  00076	8b 4d 0c	 mov	 ecx, DWORD PTR _output_buffer$[ebp]
  00079	51		 push	 ecx
  0007a	8b 55 f8	 mov	 edx, DWORD PTR _current_element$[ebp]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 _print_value
  00083	83 c4 08	 add	 esp, 8
  00086	85 c0		 test	 eax, eax
  00088	75 07		 jne	 SHORT $LN5@print_arra

; 1457 : 		{
; 1458 : 			return false;

  0008a	33 c0		 xor	 eax, eax
  0008c	e9 e3 00 00 00	 jmp	 $LN10@print_arra
$LN5@print_arra:

; 1459 : 		}
; 1460 : 		update_offset(output_buffer);

  00091	8b 45 0c	 mov	 eax, DWORD PTR _output_buffer$[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 _update_offset
  0009a	83 c4 04	 add	 esp, 4

; 1461 : 		if (current_element->next)

  0009d	8b 4d f8	 mov	 ecx, DWORD PTR _current_element$[ebp]
  000a0	83 39 00	 cmp	 DWORD PTR [ecx], 0
  000a3	74 7e		 je	 SHORT $LN4@print_arra

; 1462 : 		{
; 1463 : 			length = (size_t)(output_buffer->format ? 2 : 1);

  000a5	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  000a8	83 7a 14 00	 cmp	 DWORD PTR [edx+20], 0
  000ac	74 09		 je	 SHORT $LN12@print_arra
  000ae	c7 45 f0 02 00
	00 00		 mov	 DWORD PTR tv88[ebp], 2
  000b5	eb 07		 jmp	 SHORT $LN13@print_arra
$LN12@print_arra:
  000b7	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv88[ebp], 1
$LN13@print_arra:
  000be	8b 45 f0	 mov	 eax, DWORD PTR tv88[ebp]
  000c1	89 45 f4	 mov	 DWORD PTR _length$[ebp], eax

; 1464 : 			output_pointer = ensure(output_buffer, length + 1);

  000c4	8b 4d f4	 mov	 ecx, DWORD PTR _length$[ebp]
  000c7	83 c1 01	 add	 ecx, 1
  000ca	51		 push	 ecx
  000cb	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  000ce	52		 push	 edx
  000cf	e8 00 00 00 00	 call	 _ensure
  000d4	83 c4 08	 add	 esp, 8
  000d7	89 45 fc	 mov	 DWORD PTR _output_pointer$[ebp], eax

; 1465 : 			if (output_pointer == NULL)

  000da	83 7d fc 00	 cmp	 DWORD PTR _output_pointer$[ebp], 0
  000de	75 07		 jne	 SHORT $LN3@print_arra

; 1466 : 			{
; 1467 : 				return false;

  000e0	33 c0		 xor	 eax, eax
  000e2	e9 8d 00 00 00	 jmp	 $LN10@print_arra
$LN3@print_arra:

; 1468 : 			}
; 1469 : 			*output_pointer++ = ',';

  000e7	8b 45 fc	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  000ea	c6 00 2c	 mov	 BYTE PTR [eax], 44	; 0000002cH
  000ed	8b 4d fc	 mov	 ecx, DWORD PTR _output_pointer$[ebp]
  000f0	83 c1 01	 add	 ecx, 1
  000f3	89 4d fc	 mov	 DWORD PTR _output_pointer$[ebp], ecx

; 1470 : 			if (output_buffer->format)

  000f6	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  000f9	83 7a 14 00	 cmp	 DWORD PTR [edx+20], 0
  000fd	74 0f		 je	 SHORT $LN2@print_arra

; 1471 : 			{
; 1472 : 				*output_pointer++ = ' ';

  000ff	8b 45 fc	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  00102	c6 00 20	 mov	 BYTE PTR [eax], 32	; 00000020H
  00105	8b 4d fc	 mov	 ecx, DWORD PTR _output_pointer$[ebp]
  00108	83 c1 01	 add	 ecx, 1
  0010b	89 4d fc	 mov	 DWORD PTR _output_pointer$[ebp], ecx
$LN2@print_arra:

; 1473 : 			}
; 1474 : 			*output_pointer = '\0';

  0010e	8b 55 fc	 mov	 edx, DWORD PTR _output_pointer$[ebp]
  00111	c6 02 00	 mov	 BYTE PTR [edx], 0

; 1475 : 			output_buffer->offset += length;

  00114	8b 45 0c	 mov	 eax, DWORD PTR _output_buffer$[ebp]
  00117	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0011a	03 4d f4	 add	 ecx, DWORD PTR _length$[ebp]
  0011d	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  00120	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN4@print_arra:

; 1476 : 		}
; 1477 : 		current_element = current_element->next;

  00123	8b 45 f8	 mov	 eax, DWORD PTR _current_element$[ebp]
  00126	8b 08		 mov	 ecx, DWORD PTR [eax]
  00128	89 4d f8	 mov	 DWORD PTR _current_element$[ebp], ecx

; 1478 : 	}

  0012b	e9 3c ff ff ff	 jmp	 $LN7@print_arra
$LN6@print_arra:

; 1479 : 
; 1480 : 	output_pointer = ensure(output_buffer, 2);

  00130	6a 02		 push	 2
  00132	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  00135	52		 push	 edx
  00136	e8 00 00 00 00	 call	 _ensure
  0013b	83 c4 08	 add	 esp, 8
  0013e	89 45 fc	 mov	 DWORD PTR _output_pointer$[ebp], eax

; 1481 : 	if (output_pointer == NULL)

  00141	83 7d fc 00	 cmp	 DWORD PTR _output_pointer$[ebp], 0
  00145	75 04		 jne	 SHORT $LN1@print_arra

; 1482 : 	{
; 1483 : 		return false;

  00147	33 c0		 xor	 eax, eax
  00149	eb 29		 jmp	 SHORT $LN10@print_arra
$LN1@print_arra:

; 1484 : 	}
; 1485 : 	*output_pointer++ = ']';

  0014b	8b 45 fc	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  0014e	c6 00 5d	 mov	 BYTE PTR [eax], 93	; 0000005dH
  00151	8b 4d fc	 mov	 ecx, DWORD PTR _output_pointer$[ebp]
  00154	83 c1 01	 add	 ecx, 1
  00157	89 4d fc	 mov	 DWORD PTR _output_pointer$[ebp], ecx

; 1486 : 	*output_pointer = '\0';

  0015a	8b 55 fc	 mov	 edx, DWORD PTR _output_pointer$[ebp]
  0015d	c6 02 00	 mov	 BYTE PTR [edx], 0

; 1487 : 	output_buffer->depth--;

  00160	8b 45 0c	 mov	 eax, DWORD PTR _output_buffer$[ebp]
  00163	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00166	83 e9 01	 sub	 ecx, 1
  00169	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  0016c	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 1488 : 
; 1489 : 	return true;

  0016f	b8 01 00 00 00	 mov	 eax, 1
$LN10@print_arra:

; 1490 : }

  00174	8b e5		 mov	 esp, ebp
  00176	5d		 pop	 ebp
  00177	c3		 ret	 0
_print_array ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _parse_array
_TEXT	SEGMENT
_current_item$ = -12					; size = 4
_new_item$1 = -8					; size = 4
_head$ = -4						; size = 4
_item$ = 8						; size = 4
_input_buffer$ = 12					; size = 4
_parse_array PROC					; COMDAT

; 1339 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1340 : 	cJSON *head = NULL; /* head of the linked list */

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _head$[ebp], 0

; 1341 : 	cJSON *current_item = NULL;

  0000d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _current_item$[ebp], 0

; 1342 : 
; 1343 : 	if (input_buffer->depth >= CJSON_NESTING_LIMIT)

  00014	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  00017	81 78 0c e8 03
	00 00		 cmp	 DWORD PTR [eax+12], 1000 ; 000003e8H
  0001e	72 07		 jb	 SHORT $LN16@parse_arra

; 1344 : 	{
; 1345 : 		return false; /* to deeply nested */

  00020	33 c0		 xor	 eax, eax
  00022	e9 ee 01 00 00	 jmp	 $LN17@parse_arra
$LN16@parse_arra:

; 1346 : 	}
; 1347 : 	input_buffer->depth++;

  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  0002a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0002d	83 c2 01	 add	 edx, 1
  00030	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  00033	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 1348 : 
; 1349 : 	if (buffer_at_offset(input_buffer)[0] != '[')

  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  00039	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003b	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  0003e	03 50 08	 add	 edx, DWORD PTR [eax+8]
  00041	b9 01 00 00 00	 mov	 ecx, 1
  00046	6b c1 00	 imul	 eax, ecx, 0
  00049	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  0004d	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  00050	74 05		 je	 SHORT $LN15@parse_arra

; 1350 : 	{
; 1351 : 		/* not an array */
; 1352 : 		goto fail;

  00052	e9 ad 01 00 00	 jmp	 $fail$19
$LN15@parse_arra:

; 1353 : 	}
; 1354 : 
; 1355 : 	input_buffer->offset++;

  00057	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  0005a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0005d	83 c0 01	 add	 eax, 1
  00060	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  00063	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1356 : 	buffer_skip_whitespace(input_buffer);

  00066	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  00069	52		 push	 edx
  0006a	e8 00 00 00 00	 call	 _buffer_skip_whitespace
  0006f	83 c4 04	 add	 esp, 4

; 1357 : 	if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ']'))

  00072	83 7d 0c 00	 cmp	 DWORD PTR _input_buffer$[ebp], 0
  00076	74 2f		 je	 SHORT $LN14@parse_arra
  00078	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  0007b	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  0007e	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00081	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00084	73 21		 jae	 SHORT $LN14@parse_arra
  00086	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  00089	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008b	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  0008e	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  00091	b8 01 00 00 00	 mov	 eax, 1
  00096	6b d0 00	 imul	 edx, eax, 0
  00099	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  0009d	83 f8 5d	 cmp	 eax, 93			; 0000005dH
  000a0	75 05		 jne	 SHORT $LN14@parse_arra

; 1358 : 	{
; 1359 : 		/* empty array */
; 1360 : 		goto success;

  000a2	e9 25 01 00 00	 jmp	 $success$20
$LN14@parse_arra:

; 1361 : 	}
; 1362 : 
; 1363 : 	/* check if we skipped to the end of the buffer */
; 1364 : 	if (cannot_access_at_index(input_buffer, 0))

  000a7	83 7d 0c 00	 cmp	 DWORD PTR _input_buffer$[ebp], 0
  000ab	74 0e		 je	 SHORT $LN12@parse_arra
  000ad	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  000b0	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  000b3	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000b6	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  000b9	72 14		 jb	 SHORT $LN13@parse_arra
$LN12@parse_arra:

; 1365 : 	{
; 1366 : 		input_buffer->offset--;

  000bb	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  000be	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000c1	83 ea 01	 sub	 edx, 1
  000c4	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  000c7	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1367 : 		goto fail;

  000ca	e9 35 01 00 00	 jmp	 $fail$19
$LN13@parse_arra:

; 1368 : 	}
; 1369 : 
; 1370 : 	/* step back to character in front of the first element */
; 1371 : 	input_buffer->offset--;

  000cf	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  000d2	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000d5	83 ea 01	 sub	 edx, 1
  000d8	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  000db	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN11@parse_arra:

; 1372 : 	/* loop through the comma separated array elements */
; 1373 : 	do
; 1374 : 	{
; 1375 : 		/* allocate next item */
; 1376 : 		cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));

  000de	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  000e1	83 c1 10	 add	 ecx, 16			; 00000010H
  000e4	51		 push	 ecx
  000e5	e8 00 00 00 00	 call	 _cJSON_New_Item
  000ea	83 c4 04	 add	 esp, 4
  000ed	89 45 f8	 mov	 DWORD PTR _new_item$1[ebp], eax

; 1377 : 		if (new_item == NULL)

  000f0	83 7d f8 00	 cmp	 DWORD PTR _new_item$1[ebp], 0
  000f4	75 05		 jne	 SHORT $LN8@parse_arra

; 1378 : 		{
; 1379 : 			goto fail; /* allocation failure */

  000f6	e9 09 01 00 00	 jmp	 $fail$19
$LN8@parse_arra:

; 1380 : 		}
; 1381 : 
; 1382 : 		/* attach next item to list */
; 1383 : 		if (head == NULL)

  000fb	83 7d fc 00	 cmp	 DWORD PTR _head$[ebp], 0
  000ff	75 0e		 jne	 SHORT $LN7@parse_arra

; 1384 : 		{
; 1385 : 			/* start the linked list */
; 1386 : 			current_item = head = new_item;

  00101	8b 55 f8	 mov	 edx, DWORD PTR _new_item$1[ebp]
  00104	89 55 fc	 mov	 DWORD PTR _head$[ebp], edx
  00107	8b 45 fc	 mov	 eax, DWORD PTR _head$[ebp]
  0010a	89 45 f4	 mov	 DWORD PTR _current_item$[ebp], eax

; 1387 : 		}
; 1388 : 		else

  0010d	eb 17		 jmp	 SHORT $LN6@parse_arra
$LN7@parse_arra:

; 1389 : 		{
; 1390 : 			/* add to the end and advance */
; 1391 : 			current_item->next = new_item;

  0010f	8b 4d f4	 mov	 ecx, DWORD PTR _current_item$[ebp]
  00112	8b 55 f8	 mov	 edx, DWORD PTR _new_item$1[ebp]
  00115	89 11		 mov	 DWORD PTR [ecx], edx

; 1392 : 			new_item->prev = current_item;

  00117	8b 45 f8	 mov	 eax, DWORD PTR _new_item$1[ebp]
  0011a	8b 4d f4	 mov	 ecx, DWORD PTR _current_item$[ebp]
  0011d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1393 : 			current_item = new_item;

  00120	8b 55 f8	 mov	 edx, DWORD PTR _new_item$1[ebp]
  00123	89 55 f4	 mov	 DWORD PTR _current_item$[ebp], edx
$LN6@parse_arra:

; 1394 : 		}
; 1395 : 
; 1396 : 		/* parse next value */
; 1397 : 		input_buffer->offset++;

  00126	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  00129	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0012c	83 c1 01	 add	 ecx, 1
  0012f	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  00132	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1398 : 		buffer_skip_whitespace(input_buffer);

  00135	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  00138	50		 push	 eax
  00139	e8 00 00 00 00	 call	 _buffer_skip_whitespace
  0013e	83 c4 04	 add	 esp, 4

; 1399 : 		if (!parse_value(current_item, input_buffer))

  00141	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  00144	51		 push	 ecx
  00145	8b 55 f4	 mov	 edx, DWORD PTR _current_item$[ebp]
  00148	52		 push	 edx
  00149	e8 00 00 00 00	 call	 _parse_value
  0014e	83 c4 08	 add	 esp, 8
  00151	85 c0		 test	 eax, eax
  00153	75 05		 jne	 SHORT $LN5@parse_arra

; 1400 : 		{
; 1401 : 			goto fail; /* failed to parse value */

  00155	e9 aa 00 00 00	 jmp	 $fail$19
$LN5@parse_arra:

; 1402 : 		}
; 1403 : 		buffer_skip_whitespace(input_buffer);

  0015a	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  0015d	50		 push	 eax
  0015e	e8 00 00 00 00	 call	 _buffer_skip_whitespace
  00163	83 c4 04	 add	 esp, 4

; 1404 : 	} while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));

  00166	83 7d 0c 00	 cmp	 DWORD PTR _input_buffer$[ebp], 0
  0016a	74 2e		 je	 SHORT $LN9@parse_arra
  0016c	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  0016f	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  00172	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00175	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00178	73 20		 jae	 SHORT $LN9@parse_arra
  0017a	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  0017d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0017f	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  00182	03 50 08	 add	 edx, DWORD PTR [eax+8]
  00185	b9 01 00 00 00	 mov	 ecx, 1
  0018a	6b c1 00	 imul	 eax, ecx, 0
  0018d	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  00191	83 f9 2c	 cmp	 ecx, 44			; 0000002cH
  00194	0f 84 44 ff ff
	ff		 je	 $LN11@parse_arra
$LN9@parse_arra:

; 1405 : 
; 1406 : 	if (cannot_access_at_index(input_buffer, 0) || buffer_at_offset(input_buffer)[0] != ']')

  0019a	83 7d 0c 00	 cmp	 DWORD PTR _input_buffer$[ebp], 0
  0019e	74 2a		 je	 SHORT $LN2@parse_arra
  001a0	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  001a3	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  001a6	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  001a9	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  001ac	73 1c		 jae	 SHORT $LN2@parse_arra
  001ae	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  001b1	8b 02		 mov	 eax, DWORD PTR [edx]
  001b3	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  001b6	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  001b9	ba 01 00 00 00	 mov	 edx, 1
  001be	6b ca 00	 imul	 ecx, edx, 0
  001c1	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  001c5	83 fa 5d	 cmp	 edx, 93			; 0000005dH
  001c8	74 02		 je	 SHORT $success$20
$LN2@parse_arra:

; 1407 : 	{
; 1408 : 		goto fail; /* expected end of array */

  001ca	eb 38		 jmp	 SHORT $fail$19
$success$20:

; 1409 : 	}
; 1410 : 
; 1411 : success:
; 1412 : 	input_buffer->depth--;

  001cc	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  001cf	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  001d2	83 e9 01	 sub	 ecx, 1
  001d5	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  001d8	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 1413 : 
; 1414 : 	item->type = cJSON_Array;

  001db	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  001de	c7 40 0c 20 00
	00 00		 mov	 DWORD PTR [eax+12], 32	; 00000020H

; 1415 : 	item->child = head;

  001e5	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  001e8	8b 55 fc	 mov	 edx, DWORD PTR _head$[ebp]
  001eb	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 1416 : 
; 1417 : 	input_buffer->offset++;

  001ee	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  001f1	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001f4	83 c1 01	 add	 ecx, 1
  001f7	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  001fa	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1418 : 
; 1419 : 	return true;

  001fd	b8 01 00 00 00	 mov	 eax, 1
  00202	eb 11		 jmp	 SHORT $LN17@parse_arra
$fail$19:

; 1420 : 
; 1421 : fail:
; 1422 : 	if (head != NULL)

  00204	83 7d fc 00	 cmp	 DWORD PTR _head$[ebp], 0
  00208	74 09		 je	 SHORT $LN1@parse_arra

; 1423 : 	{
; 1424 : 		cJSON_Delete(head);

  0020a	8b 45 fc	 mov	 eax, DWORD PTR _head$[ebp]
  0020d	50		 push	 eax
  0020e	e8 00 00 00 00	 call	 _cJSON_Delete@4
$LN1@parse_arra:

; 1425 : 	}
; 1426 : 
; 1427 : 	return false;

  00213	33 c0		 xor	 eax, eax
$LN17@parse_arra:

; 1428 : }

  00215	8b e5		 mov	 esp, ebp
  00217	5d		 pop	 ebp
  00218	c3		 ret	 0
_parse_array ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _print_value
_TEXT	SEGMENT
_raw_length$1 = -12					; size = 4
tv68 = -8						; size = 4
_output$ = -4						; size = 4
_item$ = 8						; size = 4
_output_buffer$ = 12					; size = 4
_print_value PROC					; COMDAT

; 1265 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1266 : 	unsigned char *output = NULL;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _output$[ebp], 0

; 1267 : 
; 1268 : 	if ((item == NULL) || (output_buffer == NULL))

  0000d	83 7d 08 00	 cmp	 DWORD PTR _item$[ebp], 0
  00011	74 06		 je	 SHORT $LN17@print_valu
  00013	83 7d 0c 00	 cmp	 DWORD PTR _output_buffer$[ebp], 0
  00017	75 07		 jne	 SHORT $LN18@print_valu
$LN17@print_valu:

; 1269 : 	{
; 1270 : 		return false;

  00019	33 c0		 xor	 eax, eax
  0001b	e9 92 01 00 00	 jmp	 $LN19@print_valu
$LN18@print_valu:

; 1271 : 	}
; 1272 : 
; 1273 : 	switch ((item->type) & 0xFF)

  00020	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00023	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00026	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0002c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0002f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00032	83 ea 01	 sub	 edx, 1
  00035	89 55 f8	 mov	 DWORD PTR tv68[ebp], edx
  00038	83 7d f8 7f	 cmp	 DWORD PTR tv68[ebp], 127 ; 0000007fH
  0003c	0f 87 6e 01 00
	00		 ja	 $LN1@print_valu
  00042	8b 45 f8	 mov	 eax, DWORD PTR tv68[ebp]
  00045	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN21@print_valu[eax]
  0004c	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN22@print_valu[ecx*4]
$LN14@print_valu:

; 1274 : 	{
; 1275 : 	case cJSON_NULL:
; 1276 : 		output = ensure(output_buffer, 5);

  00053	6a 05		 push	 5
  00055	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  00058	52		 push	 edx
  00059	e8 00 00 00 00	 call	 _ensure
  0005e	83 c4 08	 add	 esp, 8
  00061	89 45 fc	 mov	 DWORD PTR _output$[ebp], eax

; 1277 : 		if (output == NULL)

  00064	83 7d fc 00	 cmp	 DWORD PTR _output$[ebp], 0
  00068	75 07		 jne	 SHORT $LN13@print_valu

; 1278 : 		{
; 1279 : 			return false;

  0006a	33 c0		 xor	 eax, eax
  0006c	e9 41 01 00 00	 jmp	 $LN19@print_valu
$LN13@print_valu:

; 1280 : 		}
; 1281 : 		strcpy((char*)output, "null");

  00071	68 00 00 00 00	 push	 OFFSET $SG2908
  00076	8b 45 fc	 mov	 eax, DWORD PTR _output$[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 _strcpy
  0007f	83 c4 08	 add	 esp, 8

; 1282 : 		return true;

  00082	b8 01 00 00 00	 mov	 eax, 1
  00087	e9 26 01 00 00	 jmp	 $LN19@print_valu
$LN12@print_valu:

; 1283 : 
; 1284 : 	case cJSON_False:
; 1285 : 		output = ensure(output_buffer, 6);

  0008c	6a 06		 push	 6
  0008e	8b 4d 0c	 mov	 ecx, DWORD PTR _output_buffer$[ebp]
  00091	51		 push	 ecx
  00092	e8 00 00 00 00	 call	 _ensure
  00097	83 c4 08	 add	 esp, 8
  0009a	89 45 fc	 mov	 DWORD PTR _output$[ebp], eax

; 1286 : 		if (output == NULL)

  0009d	83 7d fc 00	 cmp	 DWORD PTR _output$[ebp], 0
  000a1	75 07		 jne	 SHORT $LN11@print_valu

; 1287 : 		{
; 1288 : 			return false;

  000a3	33 c0		 xor	 eax, eax
  000a5	e9 08 01 00 00	 jmp	 $LN19@print_valu
$LN11@print_valu:

; 1289 : 		}
; 1290 : 		strcpy((char*)output, "false");

  000aa	68 00 00 00 00	 push	 OFFSET $SG2914
  000af	8b 55 fc	 mov	 edx, DWORD PTR _output$[ebp]
  000b2	52		 push	 edx
  000b3	e8 00 00 00 00	 call	 _strcpy
  000b8	83 c4 08	 add	 esp, 8

; 1291 : 		return true;

  000bb	b8 01 00 00 00	 mov	 eax, 1
  000c0	e9 ed 00 00 00	 jmp	 $LN19@print_valu
$LN10@print_valu:

; 1292 : 
; 1293 : 	case cJSON_True:
; 1294 : 		output = ensure(output_buffer, 5);

  000c5	6a 05		 push	 5
  000c7	8b 45 0c	 mov	 eax, DWORD PTR _output_buffer$[ebp]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 _ensure
  000d0	83 c4 08	 add	 esp, 8
  000d3	89 45 fc	 mov	 DWORD PTR _output$[ebp], eax

; 1295 : 		if (output == NULL)

  000d6	83 7d fc 00	 cmp	 DWORD PTR _output$[ebp], 0
  000da	75 07		 jne	 SHORT $LN9@print_valu

; 1296 : 		{
; 1297 : 			return false;

  000dc	33 c0		 xor	 eax, eax
  000de	e9 cf 00 00 00	 jmp	 $LN19@print_valu
$LN9@print_valu:

; 1298 : 		}
; 1299 : 		strcpy((char*)output, "true");

  000e3	68 00 00 00 00	 push	 OFFSET $SG2920
  000e8	8b 4d fc	 mov	 ecx, DWORD PTR _output$[ebp]
  000eb	51		 push	 ecx
  000ec	e8 00 00 00 00	 call	 _strcpy
  000f1	83 c4 08	 add	 esp, 8

; 1300 : 		return true;

  000f4	b8 01 00 00 00	 mov	 eax, 1
  000f9	e9 b4 00 00 00	 jmp	 $LN19@print_valu
$LN8@print_valu:

; 1301 : 
; 1302 : 	case cJSON_Number:
; 1303 : 		return print_number(item, output_buffer);

  000fe	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  00101	52		 push	 edx
  00102	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 _print_number
  0010b	83 c4 08	 add	 esp, 8
  0010e	e9 9f 00 00 00	 jmp	 $LN19@print_valu
$LN7@print_valu:

; 1304 : 
; 1305 : 	case cJSON_Raw:
; 1306 : 	{
; 1307 : 		size_t raw_length = 0;

  00113	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _raw_length$1[ebp], 0

; 1308 : 		if (item->valuestring == NULL)

  0011a	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  0011d	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00121	75 07		 jne	 SHORT $LN6@print_valu

; 1309 : 		{
; 1310 : 			return false;

  00123	33 c0		 xor	 eax, eax
  00125	e9 88 00 00 00	 jmp	 $LN19@print_valu
$LN6@print_valu:

; 1311 : 		}
; 1312 : 
; 1313 : 		raw_length = strlen(item->valuestring) + sizeof("");

  0012a	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  0012d	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00130	50		 push	 eax
  00131	e8 00 00 00 00	 call	 _strlen
  00136	83 c4 04	 add	 esp, 4
  00139	83 c0 01	 add	 eax, 1
  0013c	89 45 f4	 mov	 DWORD PTR _raw_length$1[ebp], eax

; 1314 : 		output = ensure(output_buffer, raw_length);

  0013f	8b 4d f4	 mov	 ecx, DWORD PTR _raw_length$1[ebp]
  00142	51		 push	 ecx
  00143	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  00146	52		 push	 edx
  00147	e8 00 00 00 00	 call	 _ensure
  0014c	83 c4 08	 add	 esp, 8
  0014f	89 45 fc	 mov	 DWORD PTR _output$[ebp], eax

; 1315 : 		if (output == NULL)

  00152	83 7d fc 00	 cmp	 DWORD PTR _output$[ebp], 0
  00156	75 04		 jne	 SHORT $LN5@print_valu

; 1316 : 		{
; 1317 : 			return false;

  00158	33 c0		 xor	 eax, eax
  0015a	eb 56		 jmp	 SHORT $LN19@print_valu
$LN5@print_valu:

; 1318 : 		}
; 1319 : 		memcpy(output, item->valuestring, raw_length);

  0015c	8b 45 f4	 mov	 eax, DWORD PTR _raw_length$1[ebp]
  0015f	50		 push	 eax
  00160	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00163	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00166	52		 push	 edx
  00167	8b 45 fc	 mov	 eax, DWORD PTR _output$[ebp]
  0016a	50		 push	 eax
  0016b	e8 00 00 00 00	 call	 _memcpy
  00170	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1320 : 		return true;

  00173	b8 01 00 00 00	 mov	 eax, 1
  00178	eb 38		 jmp	 SHORT $LN19@print_valu
$LN4@print_valu:

; 1321 : 	}
; 1322 : 
; 1323 : 	case cJSON_String:
; 1324 : 		return print_string(item, output_buffer);

  0017a	8b 4d 0c	 mov	 ecx, DWORD PTR _output_buffer$[ebp]
  0017d	51		 push	 ecx
  0017e	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00181	52		 push	 edx
  00182	e8 00 00 00 00	 call	 _print_string
  00187	83 c4 08	 add	 esp, 8
  0018a	eb 26		 jmp	 SHORT $LN19@print_valu
$LN3@print_valu:

; 1325 : 
; 1326 : 	case cJSON_Array:
; 1327 : 		return print_array(item, output_buffer);

  0018c	8b 45 0c	 mov	 eax, DWORD PTR _output_buffer$[ebp]
  0018f	50		 push	 eax
  00190	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00193	51		 push	 ecx
  00194	e8 00 00 00 00	 call	 _print_array
  00199	83 c4 08	 add	 esp, 8
  0019c	eb 14		 jmp	 SHORT $LN19@print_valu
$LN2@print_valu:

; 1328 : 
; 1329 : 	case cJSON_Object:
; 1330 : 		return print_object(item, output_buffer);

  0019e	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  001a1	52		 push	 edx
  001a2	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  001a5	50		 push	 eax
  001a6	e8 00 00 00 00	 call	 _print_object
  001ab	83 c4 08	 add	 esp, 8
  001ae	eb 02		 jmp	 SHORT $LN19@print_valu
$LN1@print_valu:

; 1331 : 
; 1332 : 	default:
; 1333 : 		return false;

  001b0	33 c0		 xor	 eax, eax
$LN19@print_valu:

; 1334 : 	}
; 1335 : }

  001b2	8b e5		 mov	 esp, ebp
  001b4	5d		 pop	 ebp
  001b5	c3		 ret	 0
  001b6	8b ff		 npad	 2
$LN22@print_valu:
  001b8	00 00 00 00	 DD	 $LN12@print_valu
  001bc	00 00 00 00	 DD	 $LN10@print_valu
  001c0	00 00 00 00	 DD	 $LN14@print_valu
  001c4	00 00 00 00	 DD	 $LN8@print_valu
  001c8	00 00 00 00	 DD	 $LN4@print_valu
  001cc	00 00 00 00	 DD	 $LN3@print_valu
  001d0	00 00 00 00	 DD	 $LN2@print_valu
  001d4	00 00 00 00	 DD	 $LN7@print_valu
  001d8	00 00 00 00	 DD	 $LN1@print_valu
$LN21@print_valu:
  001dc	00		 DB	 0
  001dd	01		 DB	 1
  001de	08		 DB	 8
  001df	02		 DB	 2
  001e0	08		 DB	 8
  001e1	08		 DB	 8
  001e2	08		 DB	 8
  001e3	03		 DB	 3
  001e4	08		 DB	 8
  001e5	08		 DB	 8
  001e6	08		 DB	 8
  001e7	08		 DB	 8
  001e8	08		 DB	 8
  001e9	08		 DB	 8
  001ea	08		 DB	 8
  001eb	04		 DB	 4
  001ec	08		 DB	 8
  001ed	08		 DB	 8
  001ee	08		 DB	 8
  001ef	08		 DB	 8
  001f0	08		 DB	 8
  001f1	08		 DB	 8
  001f2	08		 DB	 8
  001f3	08		 DB	 8
  001f4	08		 DB	 8
  001f5	08		 DB	 8
  001f6	08		 DB	 8
  001f7	08		 DB	 8
  001f8	08		 DB	 8
  001f9	08		 DB	 8
  001fa	08		 DB	 8
  001fb	05		 DB	 5
  001fc	08		 DB	 8
  001fd	08		 DB	 8
  001fe	08		 DB	 8
  001ff	08		 DB	 8
  00200	08		 DB	 8
  00201	08		 DB	 8
  00202	08		 DB	 8
  00203	08		 DB	 8
  00204	08		 DB	 8
  00205	08		 DB	 8
  00206	08		 DB	 8
  00207	08		 DB	 8
  00208	08		 DB	 8
  00209	08		 DB	 8
  0020a	08		 DB	 8
  0020b	08		 DB	 8
  0020c	08		 DB	 8
  0020d	08		 DB	 8
  0020e	08		 DB	 8
  0020f	08		 DB	 8
  00210	08		 DB	 8
  00211	08		 DB	 8
  00212	08		 DB	 8
  00213	08		 DB	 8
  00214	08		 DB	 8
  00215	08		 DB	 8
  00216	08		 DB	 8
  00217	08		 DB	 8
  00218	08		 DB	 8
  00219	08		 DB	 8
  0021a	08		 DB	 8
  0021b	06		 DB	 6
  0021c	08		 DB	 8
  0021d	08		 DB	 8
  0021e	08		 DB	 8
  0021f	08		 DB	 8
  00220	08		 DB	 8
  00221	08		 DB	 8
  00222	08		 DB	 8
  00223	08		 DB	 8
  00224	08		 DB	 8
  00225	08		 DB	 8
  00226	08		 DB	 8
  00227	08		 DB	 8
  00228	08		 DB	 8
  00229	08		 DB	 8
  0022a	08		 DB	 8
  0022b	08		 DB	 8
  0022c	08		 DB	 8
  0022d	08		 DB	 8
  0022e	08		 DB	 8
  0022f	08		 DB	 8
  00230	08		 DB	 8
  00231	08		 DB	 8
  00232	08		 DB	 8
  00233	08		 DB	 8
  00234	08		 DB	 8
  00235	08		 DB	 8
  00236	08		 DB	 8
  00237	08		 DB	 8
  00238	08		 DB	 8
  00239	08		 DB	 8
  0023a	08		 DB	 8
  0023b	08		 DB	 8
  0023c	08		 DB	 8
  0023d	08		 DB	 8
  0023e	08		 DB	 8
  0023f	08		 DB	 8
  00240	08		 DB	 8
  00241	08		 DB	 8
  00242	08		 DB	 8
  00243	08		 DB	 8
  00244	08		 DB	 8
  00245	08		 DB	 8
  00246	08		 DB	 8
  00247	08		 DB	 8
  00248	08		 DB	 8
  00249	08		 DB	 8
  0024a	08		 DB	 8
  0024b	08		 DB	 8
  0024c	08		 DB	 8
  0024d	08		 DB	 8
  0024e	08		 DB	 8
  0024f	08		 DB	 8
  00250	08		 DB	 8
  00251	08		 DB	 8
  00252	08		 DB	 8
  00253	08		 DB	 8
  00254	08		 DB	 8
  00255	08		 DB	 8
  00256	08		 DB	 8
  00257	08		 DB	 8
  00258	08		 DB	 8
  00259	08		 DB	 8
  0025a	08		 DB	 8
  0025b	07		 DB	 7
_print_value ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _parse_value
_TEXT	SEGMENT
_item$ = 8						; size = 4
_input_buffer$ = 12					; size = 4
_parse_value PROC					; COMDAT

; 1210 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1211 : 	if ((input_buffer == NULL) || (input_buffer->content == NULL))

  00003	83 7d 0c 00	 cmp	 DWORD PTR _input_buffer$[ebp], 0
  00007	74 08		 je	 SHORT $LN9@parse_valu
  00009	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	75 07		 jne	 SHORT $LN10@parse_valu
$LN9@parse_valu:

; 1212 : 	{
; 1213 : 		return false; /* no input */

  00011	33 c0		 xor	 eax, eax
  00013	e9 5d 02 00 00	 jmp	 $LN11@parse_valu
$LN10@parse_valu:

; 1214 : 	}
; 1215 : 
; 1216 : 	/* parse the different types of values */
; 1217 : 	/* null */
; 1218 : 	if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "null", 4) == 0))

  00018	83 7d 0c 00	 cmp	 DWORD PTR _input_buffer$[ebp], 0
  0001c	74 53		 je	 SHORT $LN8@parse_valu
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  00021	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00024	83 c2 04	 add	 edx, 4
  00027	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  0002a	3b 50 04	 cmp	 edx, DWORD PTR [eax+4]
  0002d	77 42		 ja	 SHORT $LN8@parse_valu
  0002f	6a 04		 push	 4
  00031	68 00 00 00 00	 push	 OFFSET $SG2875
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  00039	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003b	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  0003e	03 50 08	 add	 edx, DWORD PTR [eax+8]
  00041	52		 push	 edx
  00042	e8 00 00 00 00	 call	 _strncmp
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004a	85 c0		 test	 eax, eax
  0004c	75 23		 jne	 SHORT $LN8@parse_valu

; 1219 : 	{
; 1220 : 		item->type = cJSON_NULL;

  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00051	c7 41 0c 04 00
	00 00		 mov	 DWORD PTR [ecx+12], 4

; 1221 : 		input_buffer->offset += 4;

  00058	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  0005b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0005e	83 c0 04	 add	 eax, 4
  00061	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  00064	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1222 : 		return true;

  00067	b8 01 00 00 00	 mov	 eax, 1
  0006c	e9 04 02 00 00	 jmp	 $LN11@parse_valu
$LN8@parse_valu:

; 1223 : 	}
; 1224 : 	/* false */
; 1225 : 	if (can_read(input_buffer, 5) && (strncmp((const char*)buffer_at_offset(input_buffer), "false", 5) == 0))

  00071	83 7d 0c 00	 cmp	 DWORD PTR _input_buffer$[ebp], 0
  00075	74 53		 je	 SHORT $LN7@parse_valu
  00077	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  0007a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0007d	83 c0 05	 add	 eax, 5
  00080	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  00083	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00086	77 42		 ja	 SHORT $LN7@parse_valu
  00088	6a 05		 push	 5
  0008a	68 00 00 00 00	 push	 OFFSET $SG2879
  0008f	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  00092	8b 02		 mov	 eax, DWORD PTR [edx]
  00094	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  00097	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 _strncmp
  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a3	85 c0		 test	 eax, eax
  000a5	75 23		 jne	 SHORT $LN7@parse_valu

; 1226 : 	{
; 1227 : 		item->type = cJSON_False;

  000a7	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  000aa	c7 42 0c 01 00
	00 00		 mov	 DWORD PTR [edx+12], 1

; 1228 : 		input_buffer->offset += 5;

  000b1	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  000b4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b7	83 c1 05	 add	 ecx, 5
  000ba	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  000bd	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1229 : 		return true;

  000c0	b8 01 00 00 00	 mov	 eax, 1
  000c5	e9 ab 01 00 00	 jmp	 $LN11@parse_valu
$LN7@parse_valu:

; 1230 : 	}
; 1231 : 	/* true */
; 1232 : 	if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "true", 4) == 0))

  000ca	83 7d 0c 00	 cmp	 DWORD PTR _input_buffer$[ebp], 0
  000ce	74 5d		 je	 SHORT $LN6@parse_valu
  000d0	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  000d3	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000d6	83 c1 04	 add	 ecx, 4
  000d9	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  000dc	3b 4a 04	 cmp	 ecx, DWORD PTR [edx+4]
  000df	77 4c		 ja	 SHORT $LN6@parse_valu
  000e1	6a 04		 push	 4
  000e3	68 00 00 00 00	 push	 OFFSET $SG2883
  000e8	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  000eb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ed	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  000f0	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  000f3	51		 push	 ecx
  000f4	e8 00 00 00 00	 call	 _strncmp
  000f9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fc	85 c0		 test	 eax, eax
  000fe	75 2d		 jne	 SHORT $LN6@parse_valu

; 1233 : 	{
; 1234 : 		item->type = cJSON_True;

  00100	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00103	c7 40 0c 02 00
	00 00		 mov	 DWORD PTR [eax+12], 2

; 1235 : 		item->valueint = 1;

  0010a	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  0010d	c7 41 14 01 00
	00 00		 mov	 DWORD PTR [ecx+20], 1

; 1236 : 		input_buffer->offset += 4;

  00114	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  00117	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0011a	83 c0 04	 add	 eax, 4
  0011d	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  00120	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1237 : 		return true;

  00123	b8 01 00 00 00	 mov	 eax, 1
  00128	e9 48 01 00 00	 jmp	 $LN11@parse_valu
$LN6@parse_valu:

; 1238 : 	}
; 1239 : 	/* string */
; 1240 : 	if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '\"'))

  0012d	83 7d 0c 00	 cmp	 DWORD PTR _input_buffer$[ebp], 0
  00131	74 3f		 je	 SHORT $LN5@parse_valu
  00133	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  00136	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  00139	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0013c	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0013f	73 31		 jae	 SHORT $LN5@parse_valu
  00141	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  00144	8b 02		 mov	 eax, DWORD PTR [edx]
  00146	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  00149	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  0014c	ba 01 00 00 00	 mov	 edx, 1
  00151	6b ca 00	 imul	 ecx, edx, 0
  00154	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  00158	83 fa 22	 cmp	 edx, 34			; 00000022H
  0015b	75 15		 jne	 SHORT $LN5@parse_valu

; 1241 : 	{
; 1242 : 		return parse_string(item, input_buffer);

  0015d	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  00160	50		 push	 eax
  00161	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00164	51		 push	 ecx
  00165	e8 00 00 00 00	 call	 _parse_string
  0016a	83 c4 08	 add	 esp, 8
  0016d	e9 03 01 00 00	 jmp	 $LN11@parse_valu
$LN5@parse_valu:

; 1243 : 	}
; 1244 : 	/* number */
; 1245 : 	if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9'))))

  00172	83 7d 0c 00	 cmp	 DWORD PTR _input_buffer$[ebp], 0
  00176	74 77		 je	 SHORT $LN4@parse_valu
  00178	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  0017b	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  0017e	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00181	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00184	73 69		 jae	 SHORT $LN4@parse_valu
  00186	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  00189	8b 02		 mov	 eax, DWORD PTR [edx]
  0018b	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  0018e	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00191	ba 01 00 00 00	 mov	 edx, 1
  00196	6b ca 00	 imul	 ecx, edx, 0
  00199	0f b6 14 08	 movzx	 edx, BYTE PTR [eax+ecx]
  0019d	83 fa 2d	 cmp	 edx, 45			; 0000002dH
  001a0	74 38		 je	 SHORT $LN3@parse_valu
  001a2	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  001a5	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a7	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  001aa	03 4a 08	 add	 ecx, DWORD PTR [edx+8]
  001ad	b8 01 00 00 00	 mov	 eax, 1
  001b2	6b d0 00	 imul	 edx, eax, 0
  001b5	0f b6 04 11	 movzx	 eax, BYTE PTR [ecx+edx]
  001b9	83 f8 30	 cmp	 eax, 48			; 00000030H
  001bc	7c 31		 jl	 SHORT $LN4@parse_valu
  001be	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  001c1	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c3	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  001c6	03 50 08	 add	 edx, DWORD PTR [eax+8]
  001c9	b9 01 00 00 00	 mov	 ecx, 1
  001ce	6b c1 00	 imul	 eax, ecx, 0
  001d1	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  001d5	83 f9 39	 cmp	 ecx, 57			; 00000039H
  001d8	7f 15		 jg	 SHORT $LN4@parse_valu
$LN3@parse_valu:

; 1246 : 	{
; 1247 : 		return parse_number(item, input_buffer);

  001da	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  001dd	52		 push	 edx
  001de	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  001e1	50		 push	 eax
  001e2	e8 00 00 00 00	 call	 _parse_number
  001e7	83 c4 08	 add	 esp, 8
  001ea	e9 86 00 00 00	 jmp	 $LN11@parse_valu
$LN4@parse_valu:

; 1248 : 	}
; 1249 : 	/* array */
; 1250 : 	if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '['))

  001ef	83 7d 0c 00	 cmp	 DWORD PTR _input_buffer$[ebp], 0
  001f3	74 3c		 je	 SHORT $LN2@parse_valu
  001f5	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  001f8	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  001fb	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  001fe	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00201	73 2e		 jae	 SHORT $LN2@parse_valu
  00203	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  00206	8b 11		 mov	 edx, DWORD PTR [ecx]
  00208	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  0020b	03 50 08	 add	 edx, DWORD PTR [eax+8]
  0020e	b9 01 00 00 00	 mov	 ecx, 1
  00213	6b c1 00	 imul	 eax, ecx, 0
  00216	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  0021a	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  0021d	75 12		 jne	 SHORT $LN2@parse_valu

; 1251 : 	{
; 1252 : 		return parse_array(item, input_buffer);

  0021f	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  00222	52		 push	 edx
  00223	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00226	50		 push	 eax
  00227	e8 00 00 00 00	 call	 _parse_array
  0022c	83 c4 08	 add	 esp, 8
  0022f	eb 44		 jmp	 SHORT $LN11@parse_valu
$LN2@parse_valu:

; 1253 : 	}
; 1254 : 	/* object */
; 1255 : 	if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '{'))

  00231	83 7d 0c 00	 cmp	 DWORD PTR _input_buffer$[ebp], 0
  00235	74 3c		 je	 SHORT $LN1@parse_valu
  00237	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  0023a	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  0023d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00240	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00243	73 2e		 jae	 SHORT $LN1@parse_valu
  00245	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  00248	8b 11		 mov	 edx, DWORD PTR [ecx]
  0024a	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  0024d	03 50 08	 add	 edx, DWORD PTR [eax+8]
  00250	b9 01 00 00 00	 mov	 ecx, 1
  00255	6b c1 00	 imul	 eax, ecx, 0
  00258	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  0025c	83 f9 7b	 cmp	 ecx, 123		; 0000007bH
  0025f	75 12		 jne	 SHORT $LN1@parse_valu

; 1256 : 	{
; 1257 : 		return parse_object(item, input_buffer);

  00261	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  00264	52		 push	 edx
  00265	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00268	50		 push	 eax
  00269	e8 00 00 00 00	 call	 _parse_object
  0026e	83 c4 08	 add	 esp, 8
  00271	eb 02		 jmp	 SHORT $LN11@parse_valu
$LN1@parse_valu:

; 1258 : 	}
; 1259 : 
; 1260 : 	return false;

  00273	33 c0		 xor	 eax, eax
$LN11@parse_valu:

; 1261 : }

  00275	5d		 pop	 ebp
  00276	c3		 ret	 0
_parse_value ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _print_string
_TEXT	SEGMENT
_item$ = 8						; size = 4
_p$ = 12						; size = 4
_print_string PROC					; COMDAT

; 947  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 948  : 	return print_string_ptr((unsigned char*)item->valuestring, p);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  0000a	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0000d	52		 push	 edx
  0000e	e8 00 00 00 00	 call	 _print_string_ptr
  00013	83 c4 08	 add	 esp, 8

; 949  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
_print_string ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _print_string_ptr
_TEXT	SEGMENT
tv150 = -28						; size = 4
tv76 = -24						; size = 4
_escape_characters$ = -20				; size = 4
_output_length$ = -16					; size = 4
_output$ = -12						; size = 4
_output_pointer$ = -8					; size = 4
_input_pointer$ = -4					; size = 4
_input$ = 8						; size = 4
_output_buffer$ = 12					; size = 4
_print_string_ptr PROC					; COMDAT

; 825  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 826  : 	const unsigned char *input_pointer = NULL;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _input_pointer$[ebp], 0

; 827  : 	unsigned char *output = NULL;

  0000d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _output$[ebp], 0

; 828  : 	unsigned char *output_pointer = NULL;

  00014	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _output_pointer$[ebp], 0

; 829  : 	size_t output_length = 0;

  0001b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _output_length$[ebp], 0

; 830  : 	/* numbers of additional characters needed for escaping */
; 831  : 	size_t escape_characters = 0;

  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _escape_characters$[ebp], 0

; 832  : 
; 833  : 	if (output_buffer == NULL)

  00029	83 7d 0c 00	 cmp	 DWORD PTR _output_buffer$[ebp], 0
  0002d	75 07		 jne	 SHORT $LN28@print_stri

; 834  : 	{
; 835  : 		return false;

  0002f	33 c0		 xor	 eax, eax
  00031	e9 3c 02 00 00	 jmp	 $LN29@print_stri
$LN28@print_stri:

; 836  : 	}
; 837  : 
; 838  : 	/* empty string */
; 839  : 	if (input == NULL)

  00036	83 7d 08 00	 cmp	 DWORD PTR _input$[ebp], 0
  0003a	75 39		 jne	 SHORT $LN27@print_stri

; 840  : 	{
; 841  : 		output = ensure(output_buffer, sizeof("\"\""));

  0003c	6a 03		 push	 3
  0003e	8b 45 0c	 mov	 eax, DWORD PTR _output_buffer$[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 _ensure
  00047	83 c4 08	 add	 esp, 8
  0004a	89 45 f4	 mov	 DWORD PTR _output$[ebp], eax

; 842  : 		if (output == NULL)

  0004d	83 7d f4 00	 cmp	 DWORD PTR _output$[ebp], 0
  00051	75 07		 jne	 SHORT $LN26@print_stri

; 843  : 		{
; 844  : 			return false;

  00053	33 c0		 xor	 eax, eax
  00055	e9 18 02 00 00	 jmp	 $LN29@print_stri
$LN26@print_stri:

; 845  : 		}
; 846  : 		strcpy((char*)output, "\"\"");

  0005a	68 00 00 00 00	 push	 OFFSET $SG2673
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR _output$[ebp]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 _strcpy
  00068	83 c4 08	 add	 esp, 8

; 847  : 
; 848  : 		return true;

  0006b	b8 01 00 00 00	 mov	 eax, 1
  00070	e9 fd 01 00 00	 jmp	 $LN29@print_stri
$LN27@print_stri:

; 849  : 	}
; 850  : 
; 851  : 	/* set "flag" to 1 if something needs to be escaped */
; 852  : 	for (input_pointer = input; *input_pointer; input_pointer++)

  00075	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00078	89 55 fc	 mov	 DWORD PTR _input_pointer$[ebp], edx
  0007b	eb 09		 jmp	 SHORT $LN25@print_stri
$LN24@print_stri:
  0007d	8b 45 fc	 mov	 eax, DWORD PTR _input_pointer$[ebp]
  00080	83 c0 01	 add	 eax, 1
  00083	89 45 fc	 mov	 DWORD PTR _input_pointer$[ebp], eax
$LN25@print_stri:
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _input_pointer$[ebp]
  00089	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0008c	85 d2		 test	 edx, edx
  0008e	74 4a		 je	 SHORT $LN23@print_stri

; 853  : 	{
; 854  : 		switch (*input_pointer)

  00090	8b 45 fc	 mov	 eax, DWORD PTR _input_pointer$[ebp]
  00093	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00096	89 4d e8	 mov	 DWORD PTR tv76[ebp], ecx
  00099	8b 55 e8	 mov	 edx, DWORD PTR tv76[ebp]
  0009c	83 ea 08	 sub	 edx, 8
  0009f	89 55 e8	 mov	 DWORD PTR tv76[ebp], edx
  000a2	83 7d e8 54	 cmp	 DWORD PTR tv76[ebp], 84	; 00000054H
  000a6	77 1c		 ja	 SHORT $LN19@print_stri
  000a8	8b 45 e8	 mov	 eax, DWORD PTR tv76[ebp]
  000ab	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN31@print_stri[eax]
  000b2	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN33@print_stri[ecx*4]
$LN20@print_stri:

; 855  : 		{
; 856  : 		case '\"':
; 857  : 		case '\\':
; 858  : 		case '\b':
; 859  : 		case '\f':
; 860  : 		case '\n':
; 861  : 		case '\r':
; 862  : 		case '\t':
; 863  : 			/* one character escape sequence */
; 864  : 			escape_characters++;

  000b9	8b 55 ec	 mov	 edx, DWORD PTR _escape_characters$[ebp]
  000bc	83 c2 01	 add	 edx, 1
  000bf	89 55 ec	 mov	 DWORD PTR _escape_characters$[ebp], edx

; 865  : 			break;

  000c2	eb 14		 jmp	 SHORT $LN21@print_stri
$LN19@print_stri:

; 866  : 		default:
; 867  : 			if (*input_pointer < 32)

  000c4	8b 45 fc	 mov	 eax, DWORD PTR _input_pointer$[ebp]
  000c7	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000ca	83 f9 20	 cmp	 ecx, 32			; 00000020H
  000cd	7d 09		 jge	 SHORT $LN21@print_stri

; 868  : 			{
; 869  : 				/* UTF-16 escape sequence uXXXX */
; 870  : 				escape_characters += 5;

  000cf	8b 55 ec	 mov	 edx, DWORD PTR _escape_characters$[ebp]
  000d2	83 c2 05	 add	 edx, 5
  000d5	89 55 ec	 mov	 DWORD PTR _escape_characters$[ebp], edx
$LN21@print_stri:

; 871  : 			}
; 872  : 			break;
; 873  : 		}
; 874  : 	}

  000d8	eb a3		 jmp	 SHORT $LN24@print_stri
$LN23@print_stri:

; 875  : 	output_length = (size_t)(input_pointer - input) + escape_characters;

  000da	8b 45 fc	 mov	 eax, DWORD PTR _input_pointer$[ebp]
  000dd	2b 45 08	 sub	 eax, DWORD PTR _input$[ebp]
  000e0	03 45 ec	 add	 eax, DWORD PTR _escape_characters$[ebp]
  000e3	89 45 f0	 mov	 DWORD PTR _output_length$[ebp], eax

; 876  : 
; 877  : 	output = ensure(output_buffer, output_length + sizeof("\"\""));

  000e6	8b 4d f0	 mov	 ecx, DWORD PTR _output_length$[ebp]
  000e9	83 c1 03	 add	 ecx, 3
  000ec	51		 push	 ecx
  000ed	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  000f0	52		 push	 edx
  000f1	e8 00 00 00 00	 call	 _ensure
  000f6	83 c4 08	 add	 esp, 8
  000f9	89 45 f4	 mov	 DWORD PTR _output$[ebp], eax

; 878  : 	if (output == NULL)

  000fc	83 7d f4 00	 cmp	 DWORD PTR _output$[ebp], 0
  00100	75 07		 jne	 SHORT $LN17@print_stri

; 879  : 	{
; 880  : 		return false;

  00102	33 c0		 xor	 eax, eax
  00104	e9 69 01 00 00	 jmp	 $LN29@print_stri
$LN17@print_stri:

; 881  : 	}
; 882  : 
; 883  : 	/* no characters have to be escaped */
; 884  : 	if (escape_characters == 0)

  00109	83 7d ec 00	 cmp	 DWORD PTR _escape_characters$[ebp], 0
  0010d	75 44		 jne	 SHORT $LN16@print_stri

; 885  : 	{
; 886  : 		output[0] = '\"';

  0010f	b8 01 00 00 00	 mov	 eax, 1
  00114	6b c8 00	 imul	 ecx, eax, 0
  00117	8b 55 f4	 mov	 edx, DWORD PTR _output$[ebp]
  0011a	c6 04 0a 22	 mov	 BYTE PTR [edx+ecx], 34	; 00000022H

; 887  : 		memcpy(output + 1, input, output_length);

  0011e	8b 45 f0	 mov	 eax, DWORD PTR _output_length$[ebp]
  00121	50		 push	 eax
  00122	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00125	51		 push	 ecx
  00126	8b 55 f4	 mov	 edx, DWORD PTR _output$[ebp]
  00129	83 c2 01	 add	 edx, 1
  0012c	52		 push	 edx
  0012d	e8 00 00 00 00	 call	 _memcpy
  00132	83 c4 0c	 add	 esp, 12			; 0000000cH

; 888  : 		output[output_length + 1] = '\"';

  00135	8b 45 f4	 mov	 eax, DWORD PTR _output$[ebp]
  00138	03 45 f0	 add	 eax, DWORD PTR _output_length$[ebp]
  0013b	c6 40 01 22	 mov	 BYTE PTR [eax+1], 34	; 00000022H

; 889  : 		output[output_length + 2] = '\0';

  0013f	8b 4d f4	 mov	 ecx, DWORD PTR _output$[ebp]
  00142	03 4d f0	 add	 ecx, DWORD PTR _output_length$[ebp]
  00145	c6 41 02 00	 mov	 BYTE PTR [ecx+2], 0

; 890  : 
; 891  : 		return true;

  00149	b8 01 00 00 00	 mov	 eax, 1
  0014e	e9 1f 01 00 00	 jmp	 $LN29@print_stri
$LN16@print_stri:

; 892  : 	}
; 893  : 
; 894  : 	output[0] = '\"';

  00153	ba 01 00 00 00	 mov	 edx, 1
  00158	6b c2 00	 imul	 eax, edx, 0
  0015b	8b 4d f4	 mov	 ecx, DWORD PTR _output$[ebp]
  0015e	c6 04 01 22	 mov	 BYTE PTR [ecx+eax], 34	; 00000022H

; 895  : 	output_pointer = output + 1;

  00162	8b 55 f4	 mov	 edx, DWORD PTR _output$[ebp]
  00165	83 c2 01	 add	 edx, 1
  00168	89 55 f8	 mov	 DWORD PTR _output_pointer$[ebp], edx

; 896  : 	/* copy the string */
; 897  : 	for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)

  0016b	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  0016e	89 45 fc	 mov	 DWORD PTR _input_pointer$[ebp], eax
  00171	eb 12		 jmp	 SHORT $LN15@print_stri
$LN14@print_stri:
  00173	8b 4d fc	 mov	 ecx, DWORD PTR _input_pointer$[ebp]
  00176	83 c1 01	 add	 ecx, 1
  00179	89 4d fc	 mov	 DWORD PTR _input_pointer$[ebp], ecx
  0017c	8b 55 f8	 mov	 edx, DWORD PTR _output_pointer$[ebp]
  0017f	83 c2 01	 add	 edx, 1
  00182	89 55 f8	 mov	 DWORD PTR _output_pointer$[ebp], edx
$LN15@print_stri:
  00185	8b 45 fc	 mov	 eax, DWORD PTR _input_pointer$[ebp]
  00188	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0018b	85 c9		 test	 ecx, ecx
  0018d	0f 84 c6 00 00
	00		 je	 $LN13@print_stri

; 898  : 	{
; 899  : 		if ((*input_pointer > 31) && (*input_pointer != '\"') && (*input_pointer != '\\'))

  00193	8b 55 fc	 mov	 edx, DWORD PTR _input_pointer$[ebp]
  00196	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00199	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0019c	7e 25		 jle	 SHORT $LN12@print_stri
  0019e	8b 4d fc	 mov	 ecx, DWORD PTR _input_pointer$[ebp]
  001a1	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  001a4	83 fa 22	 cmp	 edx, 34			; 00000022H
  001a7	74 1a		 je	 SHORT $LN12@print_stri
  001a9	8b 45 fc	 mov	 eax, DWORD PTR _input_pointer$[ebp]
  001ac	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001af	83 f9 5c	 cmp	 ecx, 92			; 0000005cH
  001b2	74 0f		 je	 SHORT $LN12@print_stri

; 900  : 		{
; 901  : 			/* normal character, copy */
; 902  : 			*output_pointer = *input_pointer;

  001b4	8b 55 f8	 mov	 edx, DWORD PTR _output_pointer$[ebp]
  001b7	8b 45 fc	 mov	 eax, DWORD PTR _input_pointer$[ebp]
  001ba	8a 08		 mov	 cl, BYTE PTR [eax]
  001bc	88 0a		 mov	 BYTE PTR [edx], cl

; 903  : 		}
; 904  : 		else

  001be	e9 91 00 00 00	 jmp	 $LN11@print_stri
$LN12@print_stri:

; 905  : 		{
; 906  : 			/* character needs to be escaped */
; 907  : 			*output_pointer++ = '\\';

  001c3	8b 55 f8	 mov	 edx, DWORD PTR _output_pointer$[ebp]
  001c6	c6 02 5c	 mov	 BYTE PTR [edx], 92	; 0000005cH
  001c9	8b 45 f8	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  001cc	83 c0 01	 add	 eax, 1
  001cf	89 45 f8	 mov	 DWORD PTR _output_pointer$[ebp], eax

; 908  : 			switch (*input_pointer)

  001d2	8b 4d fc	 mov	 ecx, DWORD PTR _input_pointer$[ebp]
  001d5	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  001d8	89 55 e4	 mov	 DWORD PTR tv150[ebp], edx
  001db	8b 45 e4	 mov	 eax, DWORD PTR tv150[ebp]
  001de	83 e8 08	 sub	 eax, 8
  001e1	89 45 e4	 mov	 DWORD PTR tv150[ebp], eax
  001e4	83 7d e4 54	 cmp	 DWORD PTR tv150[ebp], 84 ; 00000054H
  001e8	77 49		 ja	 SHORT $LN1@print_stri
  001ea	8b 4d e4	 mov	 ecx, DWORD PTR tv150[ebp]
  001ed	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN32@print_stri[ecx]
  001f4	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN34@print_stri[edx*4]
$LN8@print_stri:

; 909  : 			{
; 910  : 			case '\\':
; 911  : 				*output_pointer = '\\';

  001fb	8b 45 f8	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  001fe	c6 00 5c	 mov	 BYTE PTR [eax], 92	; 0000005cH

; 912  : 				break;

  00201	eb 51		 jmp	 SHORT $LN11@print_stri
$LN7@print_stri:

; 913  : 			case '\"':
; 914  : 				*output_pointer = '\"';

  00203	8b 4d f8	 mov	 ecx, DWORD PTR _output_pointer$[ebp]
  00206	c6 01 22	 mov	 BYTE PTR [ecx], 34	; 00000022H

; 915  : 				break;

  00209	eb 49		 jmp	 SHORT $LN11@print_stri
$LN6@print_stri:

; 916  : 			case '\b':
; 917  : 				*output_pointer = 'b';

  0020b	8b 55 f8	 mov	 edx, DWORD PTR _output_pointer$[ebp]
  0020e	c6 02 62	 mov	 BYTE PTR [edx], 98	; 00000062H

; 918  : 				break;

  00211	eb 41		 jmp	 SHORT $LN11@print_stri
$LN5@print_stri:

; 919  : 			case '\f':
; 920  : 				*output_pointer = 'f';

  00213	8b 45 f8	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  00216	c6 00 66	 mov	 BYTE PTR [eax], 102	; 00000066H

; 921  : 				break;

  00219	eb 39		 jmp	 SHORT $LN11@print_stri
$LN4@print_stri:

; 922  : 			case '\n':
; 923  : 				*output_pointer = 'n';

  0021b	8b 4d f8	 mov	 ecx, DWORD PTR _output_pointer$[ebp]
  0021e	c6 01 6e	 mov	 BYTE PTR [ecx], 110	; 0000006eH

; 924  : 				break;

  00221	eb 31		 jmp	 SHORT $LN11@print_stri
$LN3@print_stri:

; 925  : 			case '\r':
; 926  : 				*output_pointer = 'r';

  00223	8b 55 f8	 mov	 edx, DWORD PTR _output_pointer$[ebp]
  00226	c6 02 72	 mov	 BYTE PTR [edx], 114	; 00000072H

; 927  : 				break;

  00229	eb 29		 jmp	 SHORT $LN11@print_stri
$LN2@print_stri:

; 928  : 			case '\t':
; 929  : 				*output_pointer = 't';

  0022b	8b 45 f8	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  0022e	c6 00 74	 mov	 BYTE PTR [eax], 116	; 00000074H

; 930  : 				break;

  00231	eb 21		 jmp	 SHORT $LN11@print_stri
$LN1@print_stri:

; 931  : 			default:
; 932  : 				/* escape and print as unicode codepoint */
; 933  : 				sprintf((char*)output_pointer, "u%04x", *input_pointer);

  00233	8b 4d fc	 mov	 ecx, DWORD PTR _input_pointer$[ebp]
  00236	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00239	52		 push	 edx
  0023a	68 00 00 00 00	 push	 OFFSET $SG2709
  0023f	8b 45 f8	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  00242	50		 push	 eax
  00243	e8 00 00 00 00	 call	 __hx_sprintf
  00248	83 c4 0c	 add	 esp, 12			; 0000000cH

; 934  : 				output_pointer += 4;

  0024b	8b 4d f8	 mov	 ecx, DWORD PTR _output_pointer$[ebp]
  0024e	83 c1 04	 add	 ecx, 4
  00251	89 4d f8	 mov	 DWORD PTR _output_pointer$[ebp], ecx
$LN11@print_stri:

; 935  : 				break;
; 936  : 			}
; 937  : 		}
; 938  : 	}

  00254	e9 1a ff ff ff	 jmp	 $LN14@print_stri
$LN13@print_stri:

; 939  : 	output[output_length + 1] = '\"';

  00259	8b 55 f4	 mov	 edx, DWORD PTR _output$[ebp]
  0025c	03 55 f0	 add	 edx, DWORD PTR _output_length$[ebp]
  0025f	c6 42 01 22	 mov	 BYTE PTR [edx+1], 34	; 00000022H

; 940  : 	output[output_length + 2] = '\0';

  00263	8b 45 f4	 mov	 eax, DWORD PTR _output$[ebp]
  00266	03 45 f0	 add	 eax, DWORD PTR _output_length$[ebp]
  00269	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0

; 941  : 
; 942  : 	return true;

  0026d	b8 01 00 00 00	 mov	 eax, 1
$LN29@print_stri:

; 943  : }

  00272	8b e5		 mov	 esp, ebp
  00274	5d		 pop	 ebp
  00275	c3		 ret	 0
  00276	8b ff		 npad	 2
$LN33@print_stri:
  00278	00 00 00 00	 DD	 $LN20@print_stri
  0027c	00 00 00 00	 DD	 $LN19@print_stri
$LN31@print_stri:
  00280	00		 DB	 0
  00281	00		 DB	 0
  00282	00		 DB	 0
  00283	01		 DB	 1
  00284	00		 DB	 0
  00285	00		 DB	 0
  00286	01		 DB	 1
  00287	01		 DB	 1
  00288	01		 DB	 1
  00289	01		 DB	 1
  0028a	01		 DB	 1
  0028b	01		 DB	 1
  0028c	01		 DB	 1
  0028d	01		 DB	 1
  0028e	01		 DB	 1
  0028f	01		 DB	 1
  00290	01		 DB	 1
  00291	01		 DB	 1
  00292	01		 DB	 1
  00293	01		 DB	 1
  00294	01		 DB	 1
  00295	01		 DB	 1
  00296	01		 DB	 1
  00297	01		 DB	 1
  00298	01		 DB	 1
  00299	01		 DB	 1
  0029a	00		 DB	 0
  0029b	01		 DB	 1
  0029c	01		 DB	 1
  0029d	01		 DB	 1
  0029e	01		 DB	 1
  0029f	01		 DB	 1
  002a0	01		 DB	 1
  002a1	01		 DB	 1
  002a2	01		 DB	 1
  002a3	01		 DB	 1
  002a4	01		 DB	 1
  002a5	01		 DB	 1
  002a6	01		 DB	 1
  002a7	01		 DB	 1
  002a8	01		 DB	 1
  002a9	01		 DB	 1
  002aa	01		 DB	 1
  002ab	01		 DB	 1
  002ac	01		 DB	 1
  002ad	01		 DB	 1
  002ae	01		 DB	 1
  002af	01		 DB	 1
  002b0	01		 DB	 1
  002b1	01		 DB	 1
  002b2	01		 DB	 1
  002b3	01		 DB	 1
  002b4	01		 DB	 1
  002b5	01		 DB	 1
  002b6	01		 DB	 1
  002b7	01		 DB	 1
  002b8	01		 DB	 1
  002b9	01		 DB	 1
  002ba	01		 DB	 1
  002bb	01		 DB	 1
  002bc	01		 DB	 1
  002bd	01		 DB	 1
  002be	01		 DB	 1
  002bf	01		 DB	 1
  002c0	01		 DB	 1
  002c1	01		 DB	 1
  002c2	01		 DB	 1
  002c3	01		 DB	 1
  002c4	01		 DB	 1
  002c5	01		 DB	 1
  002c6	01		 DB	 1
  002c7	01		 DB	 1
  002c8	01		 DB	 1
  002c9	01		 DB	 1
  002ca	01		 DB	 1
  002cb	01		 DB	 1
  002cc	01		 DB	 1
  002cd	01		 DB	 1
  002ce	01		 DB	 1
  002cf	01		 DB	 1
  002d0	01		 DB	 1
  002d1	01		 DB	 1
  002d2	01		 DB	 1
  002d3	01		 DB	 1
  002d4	00		 DB	 0
  002d5	8d 49 00	 npad	 3
$LN34@print_stri:
  002d8	00 00 00 00	 DD	 $LN6@print_stri
  002dc	00 00 00 00	 DD	 $LN2@print_stri
  002e0	00 00 00 00	 DD	 $LN4@print_stri
  002e4	00 00 00 00	 DD	 $LN5@print_stri
  002e8	00 00 00 00	 DD	 $LN3@print_stri
  002ec	00 00 00 00	 DD	 $LN7@print_stri
  002f0	00 00 00 00	 DD	 $LN8@print_stri
  002f4	00 00 00 00	 DD	 $LN1@print_stri
$LN32@print_stri:
  002f8	00		 DB	 0
  002f9	01		 DB	 1
  002fa	02		 DB	 2
  002fb	07		 DB	 7
  002fc	03		 DB	 3
  002fd	04		 DB	 4
  002fe	07		 DB	 7
  002ff	07		 DB	 7
  00300	07		 DB	 7
  00301	07		 DB	 7
  00302	07		 DB	 7
  00303	07		 DB	 7
  00304	07		 DB	 7
  00305	07		 DB	 7
  00306	07		 DB	 7
  00307	07		 DB	 7
  00308	07		 DB	 7
  00309	07		 DB	 7
  0030a	07		 DB	 7
  0030b	07		 DB	 7
  0030c	07		 DB	 7
  0030d	07		 DB	 7
  0030e	07		 DB	 7
  0030f	07		 DB	 7
  00310	07		 DB	 7
  00311	07		 DB	 7
  00312	05		 DB	 5
  00313	07		 DB	 7
  00314	07		 DB	 7
  00315	07		 DB	 7
  00316	07		 DB	 7
  00317	07		 DB	 7
  00318	07		 DB	 7
  00319	07		 DB	 7
  0031a	07		 DB	 7
  0031b	07		 DB	 7
  0031c	07		 DB	 7
  0031d	07		 DB	 7
  0031e	07		 DB	 7
  0031f	07		 DB	 7
  00320	07		 DB	 7
  00321	07		 DB	 7
  00322	07		 DB	 7
  00323	07		 DB	 7
  00324	07		 DB	 7
  00325	07		 DB	 7
  00326	07		 DB	 7
  00327	07		 DB	 7
  00328	07		 DB	 7
  00329	07		 DB	 7
  0032a	07		 DB	 7
  0032b	07		 DB	 7
  0032c	07		 DB	 7
  0032d	07		 DB	 7
  0032e	07		 DB	 7
  0032f	07		 DB	 7
  00330	07		 DB	 7
  00331	07		 DB	 7
  00332	07		 DB	 7
  00333	07		 DB	 7
  00334	07		 DB	 7
  00335	07		 DB	 7
  00336	07		 DB	 7
  00337	07		 DB	 7
  00338	07		 DB	 7
  00339	07		 DB	 7
  0033a	07		 DB	 7
  0033b	07		 DB	 7
  0033c	07		 DB	 7
  0033d	07		 DB	 7
  0033e	07		 DB	 7
  0033f	07		 DB	 7
  00340	07		 DB	 7
  00341	07		 DB	 7
  00342	07		 DB	 7
  00343	07		 DB	 7
  00344	07		 DB	 7
  00345	07		 DB	 7
  00346	07		 DB	 7
  00347	07		 DB	 7
  00348	07		 DB	 7
  00349	07		 DB	 7
  0034a	07		 DB	 7
  0034b	07		 DB	 7
  0034c	06		 DB	 6
_print_string_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _parse_string
_TEXT	SEGMENT
_allocation_length$1 = -32				; size = 4
_skipped_bytes$2 = -28					; size = 4
tv155 = -24						; size = 4
_output$ = -20						; size = 4
_input_pointer$ = -16					; size = 4
_input_end$ = -12					; size = 4
_output_pointer$ = -8					; size = 4
_sequence_length$3 = -1					; size = 1
_item$ = 8						; size = 4
_input_buffer$ = 12					; size = 4
_parse_string PROC					; COMDAT

; 696  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 697  : 	const unsigned char *input_pointer = buffer_at_offset(input_buffer) + 1;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  0000e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00011	8d 4c 01 01	 lea	 ecx, DWORD PTR [ecx+eax+1]
  00015	89 4d f0	 mov	 DWORD PTR _input_pointer$[ebp], ecx

; 698  : 	const unsigned char *input_end = buffer_at_offset(input_buffer) + 1;

  00018	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  0001b	8b 02		 mov	 eax, DWORD PTR [edx]
  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  00020	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00023	8d 44 10 01	 lea	 eax, DWORD PTR [eax+edx+1]
  00027	89 45 f4	 mov	 DWORD PTR _input_end$[ebp], eax

; 699  : 	unsigned char *output_pointer = NULL;

  0002a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _output_pointer$[ebp], 0

; 700  : 	unsigned char *output = NULL;

  00031	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _output$[ebp], 0

; 701  : 
; 702  : 	/* not a string */
; 703  : 	if (buffer_at_offset(input_buffer)[0] != '\"')

  00038	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  0003b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003d	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  00040	03 50 08	 add	 edx, DWORD PTR [eax+8]
  00043	b9 01 00 00 00	 mov	 ecx, 1
  00048	6b c1 00	 imul	 eax, ecx, 0
  0004b	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  0004f	83 f9 22	 cmp	 ecx, 34			; 00000022H
  00052	74 05		 je	 SHORT $LN26@parse_stri

; 704  : 	{
; 705  : 		goto fail;

  00054	e9 37 02 00 00	 jmp	 $fail$31
$LN26@parse_stri:

; 706  : 	}
; 707  : 
; 708  : 	{
; 709  : 		/* calculate approximate size of the output (overestimate) */
; 710  : 		size_t allocation_length = 0;

  00059	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _allocation_length$1[ebp], 0

; 711  : 		size_t skipped_bytes = 0;

  00060	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _skipped_bytes$2[ebp], 0
$LN25@parse_stri:

; 712  : 		while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\"'))

  00067	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  0006a	8b 45 f4	 mov	 eax, DWORD PTR _input_end$[ebp]
  0006d	2b 02		 sub	 eax, DWORD PTR [edx]
  0006f	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  00072	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00075	73 54		 jae	 SHORT $LN24@parse_stri
  00077	8b 55 f4	 mov	 edx, DWORD PTR _input_end$[ebp]
  0007a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0007d	83 f8 22	 cmp	 eax, 34			; 00000022H
  00080	74 49		 je	 SHORT $LN24@parse_stri

; 713  : 		{
; 714  : 			/* is escape sequence */
; 715  : 			if (input_end[0] == '\\')

  00082	b9 01 00 00 00	 mov	 ecx, 1
  00087	6b d1 00	 imul	 edx, ecx, 0
  0008a	8b 45 f4	 mov	 eax, DWORD PTR _input_end$[ebp]
  0008d	0f b6 0c 10	 movzx	 ecx, BYTE PTR [eax+edx]
  00091	83 f9 5c	 cmp	 ecx, 92			; 0000005cH
  00094	75 2a		 jne	 SHORT $LN23@parse_stri

; 716  : 			{
; 717  : 				if ((size_t)(input_end + 1 - input_buffer->content) >= input_buffer->length)

  00096	8b 55 f4	 mov	 edx, DWORD PTR _input_end$[ebp]
  00099	83 c2 01	 add	 edx, 1
  0009c	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  0009f	2b 10		 sub	 edx, DWORD PTR [eax]
  000a1	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  000a4	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  000a7	72 05		 jb	 SHORT $LN22@parse_stri

; 718  : 				{
; 719  : 					/* prevent buffer overflow when last input character is a backslash */
; 720  : 					goto fail;

  000a9	e9 e2 01 00 00	 jmp	 $fail$31
$LN22@parse_stri:

; 721  : 				}
; 722  : 				skipped_bytes++;

  000ae	8b 55 e4	 mov	 edx, DWORD PTR _skipped_bytes$2[ebp]
  000b1	83 c2 01	 add	 edx, 1
  000b4	89 55 e4	 mov	 DWORD PTR _skipped_bytes$2[ebp], edx

; 723  : 				input_end++;

  000b7	8b 45 f4	 mov	 eax, DWORD PTR _input_end$[ebp]
  000ba	83 c0 01	 add	 eax, 1
  000bd	89 45 f4	 mov	 DWORD PTR _input_end$[ebp], eax
$LN23@parse_stri:

; 724  : 			}
; 725  : 			input_end++;

  000c0	8b 4d f4	 mov	 ecx, DWORD PTR _input_end$[ebp]
  000c3	83 c1 01	 add	 ecx, 1
  000c6	89 4d f4	 mov	 DWORD PTR _input_end$[ebp], ecx

; 726  : 		}

  000c9	eb 9c		 jmp	 SHORT $LN25@parse_stri
$LN24@parse_stri:

; 727  : 		if (((size_t)(input_end - input_buffer->content) >= input_buffer->length) || (*input_end != '\"'))

  000cb	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  000ce	8b 45 f4	 mov	 eax, DWORD PTR _input_end$[ebp]
  000d1	2b 02		 sub	 eax, DWORD PTR [edx]
  000d3	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  000d6	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  000d9	73 0b		 jae	 SHORT $LN20@parse_stri
  000db	8b 55 f4	 mov	 edx, DWORD PTR _input_end$[ebp]
  000de	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000e1	83 f8 22	 cmp	 eax, 34			; 00000022H
  000e4	74 05		 je	 SHORT $LN21@parse_stri
$LN20@parse_stri:

; 728  : 		{
; 729  : 			goto fail; /* string ended unexpectedly */

  000e6	e9 a5 01 00 00	 jmp	 $fail$31
$LN21@parse_stri:

; 730  : 		}
; 731  : 
; 732  : 		/* This is at most how much we need for the output */
; 733  : 		allocation_length = (size_t)(input_end - buffer_at_offset(input_buffer)) - skipped_bytes;

  000eb	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  000ee	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f0	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  000f3	03 50 08	 add	 edx, DWORD PTR [eax+8]
  000f6	8b 4d f4	 mov	 ecx, DWORD PTR _input_end$[ebp]
  000f9	2b ca		 sub	 ecx, edx
  000fb	2b 4d e4	 sub	 ecx, DWORD PTR _skipped_bytes$2[ebp]
  000fe	89 4d e0	 mov	 DWORD PTR _allocation_length$1[ebp], ecx

; 734  : 		output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(""));

  00101	8b 55 e0	 mov	 edx, DWORD PTR _allocation_length$1[ebp]
  00104	83 c2 01	 add	 edx, 1
  00107	52		 push	 edx
  00108	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  0010b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0010e	ff d1		 call	 ecx
  00110	83 c4 04	 add	 esp, 4
  00113	89 45 ec	 mov	 DWORD PTR _output$[ebp], eax

; 735  : 		if (output == NULL)

  00116	83 7d ec 00	 cmp	 DWORD PTR _output$[ebp], 0
  0011a	75 05		 jne	 SHORT $LN19@parse_stri

; 736  : 		{
; 737  : 			goto fail; /* allocation failure */

  0011c	e9 6f 01 00 00	 jmp	 $fail$31
$LN19@parse_stri:

; 738  : 		}
; 739  : 	}
; 740  : 
; 741  : 	output_pointer = output;

  00121	8b 55 ec	 mov	 edx, DWORD PTR _output$[ebp]
  00124	89 55 f8	 mov	 DWORD PTR _output_pointer$[ebp], edx
$LN18@parse_stri:

; 742  : 	/* loop through the string literal */
; 743  : 	while (input_pointer < input_end)

  00127	8b 45 f0	 mov	 eax, DWORD PTR _input_pointer$[ebp]
  0012a	3b 45 f4	 cmp	 eax, DWORD PTR _input_end$[ebp]
  0012d	0f 83 20 01 00
	00		 jae	 $LN17@parse_stri

; 744  : 	{
; 745  : 		if (*input_pointer != '\\')

  00133	8b 4d f0	 mov	 ecx, DWORD PTR _input_pointer$[ebp]
  00136	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00139	83 fa 5c	 cmp	 edx, 92			; 0000005cH
  0013c	74 21		 je	 SHORT $LN16@parse_stri

; 746  : 		{
; 747  : 			*output_pointer++ = *input_pointer++;

  0013e	8b 45 f8	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  00141	8b 4d f0	 mov	 ecx, DWORD PTR _input_pointer$[ebp]
  00144	8a 11		 mov	 dl, BYTE PTR [ecx]
  00146	88 10		 mov	 BYTE PTR [eax], dl
  00148	8b 45 f8	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  0014b	83 c0 01	 add	 eax, 1
  0014e	89 45 f8	 mov	 DWORD PTR _output_pointer$[ebp], eax
  00151	8b 4d f0	 mov	 ecx, DWORD PTR _input_pointer$[ebp]
  00154	83 c1 01	 add	 ecx, 1
  00157	89 4d f0	 mov	 DWORD PTR _input_pointer$[ebp], ecx

; 748  : 		}
; 749  : 		/* escape sequence */
; 750  : 		else

  0015a	e9 ef 00 00 00	 jmp	 $LN15@parse_stri
$LN16@parse_stri:

; 751  : 		{
; 752  : 			unsigned char sequence_length = 2;

  0015f	c6 45 ff 02	 mov	 BYTE PTR _sequence_length$3[ebp], 2

; 753  : 			if ((input_end - input_pointer) < 1)

  00163	8b 55 f4	 mov	 edx, DWORD PTR _input_end$[ebp]
  00166	2b 55 f0	 sub	 edx, DWORD PTR _input_pointer$[ebp]
  00169	83 fa 01	 cmp	 edx, 1
  0016c	7d 05		 jge	 SHORT $LN14@parse_stri

; 754  : 			{
; 755  : 				goto fail;

  0016e	e9 1d 01 00 00	 jmp	 $fail$31
$LN14@parse_stri:

; 756  : 			}
; 757  : 
; 758  : 			switch (input_pointer[1])

  00173	b8 01 00 00 00	 mov	 eax, 1
  00178	c1 e0 00	 shl	 eax, 0
  0017b	8b 4d f0	 mov	 ecx, DWORD PTR _input_pointer$[ebp]
  0017e	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  00182	89 55 e8	 mov	 DWORD PTR tv155[ebp], edx
  00185	8b 45 e8	 mov	 eax, DWORD PTR tv155[ebp]
  00188	83 e8 22	 sub	 eax, 34			; 00000022H
  0018b	89 45 e8	 mov	 DWORD PTR tv155[ebp], eax
  0018e	83 7d e8 53	 cmp	 DWORD PTR tv155[ebp], 83 ; 00000053H
  00192	0f 87 aa 00 00
	00		 ja	 $LN3@parse_stri
  00198	8b 4d e8	 mov	 ecx, DWORD PTR tv155[ebp]
  0019b	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN29@parse_stri[ecx]
  001a2	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN30@parse_stri[edx*4]
$LN11@parse_stri:

; 759  : 			{
; 760  : 			case 'b':
; 761  : 				*output_pointer++ = '\b';

  001a9	8b 45 f8	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  001ac	c6 00 08	 mov	 BYTE PTR [eax], 8
  001af	8b 4d f8	 mov	 ecx, DWORD PTR _output_pointer$[ebp]
  001b2	83 c1 01	 add	 ecx, 1
  001b5	89 4d f8	 mov	 DWORD PTR _output_pointer$[ebp], ecx

; 762  : 				break;

  001b8	e9 87 00 00 00	 jmp	 $LN12@parse_stri
$LN10@parse_stri:

; 763  : 			case 'f':
; 764  : 				*output_pointer++ = '\f';

  001bd	8b 55 f8	 mov	 edx, DWORD PTR _output_pointer$[ebp]
  001c0	c6 02 0c	 mov	 BYTE PTR [edx], 12	; 0000000cH
  001c3	8b 45 f8	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  001c6	83 c0 01	 add	 eax, 1
  001c9	89 45 f8	 mov	 DWORD PTR _output_pointer$[ebp], eax

; 765  : 				break;

  001cc	eb 76		 jmp	 SHORT $LN12@parse_stri
$LN9@parse_stri:

; 766  : 			case 'n':
; 767  : 				*output_pointer++ = '\n';

  001ce	8b 4d f8	 mov	 ecx, DWORD PTR _output_pointer$[ebp]
  001d1	c6 01 0a	 mov	 BYTE PTR [ecx], 10	; 0000000aH
  001d4	8b 55 f8	 mov	 edx, DWORD PTR _output_pointer$[ebp]
  001d7	83 c2 01	 add	 edx, 1
  001da	89 55 f8	 mov	 DWORD PTR _output_pointer$[ebp], edx

; 768  : 				break;

  001dd	eb 65		 jmp	 SHORT $LN12@parse_stri
$LN8@parse_stri:

; 769  : 			case 'r':
; 770  : 				*output_pointer++ = '\r';

  001df	8b 45 f8	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  001e2	c6 00 0d	 mov	 BYTE PTR [eax], 13	; 0000000dH
  001e5	8b 4d f8	 mov	 ecx, DWORD PTR _output_pointer$[ebp]
  001e8	83 c1 01	 add	 ecx, 1
  001eb	89 4d f8	 mov	 DWORD PTR _output_pointer$[ebp], ecx

; 771  : 				break;

  001ee	eb 54		 jmp	 SHORT $LN12@parse_stri
$LN7@parse_stri:

; 772  : 			case 't':
; 773  : 				*output_pointer++ = '\t';

  001f0	8b 55 f8	 mov	 edx, DWORD PTR _output_pointer$[ebp]
  001f3	c6 02 09	 mov	 BYTE PTR [edx], 9
  001f6	8b 45 f8	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  001f9	83 c0 01	 add	 eax, 1
  001fc	89 45 f8	 mov	 DWORD PTR _output_pointer$[ebp], eax

; 774  : 				break;

  001ff	eb 43		 jmp	 SHORT $LN12@parse_stri
$LN6@parse_stri:

; 775  : 			case '\"':
; 776  : 			case '\\':
; 777  : 			case '/':
; 778  : 				*output_pointer++ = input_pointer[1];

  00201	b9 01 00 00 00	 mov	 ecx, 1
  00206	c1 e1 00	 shl	 ecx, 0
  00209	8b 55 f8	 mov	 edx, DWORD PTR _output_pointer$[ebp]
  0020c	8b 45 f0	 mov	 eax, DWORD PTR _input_pointer$[ebp]
  0020f	8a 0c 08	 mov	 cl, BYTE PTR [eax+ecx]
  00212	88 0a		 mov	 BYTE PTR [edx], cl
  00214	8b 55 f8	 mov	 edx, DWORD PTR _output_pointer$[ebp]
  00217	83 c2 01	 add	 edx, 1
  0021a	89 55 f8	 mov	 DWORD PTR _output_pointer$[ebp], edx

; 779  : 				break;

  0021d	eb 25		 jmp	 SHORT $LN12@parse_stri
$LN5@parse_stri:

; 780  : 
; 781  : 				/* UTF-16 literal */
; 782  : 			case 'u':
; 783  : 				sequence_length = utf16_literal_to_utf8(input_pointer, input_end, &output_pointer);

  0021f	8d 45 f8	 lea	 eax, DWORD PTR _output_pointer$[ebp]
  00222	50		 push	 eax
  00223	8b 4d f4	 mov	 ecx, DWORD PTR _input_end$[ebp]
  00226	51		 push	 ecx
  00227	8b 55 f0	 mov	 edx, DWORD PTR _input_pointer$[ebp]
  0022a	52		 push	 edx
  0022b	e8 00 00 00 00	 call	 _utf16_literal_to_utf8
  00230	83 c4 0c	 add	 esp, 12			; 0000000cH
  00233	88 45 ff	 mov	 BYTE PTR _sequence_length$3[ebp], al

; 784  : 				if (sequence_length == 0)

  00236	0f b6 45 ff	 movzx	 eax, BYTE PTR _sequence_length$3[ebp]
  0023a	85 c0		 test	 eax, eax
  0023c	75 02		 jne	 SHORT $LN4@parse_stri

; 785  : 				{
; 786  : 					/* failed to convert UTF16-literal to UTF-8 */
; 787  : 					goto fail;

  0023e	eb 50		 jmp	 SHORT $fail$31
$LN4@parse_stri:

; 788  : 				}
; 789  : 				break;

  00240	eb 02		 jmp	 SHORT $LN12@parse_stri
$LN3@parse_stri:

; 790  : 
; 791  : 			default:
; 792  : 				goto fail;

  00242	eb 4c		 jmp	 SHORT $fail$31
$LN12@parse_stri:

; 793  : 			}
; 794  : 			input_pointer += sequence_length;

  00244	0f b6 4d ff	 movzx	 ecx, BYTE PTR _sequence_length$3[ebp]
  00248	03 4d f0	 add	 ecx, DWORD PTR _input_pointer$[ebp]
  0024b	89 4d f0	 mov	 DWORD PTR _input_pointer$[ebp], ecx
$LN15@parse_stri:

; 795  : 		}
; 796  : 	}

  0024e	e9 d4 fe ff ff	 jmp	 $LN18@parse_stri
$LN17@parse_stri:

; 797  : 
; 798  : 	/* zero terminate the output */
; 799  : 	*output_pointer = '\0';

  00253	8b 55 f8	 mov	 edx, DWORD PTR _output_pointer$[ebp]
  00256	c6 02 00	 mov	 BYTE PTR [edx], 0

; 800  : 
; 801  : 	item->type = cJSON_String;

  00259	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  0025c	c7 40 0c 10 00
	00 00		 mov	 DWORD PTR [eax+12], 16	; 00000010H

; 802  : 	item->valuestring = (char*)output;

  00263	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00266	8b 55 ec	 mov	 edx, DWORD PTR _output$[ebp]
  00269	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 803  : 
; 804  : 	input_buffer->offset = (size_t)(input_end - input_buffer->content);

  0026c	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  0026f	8b 4d f4	 mov	 ecx, DWORD PTR _input_end$[ebp]
  00272	2b 08		 sub	 ecx, DWORD PTR [eax]
  00274	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  00277	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 805  : 	input_buffer->offset++;

  0027a	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  0027d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00280	83 c1 01	 add	 ecx, 1
  00283	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  00286	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 806  : 
; 807  : 	return true;

  00289	b8 01 00 00 00	 mov	 eax, 1
  0028e	eb 2b		 jmp	 SHORT $LN27@parse_stri
$fail$31:

; 808  : 
; 809  : fail:
; 810  : 	if (output != NULL)

  00290	83 7d ec 00	 cmp	 DWORD PTR _output$[ebp], 0
  00294	74 0f		 je	 SHORT $LN2@parse_stri

; 811  : 	{
; 812  : 		input_buffer->hooks.deallocate(output);

  00296	8b 45 ec	 mov	 eax, DWORD PTR _output$[ebp]
  00299	50		 push	 eax
  0029a	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  0029d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  002a0	ff d2		 call	 edx
  002a2	83 c4 04	 add	 esp, 4
$LN2@parse_stri:

; 813  : 	}
; 814  : 
; 815  : 	if (input_pointer != NULL)

  002a5	83 7d f0 00	 cmp	 DWORD PTR _input_pointer$[ebp], 0
  002a9	74 0e		 je	 SHORT $LN1@parse_stri

; 816  : 	{
; 817  : 		input_buffer->offset = (size_t)(input_pointer - input_buffer->content);

  002ab	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  002ae	8b 4d f0	 mov	 ecx, DWORD PTR _input_pointer$[ebp]
  002b1	2b 08		 sub	 ecx, DWORD PTR [eax]
  002b3	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  002b6	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN1@parse_stri:

; 818  : 	}
; 819  : 
; 820  : 	return false;

  002b9	33 c0		 xor	 eax, eax
$LN27@parse_stri:

; 821  : }

  002bb	8b e5		 mov	 esp, ebp
  002bd	5d		 pop	 ebp
  002be	c3		 ret	 0
  002bf	90		 npad	 1
$LN30@parse_stri:
  002c0	00 00 00 00	 DD	 $LN6@parse_stri
  002c4	00 00 00 00	 DD	 $LN11@parse_stri
  002c8	00 00 00 00	 DD	 $LN10@parse_stri
  002cc	00 00 00 00	 DD	 $LN9@parse_stri
  002d0	00 00 00 00	 DD	 $LN8@parse_stri
  002d4	00 00 00 00	 DD	 $LN7@parse_stri
  002d8	00 00 00 00	 DD	 $LN5@parse_stri
  002dc	00 00 00 00	 DD	 $LN3@parse_stri
$LN29@parse_stri:
  002e0	00		 DB	 0
  002e1	07		 DB	 7
  002e2	07		 DB	 7
  002e3	07		 DB	 7
  002e4	07		 DB	 7
  002e5	07		 DB	 7
  002e6	07		 DB	 7
  002e7	07		 DB	 7
  002e8	07		 DB	 7
  002e9	07		 DB	 7
  002ea	07		 DB	 7
  002eb	07		 DB	 7
  002ec	07		 DB	 7
  002ed	00		 DB	 0
  002ee	07		 DB	 7
  002ef	07		 DB	 7
  002f0	07		 DB	 7
  002f1	07		 DB	 7
  002f2	07		 DB	 7
  002f3	07		 DB	 7
  002f4	07		 DB	 7
  002f5	07		 DB	 7
  002f6	07		 DB	 7
  002f7	07		 DB	 7
  002f8	07		 DB	 7
  002f9	07		 DB	 7
  002fa	07		 DB	 7
  002fb	07		 DB	 7
  002fc	07		 DB	 7
  002fd	07		 DB	 7
  002fe	07		 DB	 7
  002ff	07		 DB	 7
  00300	07		 DB	 7
  00301	07		 DB	 7
  00302	07		 DB	 7
  00303	07		 DB	 7
  00304	07		 DB	 7
  00305	07		 DB	 7
  00306	07		 DB	 7
  00307	07		 DB	 7
  00308	07		 DB	 7
  00309	07		 DB	 7
  0030a	07		 DB	 7
  0030b	07		 DB	 7
  0030c	07		 DB	 7
  0030d	07		 DB	 7
  0030e	07		 DB	 7
  0030f	07		 DB	 7
  00310	07		 DB	 7
  00311	07		 DB	 7
  00312	07		 DB	 7
  00313	07		 DB	 7
  00314	07		 DB	 7
  00315	07		 DB	 7
  00316	07		 DB	 7
  00317	07		 DB	 7
  00318	07		 DB	 7
  00319	07		 DB	 7
  0031a	00		 DB	 0
  0031b	07		 DB	 7
  0031c	07		 DB	 7
  0031d	07		 DB	 7
  0031e	07		 DB	 7
  0031f	07		 DB	 7
  00320	01		 DB	 1
  00321	07		 DB	 7
  00322	07		 DB	 7
  00323	07		 DB	 7
  00324	02		 DB	 2
  00325	07		 DB	 7
  00326	07		 DB	 7
  00327	07		 DB	 7
  00328	07		 DB	 7
  00329	07		 DB	 7
  0032a	07		 DB	 7
  0032b	07		 DB	 7
  0032c	03		 DB	 3
  0032d	07		 DB	 7
  0032e	07		 DB	 7
  0032f	07		 DB	 7
  00330	04		 DB	 4
  00331	07		 DB	 7
  00332	05		 DB	 5
  00333	06		 DB	 6
_parse_string ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _utf16_literal_to_utf8
_TEXT	SEGMENT
_first_sequence$ = -24					; size = 4
_second_code$1 = -20					; size = 4
_second_sequence$2 = -16				; size = 4
_first_code$ = -12					; size = 4
_codepoint$ = -8					; size = 4
_sequence_length$ = -4					; size = 1
_first_byte_mark$ = -3					; size = 1
_utf8_position$ = -2					; size = 1
_utf8_length$ = -1					; size = 1
_input_pointer$ = 8					; size = 4
_input_end$ = 12					; size = 4
_output_pointer$ = 16					; size = 4
_utf16_literal_to_utf8 PROC				; COMDAT

; 575  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 576  : 	long unsigned int codepoint = 0;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _codepoint$[ebp], 0

; 577  : 	unsigned int first_code = 0;

  0000d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _first_code$[ebp], 0

; 578  : 	const unsigned char *first_sequence = input_pointer;

  00014	8b 45 08	 mov	 eax, DWORD PTR _input_pointer$[ebp]
  00017	89 45 e8	 mov	 DWORD PTR _first_sequence$[ebp], eax

; 579  : 	unsigned char utf8_length = 0;

  0001a	c6 45 ff 00	 mov	 BYTE PTR _utf8_length$[ebp], 0

; 580  : 	unsigned char utf8_position = 0;

  0001e	c6 45 fe 00	 mov	 BYTE PTR _utf8_position$[ebp], 0

; 581  : 	unsigned char sequence_length = 0;

  00022	c6 45 fc 00	 mov	 BYTE PTR _sequence_length$[ebp], 0

; 582  : 	unsigned char first_byte_mark = 0;

  00026	c6 45 fd 00	 mov	 BYTE PTR _first_byte_mark$[ebp], 0

; 583  : 
; 584  : 	if ((input_end - first_sequence) < 6)

  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _input_end$[ebp]
  0002d	2b 4d e8	 sub	 ecx, DWORD PTR _first_sequence$[ebp]
  00030	83 f9 06	 cmp	 ecx, 6
  00033	7d 05		 jge	 SHORT $LN22@utf16_lite

; 585  : 	{
; 586  : 		/* input ends unexpectedly */
; 587  : 		goto fail;

  00035	e9 c9 01 00 00	 jmp	 $fail$25
$LN22@utf16_lite:

; 588  : 	}
; 589  : 
; 590  : 	/* get the first utf16 sequence */
; 591  : 	first_code = parse_hex4(first_sequence + 2);

  0003a	8b 55 e8	 mov	 edx, DWORD PTR _first_sequence$[ebp]
  0003d	83 c2 02	 add	 edx, 2
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 _parse_hex4
  00046	83 c4 04	 add	 esp, 4
  00049	89 45 f4	 mov	 DWORD PTR _first_code$[ebp], eax

; 592  : 
; 593  : 	/* check that the code is valid */
; 594  : 	if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)))

  0004c	81 7d f4 00 dc
	00 00		 cmp	 DWORD PTR _first_code$[ebp], 56320 ; 0000dc00H
  00053	72 0e		 jb	 SHORT $LN21@utf16_lite
  00055	81 7d f4 ff df
	00 00		 cmp	 DWORD PTR _first_code$[ebp], 57343 ; 0000dfffH
  0005c	77 05		 ja	 SHORT $LN21@utf16_lite

; 595  : 	{
; 596  : 		goto fail;

  0005e	e9 a0 01 00 00	 jmp	 $fail$25
$LN21@utf16_lite:

; 597  : 	}
; 598  : 
; 599  : 	/* UTF16 surrogate pair */
; 600  : 	if ((first_code >= 0xD800) && (first_code <= 0xDBFF))

  00063	81 7d f4 00 d8
	00 00		 cmp	 DWORD PTR _first_code$[ebp], 55296 ; 0000d800H
  0006a	0f 82 a9 00 00
	00		 jb	 $LN20@utf16_lite
  00070	81 7d f4 ff db
	00 00		 cmp	 DWORD PTR _first_code$[ebp], 56319 ; 0000dbffH
  00077	0f 87 9c 00 00
	00		 ja	 $LN20@utf16_lite

; 601  : 	{
; 602  : 		const unsigned char *second_sequence = first_sequence + 6;

  0007d	8b 45 e8	 mov	 eax, DWORD PTR _first_sequence$[ebp]
  00080	83 c0 06	 add	 eax, 6
  00083	89 45 f0	 mov	 DWORD PTR _second_sequence$2[ebp], eax

; 603  : 		unsigned int second_code = 0;

  00086	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _second_code$1[ebp], 0

; 604  : 		sequence_length = 12; /* \uXXXX\uXXXX */

  0008d	c6 45 fc 0c	 mov	 BYTE PTR _sequence_length$[ebp], 12 ; 0000000cH

; 605  : 
; 606  : 		if ((input_end - second_sequence) < 6)

  00091	8b 4d 0c	 mov	 ecx, DWORD PTR _input_end$[ebp]
  00094	2b 4d f0	 sub	 ecx, DWORD PTR _second_sequence$2[ebp]
  00097	83 f9 06	 cmp	 ecx, 6
  0009a	7d 05		 jge	 SHORT $LN19@utf16_lite

; 607  : 		{
; 608  : 			/* input ends unexpectedly */
; 609  : 			goto fail;

  0009c	e9 62 01 00 00	 jmp	 $fail$25
$LN19@utf16_lite:

; 610  : 		}
; 611  : 
; 612  : 		if ((second_sequence[0] != '\\') || (second_sequence[1] != 'u'))

  000a1	ba 01 00 00 00	 mov	 edx, 1
  000a6	6b c2 00	 imul	 eax, edx, 0
  000a9	8b 4d f0	 mov	 ecx, DWORD PTR _second_sequence$2[ebp]
  000ac	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000b0	83 fa 5c	 cmp	 edx, 92			; 0000005cH
  000b3	75 14		 jne	 SHORT $LN17@utf16_lite
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	c1 e0 00	 shl	 eax, 0
  000bd	8b 4d f0	 mov	 ecx, DWORD PTR _second_sequence$2[ebp]
  000c0	0f b6 14 01	 movzx	 edx, BYTE PTR [ecx+eax]
  000c4	83 fa 75	 cmp	 edx, 117		; 00000075H
  000c7	74 05		 je	 SHORT $LN18@utf16_lite
$LN17@utf16_lite:

; 613  : 		{
; 614  : 			/* missing second half of the surrogate pair */
; 615  : 			goto fail;

  000c9	e9 35 01 00 00	 jmp	 $fail$25
$LN18@utf16_lite:

; 616  : 		}
; 617  : 
; 618  : 		/* get the second utf16 sequence */
; 619  : 		second_code = parse_hex4(second_sequence + 2);

  000ce	8b 45 f0	 mov	 eax, DWORD PTR _second_sequence$2[ebp]
  000d1	83 c0 02	 add	 eax, 2
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 _parse_hex4
  000da	83 c4 04	 add	 esp, 4
  000dd	89 45 ec	 mov	 DWORD PTR _second_code$1[ebp], eax

; 620  : 		/* check that the code is valid */
; 621  : 		if ((second_code < 0xDC00) || (second_code > 0xDFFF))

  000e0	81 7d ec 00 dc
	00 00		 cmp	 DWORD PTR _second_code$1[ebp], 56320 ; 0000dc00H
  000e7	72 09		 jb	 SHORT $LN15@utf16_lite
  000e9	81 7d ec ff df
	00 00		 cmp	 DWORD PTR _second_code$1[ebp], 57343 ; 0000dfffH
  000f0	76 05		 jbe	 SHORT $LN16@utf16_lite
$LN15@utf16_lite:

; 622  : 		{
; 623  : 			/* invalid second half of the surrogate pair */
; 624  : 			goto fail;

  000f2	e9 0c 01 00 00	 jmp	 $fail$25
$LN16@utf16_lite:

; 625  : 		}
; 626  : 
; 627  : 
; 628  : 		/* calculate the unicode codepoint from the surrogate pair */
; 629  : 		codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));

  000f7	8b 4d f4	 mov	 ecx, DWORD PTR _first_code$[ebp]
  000fa	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  00100	c1 e1 0a	 shl	 ecx, 10			; 0000000aH
  00103	8b 55 ec	 mov	 edx, DWORD PTR _second_code$1[ebp]
  00106	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  0010c	0b ca		 or	 ecx, edx
  0010e	81 c1 00 00 01
	00		 add	 ecx, 65536		; 00010000H
  00114	89 4d f8	 mov	 DWORD PTR _codepoint$[ebp], ecx

; 630  : 	}
; 631  : 	else

  00117	eb 0a		 jmp	 SHORT $LN14@utf16_lite
$LN20@utf16_lite:

; 632  : 	{
; 633  : 		sequence_length = 6; /* \uXXXX */

  00119	c6 45 fc 06	 mov	 BYTE PTR _sequence_length$[ebp], 6

; 634  : 		codepoint = first_code;

  0011d	8b 45 f4	 mov	 eax, DWORD PTR _first_code$[ebp]
  00120	89 45 f8	 mov	 DWORD PTR _codepoint$[ebp], eax
$LN14@utf16_lite:

; 635  : 	}
; 636  : 
; 637  : 	/* encode as UTF-8
; 638  : 	* takes at maximum 4 bytes to encode:
; 639  : 	* 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
; 640  : 	if (codepoint < 0x80)

  00123	81 7d f8 80 00
	00 00		 cmp	 DWORD PTR _codepoint$[ebp], 128 ; 00000080H
  0012a	73 06		 jae	 SHORT $LN13@utf16_lite

; 641  : 	{
; 642  : 		/* normal ascii, encoding 0xxxxxxx */
; 643  : 		utf8_length = 1;

  0012c	c6 45 ff 01	 mov	 BYTE PTR _utf8_length$[ebp], 1
  00130	eb 3e		 jmp	 SHORT $LN12@utf16_lite
$LN13@utf16_lite:

; 644  : 	}
; 645  : 	else if (codepoint < 0x800)

  00132	81 7d f8 00 08
	00 00		 cmp	 DWORD PTR _codepoint$[ebp], 2048 ; 00000800H
  00139	73 0a		 jae	 SHORT $LN11@utf16_lite

; 646  : 	{
; 647  : 		/* two bytes, encoding 110xxxxx 10xxxxxx */
; 648  : 		utf8_length = 2;

  0013b	c6 45 ff 02	 mov	 BYTE PTR _utf8_length$[ebp], 2

; 649  : 		first_byte_mark = 0xC0; /* 11000000 */

  0013f	c6 45 fd c0	 mov	 BYTE PTR _first_byte_mark$[ebp], 192 ; 000000c0H
  00143	eb 2b		 jmp	 SHORT $LN12@utf16_lite
$LN11@utf16_lite:

; 650  : 	}
; 651  : 	else if (codepoint < 0x10000)

  00145	81 7d f8 00 00
	01 00		 cmp	 DWORD PTR _codepoint$[ebp], 65536 ; 00010000H
  0014c	73 0a		 jae	 SHORT $LN9@utf16_lite

; 652  : 	{
; 653  : 		/* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */
; 654  : 		utf8_length = 3;

  0014e	c6 45 ff 03	 mov	 BYTE PTR _utf8_length$[ebp], 3

; 655  : 		first_byte_mark = 0xE0; /* 11100000 */

  00152	c6 45 fd e0	 mov	 BYTE PTR _first_byte_mark$[ebp], 224 ; 000000e0H
  00156	eb 18		 jmp	 SHORT $LN12@utf16_lite
$LN9@utf16_lite:

; 656  : 	}
; 657  : 	else if (codepoint <= 0x10FFFF)

  00158	81 7d f8 ff ff
	10 00		 cmp	 DWORD PTR _codepoint$[ebp], 1114111 ; 0010ffffH
  0015f	77 0a		 ja	 SHORT $LN7@utf16_lite

; 658  : 	{
; 659  : 		/* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */
; 660  : 		utf8_length = 4;

  00161	c6 45 ff 04	 mov	 BYTE PTR _utf8_length$[ebp], 4

; 661  : 		first_byte_mark = 0xF0; /* 11110000 */

  00165	c6 45 fd f0	 mov	 BYTE PTR _first_byte_mark$[ebp], 240 ; 000000f0H

; 662  : 	}
; 663  : 	else

  00169	eb 05		 jmp	 SHORT $LN12@utf16_lite
$LN7@utf16_lite:

; 664  : 	{
; 665  : 		/* invalid unicode codepoint */
; 666  : 		goto fail;

  0016b	e9 93 00 00 00	 jmp	 $fail$25
$LN12@utf16_lite:

; 667  : 	}
; 668  : 
; 669  : 	/* encode as utf8 */
; 670  : 	for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)

  00170	0f b6 4d ff	 movzx	 ecx, BYTE PTR _utf8_length$[ebp]
  00174	83 e9 01	 sub	 ecx, 1
  00177	88 4d fe	 mov	 BYTE PTR _utf8_position$[ebp], cl
  0017a	eb 09		 jmp	 SHORT $LN5@utf16_lite
$LN4@utf16_lite:
  0017c	8a 55 fe	 mov	 dl, BYTE PTR _utf8_position$[ebp]
  0017f	80 ea 01	 sub	 dl, 1
  00182	88 55 fe	 mov	 BYTE PTR _utf8_position$[ebp], dl
$LN5@utf16_lite:
  00185	0f b6 45 fe	 movzx	 eax, BYTE PTR _utf8_position$[ebp]
  00189	85 c0		 test	 eax, eax
  0018b	7e 26		 jle	 SHORT $LN3@utf16_lite

; 671  : 	{
; 672  : 		/* 10xxxxxx */
; 673  : 		(*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);

  0018d	8b 4d f8	 mov	 ecx, DWORD PTR _codepoint$[ebp]
  00190	81 c9 80 00 00
	00		 or	 ecx, 128		; 00000080H
  00196	81 e1 bf 00 00
	00		 and	 ecx, 191		; 000000bfH
  0019c	0f b6 55 fe	 movzx	 edx, BYTE PTR _utf8_position$[ebp]
  001a0	8b 45 10	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  001a3	8b 00		 mov	 eax, DWORD PTR [eax]
  001a5	88 0c 10	 mov	 BYTE PTR [eax+edx], cl

; 674  : 		codepoint >>= 6;

  001a8	8b 4d f8	 mov	 ecx, DWORD PTR _codepoint$[ebp]
  001ab	c1 e9 06	 shr	 ecx, 6
  001ae	89 4d f8	 mov	 DWORD PTR _codepoint$[ebp], ecx

; 675  : 	}

  001b1	eb c9		 jmp	 SHORT $LN4@utf16_lite
$LN3@utf16_lite:

; 676  : 	/* encode first byte */
; 677  : 	if (utf8_length > 1)

  001b3	0f b6 55 ff	 movzx	 edx, BYTE PTR _utf8_length$[ebp]
  001b7	83 fa 01	 cmp	 edx, 1
  001ba	7e 1e		 jle	 SHORT $LN2@utf16_lite

; 678  : 	{
; 679  : 		(*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);

  001bc	0f b6 45 fd	 movzx	 eax, BYTE PTR _first_byte_mark$[ebp]
  001c0	0b 45 f8	 or	 eax, DWORD PTR _codepoint$[ebp]
  001c3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001c8	b9 01 00 00 00	 mov	 ecx, 1
  001cd	6b d1 00	 imul	 edx, ecx, 0
  001d0	8b 4d 10	 mov	 ecx, DWORD PTR _output_pointer$[ebp]
  001d3	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001d5	88 04 0a	 mov	 BYTE PTR [edx+ecx], al

; 680  : 	}
; 681  : 	else

  001d8	eb 16		 jmp	 SHORT $LN1@utf16_lite
$LN2@utf16_lite:

; 682  : 	{
; 683  : 		(*output_pointer)[0] = (unsigned char)(codepoint & 0x7F);

  001da	8b 55 f8	 mov	 edx, DWORD PTR _codepoint$[ebp]
  001dd	83 e2 7f	 and	 edx, 127		; 0000007fH
  001e0	b8 01 00 00 00	 mov	 eax, 1
  001e5	6b c8 00	 imul	 ecx, eax, 0
  001e8	8b 45 10	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  001eb	8b 00		 mov	 eax, DWORD PTR [eax]
  001ed	88 14 01	 mov	 BYTE PTR [ecx+eax], dl
$LN1@utf16_lite:

; 684  : 	}
; 685  : 
; 686  : 	*output_pointer += utf8_length;

  001f0	0f b6 4d ff	 movzx	 ecx, BYTE PTR _utf8_length$[ebp]
  001f4	8b 55 10	 mov	 edx, DWORD PTR _output_pointer$[ebp]
  001f7	03 0a		 add	 ecx, DWORD PTR [edx]
  001f9	8b 45 10	 mov	 eax, DWORD PTR _output_pointer$[ebp]
  001fc	89 08		 mov	 DWORD PTR [eax], ecx

; 687  : 
; 688  : 	return sequence_length;

  001fe	8a 45 fc	 mov	 al, BYTE PTR _sequence_length$[ebp]
  00201	eb 02		 jmp	 SHORT $LN23@utf16_lite
$fail$25:

; 689  : 
; 690  : fail:
; 691  : 	return 0;

  00203	32 c0		 xor	 al, al
$LN23@utf16_lite:

; 692  : }

  00205	8b e5		 mov	 esp, ebp
  00207	5d		 pop	 ebp
  00208	c3		 ret	 0
_utf16_literal_to_utf8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _parse_hex4
_TEXT	SEGMENT
_h$ = -8						; size = 4
_i$ = -4						; size = 4
_input$ = 8						; size = 4
_parse_hex4 PROC					; COMDAT

; 538  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 539  : 	unsigned int h = 0;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _h$[ebp], 0

; 540  : 	size_t i = 0;

  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 541  : 
; 542  : 	for (i = 0; i < 4; i++)

  00014	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0001b	eb 09		 jmp	 SHORT $LN10@parse_hex4
$LN9@parse_hex4:
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00020	83 c0 01	 add	 eax, 1
  00023	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN10@parse_hex4:
  00026	83 7d fc 04	 cmp	 DWORD PTR _i$[ebp], 4
  0002a	0f 83 ab 00 00
	00		 jae	 $LN8@parse_hex4

; 543  : 	{
; 544  : 		/* parse digit */
; 545  : 		if ((input[i] >= '0') && (input[i] <= '9'))

  00030	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00033	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00036	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00039	83 fa 30	 cmp	 edx, 48			; 00000030H
  0003c	7c 23		 jl	 SHORT $LN7@parse_hex4
  0003e	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00041	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00044	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00047	83 f9 39	 cmp	 ecx, 57			; 00000039H
  0004a	7f 15		 jg	 SHORT $LN7@parse_hex4

; 546  : 		{
; 547  : 			h += (unsigned int)input[i] - '0';

  0004c	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  0004f	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00052	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00055	8b 4d f8	 mov	 ecx, DWORD PTR _h$[ebp]
  00058	8d 54 01 d0	 lea	 edx, DWORD PTR [ecx+eax-48]
  0005c	89 55 f8	 mov	 DWORD PTR _h$[ebp], edx
  0005f	eb 66		 jmp	 SHORT $LN6@parse_hex4
$LN7@parse_hex4:

; 548  : 		}
; 549  : 		else if ((input[i] >= 'A') && (input[i] <= 'F'))

  00061	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  00064	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00067	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0006a	83 f9 41	 cmp	 ecx, 65			; 00000041H
  0006d	7c 23		 jl	 SHORT $LN5@parse_hex4
  0006f	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00072	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00075	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00078	83 f8 46	 cmp	 eax, 70			; 00000046H
  0007b	7f 15		 jg	 SHORT $LN5@parse_hex4

; 550  : 		{
; 551  : 			h += (unsigned int)10 + input[i] - 'A';

  0007d	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  00080	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00083	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00086	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
  00089	8d 4c 10 c9	 lea	 ecx, DWORD PTR [eax+edx-55]
  0008d	89 4d f8	 mov	 DWORD PTR _h$[ebp], ecx
  00090	eb 35		 jmp	 SHORT $LN6@parse_hex4
$LN5@parse_hex4:

; 552  : 		}
; 553  : 		else if ((input[i] >= 'a') && (input[i] <= 'f'))

  00092	8b 55 08	 mov	 edx, DWORD PTR _input$[ebp]
  00095	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00098	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0009b	83 f8 61	 cmp	 eax, 97			; 00000061H
  0009e	7c 23		 jl	 SHORT $LN3@parse_hex4
  000a0	8b 4d 08	 mov	 ecx, DWORD PTR _input$[ebp]
  000a3	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  000a6	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  000a9	83 fa 66	 cmp	 edx, 102		; 00000066H
  000ac	7f 15		 jg	 SHORT $LN3@parse_hex4

; 554  : 		{
; 555  : 			h += (unsigned int)10 + input[i] - 'a';

  000ae	8b 45 08	 mov	 eax, DWORD PTR _input$[ebp]
  000b1	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  000b4	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000b7	8b 55 f8	 mov	 edx, DWORD PTR _h$[ebp]
  000ba	8d 44 0a a9	 lea	 eax, DWORD PTR [edx+ecx-87]
  000be	89 45 f8	 mov	 DWORD PTR _h$[ebp], eax

; 556  : 		}
; 557  : 		else /* invalid */

  000c1	eb 04		 jmp	 SHORT $LN6@parse_hex4
$LN3@parse_hex4:

; 558  : 		{
; 559  : 			return 0;

  000c3	33 c0		 xor	 eax, eax
  000c5	eb 17		 jmp	 SHORT $LN11@parse_hex4
$LN6@parse_hex4:

; 560  : 		}
; 561  : 
; 562  : 		if (i < 3)

  000c7	83 7d fc 03	 cmp	 DWORD PTR _i$[ebp], 3
  000cb	73 09		 jae	 SHORT $LN1@parse_hex4

; 563  : 		{
; 564  : 			/* shift left to make place for the next nibble */
; 565  : 			h = h << 4;

  000cd	8b 4d f8	 mov	 ecx, DWORD PTR _h$[ebp]
  000d0	c1 e1 04	 shl	 ecx, 4
  000d3	89 4d f8	 mov	 DWORD PTR _h$[ebp], ecx
$LN1@parse_hex4:

; 566  : 		}
; 567  : 	}

  000d6	e9 42 ff ff ff	 jmp	 $LN9@parse_hex4
$LN8@parse_hex4:

; 568  : 
; 569  : 	return h;

  000db	8b 45 f8	 mov	 eax, DWORD PTR _h$[ebp]
$LN11@parse_hex4:

; 570  : }

  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c3		 ret	 0
_parse_hex4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _print_number
_TEXT	SEGMENT
_number_buffer$ = -60					; size = 26
_test$ = -32						; size = 8
_d$ = -24						; size = 8
_output_pointer$ = -16					; size = 4
_length$ = -12						; size = 4
_i$ = -8						; size = 4
_decimal_point$ = -1					; size = 1
_item$ = 8						; size = 4
_output_buffer$ = 12					; size = 4
_print_number PROC					; COMDAT

; 472  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 473  : 	unsigned char *output_pointer = NULL;

  00006	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _output_pointer$[ebp], 0

; 474  : 	double d = item->valuedouble;

  0000d	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00010	dd 40 18	 fld	 QWORD PTR [eax+24]
  00013	dd 5d e8	 fstp	 QWORD PTR _d$[ebp]

; 475  : 	int length = 0;

  00016	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _length$[ebp], 0

; 476  : 	size_t i = 0;

  0001d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 477  : 	unsigned char number_buffer[26]; /* temporary buffer to print the number into */
; 478  : 	unsigned char decimal_point = get_decimal_point();

  00024	e8 00 00 00 00	 call	 _get_decimal_point
  00029	88 45 ff	 mov	 BYTE PTR _decimal_point$[ebp], al

; 479  : 	double test;
; 480  : 
; 481  : 	if (output_buffer == NULL)

  0002c	83 7d 0c 00	 cmp	 DWORD PTR _output_buffer$[ebp], 0
  00030	75 07		 jne	 SHORT $LN12@print_numb

; 482  : 	{
; 483  : 		return false;

  00032	33 c0		 xor	 eax, eax
  00034	e9 23 01 00 00	 jmp	 $LN13@print_numb
$LN12@print_numb:

; 484  : 	}
; 485  : 
; 486  : 	/* This checks for NaN and Infinity */
; 487  : 	if ((d * 0) != 0)

  00039	dd 45 e8	 fld	 QWORD PTR _d$[ebp]
  0003c	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@0000000000000000
  00042	d9 ee		 fldz
  00044	da e9		 fucompp
  00046	df e0		 fnstsw	 ax
  00048	f6 c4 44	 test	 ah, 68			; 00000044H
  0004b	7b 16		 jnp	 SHORT $LN11@print_numb

; 488  : 	{
; 489  : 		length = sprintf((char*)number_buffer, "null");

  0004d	68 00 00 00 00	 push	 OFFSET $SG2513
  00052	8d 4d c4	 lea	 ecx, DWORD PTR _number_buffer$[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 __hx_sprintf
  0005b	83 c4 08	 add	 esp, 8
  0005e	89 45 f4	 mov	 DWORD PTR _length$[ebp], eax

; 490  : 	}
; 491  : 	else

  00061	eb 63		 jmp	 SHORT $LN9@print_numb
$LN11@print_numb:

; 492  : 	{
; 493  : 		/* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */
; 494  : 		length = sprintf((char*)number_buffer, "%1.15g", d);

  00063	83 ec 08	 sub	 esp, 8
  00066	dd 45 e8	 fld	 QWORD PTR _d$[ebp]
  00069	dd 1c 24	 fstp	 QWORD PTR [esp]
  0006c	68 00 00 00 00	 push	 OFFSET $SG2516
  00071	8d 55 c4	 lea	 edx, DWORD PTR _number_buffer$[ebp]
  00074	52		 push	 edx
  00075	e8 00 00 00 00	 call	 __hx_sprintf
  0007a	83 c4 10	 add	 esp, 16			; 00000010H
  0007d	89 45 f4	 mov	 DWORD PTR _length$[ebp], eax

; 495  : 
; 496  : 		/* Check whether the original double can be recovered */
; 497  : 		if ((sscanf((char*)number_buffer, "%lg", &test) != 1) || ((double)test != d))

  00080	8d 45 e0	 lea	 eax, DWORD PTR _test$[ebp]
  00083	50		 push	 eax
  00084	68 00 00 00 00	 push	 OFFSET $SG2522
  00089	8d 4d c4	 lea	 ecx, DWORD PTR _number_buffer$[ebp]
  0008c	51		 push	 ecx
  0008d	e8 00 00 00 00	 call	 _sscanf
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH
  00095	83 f8 01	 cmp	 eax, 1
  00098	75 0f		 jne	 SHORT $LN8@print_numb
  0009a	dd 45 e0	 fld	 QWORD PTR _test$[ebp]
  0009d	dd 45 e8	 fld	 QWORD PTR _d$[ebp]
  000a0	da e9		 fucompp
  000a2	df e0		 fnstsw	 ax
  000a4	f6 c4 44	 test	 ah, 68			; 00000044H
  000a7	7b 1d		 jnp	 SHORT $LN9@print_numb
$LN8@print_numb:

; 498  : 		{
; 499  : 			/* If not, print with 17 decimal places of precision */
; 500  : 			length = sprintf((char*)number_buffer, "%1.17g", d);

  000a9	83 ec 08	 sub	 esp, 8
  000ac	dd 45 e8	 fld	 QWORD PTR _d$[ebp]
  000af	dd 1c 24	 fstp	 QWORD PTR [esp]
  000b2	68 00 00 00 00	 push	 OFFSET $SG2524
  000b7	8d 55 c4	 lea	 edx, DWORD PTR _number_buffer$[ebp]
  000ba	52		 push	 edx
  000bb	e8 00 00 00 00	 call	 __hx_sprintf
  000c0	83 c4 10	 add	 esp, 16			; 00000010H
  000c3	89 45 f4	 mov	 DWORD PTR _length$[ebp], eax
$LN9@print_numb:

; 501  : 		}
; 502  : 	}
; 503  : 
; 504  : 	/* sprintf failed or buffer overrun occured */
; 505  : 	if ((length < 0) || (length >(int)(sizeof(number_buffer) - 1)))

  000c6	83 7d f4 00	 cmp	 DWORD PTR _length$[ebp], 0
  000ca	7c 06		 jl	 SHORT $LN6@print_numb
  000cc	83 7d f4 19	 cmp	 DWORD PTR _length$[ebp], 25 ; 00000019H
  000d0	7e 07		 jle	 SHORT $LN7@print_numb
$LN6@print_numb:

; 506  : 	{
; 507  : 		return false;

  000d2	33 c0		 xor	 eax, eax
  000d4	e9 83 00 00 00	 jmp	 $LN13@print_numb
$LN7@print_numb:

; 508  : 	}
; 509  : 
; 510  : 	/* reserve appropriate space in the output */
; 511  : 	output_pointer = ensure(output_buffer, (size_t)length + sizeof(""));

  000d9	8b 45 f4	 mov	 eax, DWORD PTR _length$[ebp]
  000dc	83 c0 01	 add	 eax, 1
  000df	50		 push	 eax
  000e0	8b 4d 0c	 mov	 ecx, DWORD PTR _output_buffer$[ebp]
  000e3	51		 push	 ecx
  000e4	e8 00 00 00 00	 call	 _ensure
  000e9	83 c4 08	 add	 esp, 8
  000ec	89 45 f0	 mov	 DWORD PTR _output_pointer$[ebp], eax

; 512  : 	if (output_pointer == NULL)

  000ef	83 7d f0 00	 cmp	 DWORD PTR _output_pointer$[ebp], 0
  000f3	75 04		 jne	 SHORT $LN5@print_numb

; 513  : 	{
; 514  : 		return false;

  000f5	33 c0		 xor	 eax, eax
  000f7	eb 63		 jmp	 SHORT $LN13@print_numb
$LN5@print_numb:

; 515  : 	}
; 516  : 
; 517  : 	/* copy the printed number to the output and replace locale
; 518  : 	* dependent decimal point with '.' */
; 519  : 	for (i = 0; i < ((size_t)length); i++)

  000f9	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00100	eb 09		 jmp	 SHORT $LN4@print_numb
$LN3@print_numb:
  00102	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00105	83 c2 01	 add	 edx, 1
  00108	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN4@print_numb:
  0010b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0010e	3b 45 f4	 cmp	 eax, DWORD PTR _length$[ebp]
  00111	73 2c		 jae	 SHORT $LN2@print_numb

; 520  : 	{
; 521  : 		if (number_buffer[i] == decimal_point)

  00113	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00116	0f b6 54 0d c4	 movzx	 edx, BYTE PTR _number_buffer$[ebp+ecx]
  0011b	0f b6 45 ff	 movzx	 eax, BYTE PTR _decimal_point$[ebp]
  0011f	3b d0		 cmp	 edx, eax
  00121	75 0b		 jne	 SHORT $LN1@print_numb

; 522  : 		{
; 523  : 			output_pointer[i] = '.';

  00123	8b 4d f0	 mov	 ecx, DWORD PTR _output_pointer$[ebp]
  00126	03 4d f8	 add	 ecx, DWORD PTR _i$[ebp]
  00129	c6 01 2e	 mov	 BYTE PTR [ecx], 46	; 0000002eH

; 524  : 			continue;

  0012c	eb d4		 jmp	 SHORT $LN3@print_numb
$LN1@print_numb:

; 525  : 		}
; 526  : 
; 527  : 		output_pointer[i] = number_buffer[i];

  0012e	8b 55 f0	 mov	 edx, DWORD PTR _output_pointer$[ebp]
  00131	03 55 f8	 add	 edx, DWORD PTR _i$[ebp]
  00134	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00137	8a 4c 05 c4	 mov	 cl, BYTE PTR _number_buffer$[ebp+eax]
  0013b	88 0a		 mov	 BYTE PTR [edx], cl

; 528  : 	}

  0013d	eb c3		 jmp	 SHORT $LN3@print_numb
$LN2@print_numb:

; 529  : 	output_pointer[i] = '\0';

  0013f	8b 55 f0	 mov	 edx, DWORD PTR _output_pointer$[ebp]
  00142	03 55 f8	 add	 edx, DWORD PTR _i$[ebp]
  00145	c6 02 00	 mov	 BYTE PTR [edx], 0

; 530  : 
; 531  : 	output_buffer->offset += (size_t)length;

  00148	8b 45 0c	 mov	 eax, DWORD PTR _output_buffer$[ebp]
  0014b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0014e	03 4d f4	 add	 ecx, DWORD PTR _length$[ebp]
  00151	8b 55 0c	 mov	 edx, DWORD PTR _output_buffer$[ebp]
  00154	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 532  : 
; 533  : 	return true;

  00157	b8 01 00 00 00	 mov	 eax, 1
$LN13@print_numb:

; 534  : }

  0015c	8b e5		 mov	 esp, ebp
  0015e	5d		 pop	 ebp
  0015f	c3		 ret	 0
_print_number ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _update_offset
_TEXT	SEGMENT
_buffer_pointer$ = -4					; size = 4
_buffer$ = 8						; size = 4
_update_offset PROC					; COMDAT

; 459  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 460  : 	const unsigned char *buffer_pointer = NULL;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _buffer_pointer$[ebp], 0

; 461  : 	if ((buffer == NULL) || (buffer->buffer == NULL))

  0000b	83 7d 08 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  0000f	74 08		 je	 SHORT $LN1@update_off
  00011	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00014	83 38 00	 cmp	 DWORD PTR [eax], 0
  00017	75 02		 jne	 SHORT $LN2@update_off
$LN1@update_off:

; 462  : 	{
; 463  : 		return;

  00019	eb 26		 jmp	 SHORT $LN3@update_off
$LN2@update_off:

; 464  : 	}
; 465  : 	buffer_pointer = buffer->buffer + buffer->offset;

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0001e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00020	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00023	03 50 08	 add	 edx, DWORD PTR [eax+8]
  00026	89 55 fc	 mov	 DWORD PTR _buffer_pointer$[ebp], edx

; 466  : 
; 467  : 	buffer->offset += strlen((const char*)buffer_pointer);

  00029	8b 4d fc	 mov	 ecx, DWORD PTR _buffer_pointer$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 _strlen
  00032	83 c4 04	 add	 esp, 4
  00035	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00038	03 42 08	 add	 eax, DWORD PTR [edx+8]
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  0003e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN3@update_off:

; 468  : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_update_offset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _ensure
_TEXT	SEGMENT
_newsize$ = -8						; size = 4
_newbuffer$ = -4					; size = 4
_p$ = 8							; size = 4
_needed$ = 12						; size = 4
_ensure	PROC						; COMDAT

; 371  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 372  : 	unsigned char *newbuffer = NULL;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _newbuffer$[ebp], 0

; 373  : 	size_t newsize = 0;

  0000d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _newsize$[ebp], 0

; 374  : 
; 375  : 	if ((p == NULL) || (p->buffer == NULL))

  00014	83 7d 08 00	 cmp	 DWORD PTR _p$[ebp], 0
  00018	74 08		 je	 SHORT $LN14@ensure
  0001a	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0001d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00020	75 07		 jne	 SHORT $LN15@ensure
$LN14@ensure:

; 376  : 	{
; 377  : 		return NULL;

  00022	33 c0		 xor	 eax, eax
  00024	e9 76 01 00 00	 jmp	 $LN16@ensure
$LN15@ensure:

; 378  : 	}
; 379  : 
; 380  : 	if ((p->length > 0) && (p->offset >= p->length))

  00029	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0002c	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00030	76 15		 jbe	 SHORT $LN13@ensure
  00032	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00035	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00038	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0003b	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0003e	72 07		 jb	 SHORT $LN13@ensure

; 381  : 	{
; 382  : 		/* make sure that offset is valid */
; 383  : 		return NULL;

  00040	33 c0		 xor	 eax, eax
  00042	e9 58 01 00 00	 jmp	 $LN16@ensure
$LN13@ensure:

; 384  : 	}
; 385  : 
; 386  : 	if (needed > INT_MAX)

  00047	81 7d 0c ff ff
	ff 7f		 cmp	 DWORD PTR _needed$[ebp], 2147483647 ; 7fffffffH
  0004e	76 07		 jbe	 SHORT $LN12@ensure

; 387  : 	{
; 388  : 		/* sizes bigger than INT_MAX are currently not supported */
; 389  : 		return NULL;

  00050	33 c0		 xor	 eax, eax
  00052	e9 48 01 00 00	 jmp	 $LN16@ensure
$LN12@ensure:

; 390  : 	}
; 391  : 
; 392  : 	needed += p->offset + 1;

  00057	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  0005a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0005d	8b 4d 0c	 mov	 ecx, DWORD PTR _needed$[ebp]
  00060	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00064	89 55 0c	 mov	 DWORD PTR _needed$[ebp], edx

; 393  : 	if (needed <= p->length)

  00067	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _needed$[ebp]
  0006d	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00070	77 10		 ja	 SHORT $LN11@ensure

; 394  : 	{
; 395  : 		return p->buffer + p->offset;

  00072	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00075	8b 02		 mov	 eax, DWORD PTR [edx]
  00077	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0007a	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  0007d	e9 1d 01 00 00	 jmp	 $LN16@ensure
$LN11@ensure:

; 396  : 	}
; 397  : 
; 398  : 	if (p->noalloc) {

  00082	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00085	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  00089	74 07		 je	 SHORT $LN10@ensure

; 399  : 		return NULL;

  0008b	33 c0		 xor	 eax, eax
  0008d	e9 0d 01 00 00	 jmp	 $LN16@ensure
$LN10@ensure:

; 400  : 	}
; 401  : 
; 402  : 	/* calculate new buffer size */
; 403  : 	if (needed > (INT_MAX / 2))

  00092	81 7d 0c ff ff
	ff 3f		 cmp	 DWORD PTR _needed$[ebp], 1073741823 ; 3fffffffH
  00099	76 1b		 jbe	 SHORT $LN9@ensure

; 404  : 	{
; 405  : 		/* overflow of int, use INT_MAX if possible */
; 406  : 		if (needed <= INT_MAX)

  0009b	81 7d 0c ff ff
	ff 7f		 cmp	 DWORD PTR _needed$[ebp], 2147483647 ; 7fffffffH
  000a2	77 09		 ja	 SHORT $LN8@ensure

; 407  : 		{
; 408  : 			newsize = INT_MAX;

  000a4	c7 45 f8 ff ff
	ff 7f		 mov	 DWORD PTR _newsize$[ebp], 2147483647 ; 7fffffffH

; 409  : 		}
; 410  : 		else

  000ab	eb 07		 jmp	 SHORT $LN7@ensure
$LN8@ensure:

; 411  : 		{
; 412  : 			return NULL;

  000ad	33 c0		 xor	 eax, eax
  000af	e9 eb 00 00 00	 jmp	 $LN16@ensure
$LN7@ensure:

; 413  : 		}
; 414  : 	}
; 415  : 	else

  000b4	eb 08		 jmp	 SHORT $LN6@ensure
$LN9@ensure:

; 416  : 	{
; 417  : 		newsize = needed * 2;

  000b6	8b 45 0c	 mov	 eax, DWORD PTR _needed$[ebp]
  000b9	d1 e0		 shl	 eax, 1
  000bb	89 45 f8	 mov	 DWORD PTR _newsize$[ebp], eax
$LN6@ensure:

; 418  : 	}
; 419  : 
; 420  : 	if (p->hooks.reallocate != NULL)

  000be	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  000c1	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  000c5	74 4b		 je	 SHORT $LN5@ensure

; 421  : 	{
; 422  : 		/* reallocate with realloc if available */
; 423  : 		newbuffer = (unsigned char*)p->hooks.reallocate(p->buffer, newsize);

  000c7	8b 55 f8	 mov	 edx, DWORD PTR _newsize$[ebp]
  000ca	52		 push	 edx
  000cb	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000ce	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d0	51		 push	 ecx
  000d1	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  000d4	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  000d7	ff d0		 call	 eax
  000d9	83 c4 08	 add	 esp, 8
  000dc	89 45 fc	 mov	 DWORD PTR _newbuffer$[ebp], eax

; 424  : 		if (newbuffer == NULL)

  000df	83 7d fc 00	 cmp	 DWORD PTR _newbuffer$[ebp], 0
  000e3	75 2b		 jne	 SHORT $LN4@ensure

; 425  : 		{
; 426  : 			p->hooks.deallocate(p->buffer);

  000e5	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  000e8	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ea	52		 push	 edx
  000eb	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  000ee	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000f1	ff d1		 call	 ecx
  000f3	83 c4 04	 add	 esp, 4

; 427  : 			p->length = 0;

  000f6	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  000f9	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 428  : 			p->buffer = NULL;

  00100	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00103	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 429  : 
; 430  : 			return NULL;

  00109	33 c0		 xor	 eax, eax
  0010b	e9 8f 00 00 00	 jmp	 $LN16@ensure
$LN4@ensure:

; 431  : 		}
; 432  : 	}
; 433  : 	else

  00110	eb 73		 jmp	 SHORT $LN3@ensure
$LN5@ensure:

; 434  : 	{
; 435  : 		/* otherwise reallocate manually */
; 436  : 		newbuffer = (unsigned char*)p->hooks.allocate(newsize);

  00112	8b 4d f8	 mov	 ecx, DWORD PTR _newsize$[ebp]
  00115	51		 push	 ecx
  00116	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00119	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0011c	ff d0		 call	 eax
  0011e	83 c4 04	 add	 esp, 4
  00121	89 45 fc	 mov	 DWORD PTR _newbuffer$[ebp], eax

; 437  : 		if (!newbuffer)

  00124	83 7d fc 00	 cmp	 DWORD PTR _newbuffer$[ebp], 0
  00128	75 28		 jne	 SHORT $LN2@ensure

; 438  : 		{
; 439  : 			p->hooks.deallocate(p->buffer);

  0012a	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0012d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0012f	52		 push	 edx
  00130	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00133	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00136	ff d1		 call	 ecx
  00138	83 c4 04	 add	 esp, 4

; 440  : 			p->length = 0;

  0013b	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  0013e	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 441  : 			p->buffer = NULL;

  00145	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00148	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 442  : 
; 443  : 			return NULL;

  0014e	33 c0		 xor	 eax, eax
  00150	eb 4d		 jmp	 SHORT $LN16@ensure
$LN2@ensure:

; 444  : 		}
; 445  : 		if (newbuffer)

  00152	83 7d fc 00	 cmp	 DWORD PTR _newbuffer$[ebp], 0
  00156	74 1c		 je	 SHORT $LN1@ensure

; 446  : 		{
; 447  : 			memcpy(newbuffer, p->buffer, p->offset + 1);

  00158	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0015b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0015e	83 c2 01	 add	 edx, 1
  00161	52		 push	 edx
  00162	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00165	8b 08		 mov	 ecx, DWORD PTR [eax]
  00167	51		 push	 ecx
  00168	8b 55 fc	 mov	 edx, DWORD PTR _newbuffer$[ebp]
  0016b	52		 push	 edx
  0016c	e8 00 00 00 00	 call	 _memcpy
  00171	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@ensure:

; 448  : 		}
; 449  : 		p->hooks.deallocate(p->buffer);

  00174	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00177	8b 08		 mov	 ecx, DWORD PTR [eax]
  00179	51		 push	 ecx
  0017a	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  0017d	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00180	ff d0		 call	 eax
  00182	83 c4 04	 add	 esp, 4
$LN3@ensure:

; 450  : 	}
; 451  : 	p->length = newsize;

  00185	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00188	8b 55 f8	 mov	 edx, DWORD PTR _newsize$[ebp]
  0018b	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 452  : 	p->buffer = newbuffer;

  0018e	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00191	8b 4d fc	 mov	 ecx, DWORD PTR _newbuffer$[ebp]
  00194	89 08		 mov	 DWORD PTR [eax], ecx

; 453  : 
; 454  : 	return newbuffer + p->offset;

  00196	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00199	8b 45 fc	 mov	 eax, DWORD PTR _newbuffer$[ebp]
  0019c	03 42 08	 add	 eax, DWORD PTR [edx+8]
$LN16@ensure:

; 455  : }

  0019f	8b e5		 mov	 esp, ebp
  001a1	5d		 pop	 ebp
  001a2	c3		 ret	 0
_ensure	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _parse_number
_TEXT	SEGMENT
_number_c_string$ = -92					; size = 64
_number$ = -28						; size = 8
tv174 = -20						; size = 4
_after_end$ = -16					; size = 4
tv81 = -12						; size = 4
_i$ = -8						; size = 4
_decimal_point$ = -1					; size = 1
_item$ = 8						; size = 4
_input_buffer$ = 12					; size = 4
_parse_number PROC					; COMDAT

; 264  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH

; 265  : 	double number = 0;

  00006	d9 ee		 fldz
  00008	dd 5d e4	 fstp	 QWORD PTR _number$[ebp]

; 266  : 	unsigned char *after_end = NULL;

  0000b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _after_end$[ebp], 0

; 267  : 	unsigned char number_c_string[64];
; 268  : 	unsigned char decimal_point = get_decimal_point();

  00012	e8 00 00 00 00	 call	 _get_decimal_point
  00017	88 45 ff	 mov	 BYTE PTR _decimal_point$[ebp], al

; 269  : 	size_t i = 0;

  0001a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 270  : 
; 271  : 	if ((input_buffer == NULL) || (input_buffer->content == NULL))

  00021	83 7d 0c 00	 cmp	 DWORD PTR _input_buffer$[ebp], 0
  00025	74 08		 je	 SHORT $LN14@parse_numb
  00027	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	75 07		 jne	 SHORT $LN15@parse_numb
$LN14@parse_numb:

; 272  : 	{
; 273  : 		return false;

  0002f	33 c0		 xor	 eax, eax
  00031	e9 30 01 00 00	 jmp	 $LN16@parse_numb
$LN15@parse_numb:

; 274  : 	}
; 275  : 
; 276  : 	/* copy the number into a temporary buffer and replace '.' with the decimal point
; 277  : 	* of the current locale (for strtod)
; 278  : 	* This also takes care of '\0' not necessarily being available for marking the end of the input */
; 279  : 	for (i = 0; (i < (sizeof(number_c_string) - 1)) && can_access_at_index(input_buffer, i); i++)

  00036	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0003d	eb 09		 jmp	 SHORT $LN13@parse_numb
$LN12@parse_numb:
  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00042	83 c1 01	 add	 ecx, 1
  00045	89 4d f8	 mov	 DWORD PTR _i$[ebp], ecx
$LN13@parse_numb:
  00048	83 7d f8 3f	 cmp	 DWORD PTR _i$[ebp], 63	; 0000003fH
  0004c	73 79		 jae	 SHORT $loop_end$20
  0004e	83 7d 0c 00	 cmp	 DWORD PTR _input_buffer$[ebp], 0
  00052	74 73		 je	 SHORT $loop_end$20
  00054	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  00057	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0005a	03 45 f8	 add	 eax, DWORD PTR _i$[ebp]
  0005d	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  00060	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00063	73 62		 jae	 SHORT $loop_end$20

; 280  : 	{
; 281  : 		switch (buffer_at_offset(input_buffer)[i])

  00065	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  00068	8b 02		 mov	 eax, DWORD PTR [edx]
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  0006d	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00070	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00073	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  00077	89 45 f4	 mov	 DWORD PTR tv81[ebp], eax
  0007a	8b 4d f4	 mov	 ecx, DWORD PTR tv81[ebp]
  0007d	83 e9 2b	 sub	 ecx, 43			; 0000002bH
  00080	89 4d f4	 mov	 DWORD PTR tv81[ebp], ecx
  00083	83 7d f4 3a	 cmp	 DWORD PTR tv81[ebp], 58	; 0000003aH
  00087	77 37		 ja	 SHORT $LN6@parse_numb
  00089	8b 55 f4	 mov	 edx, DWORD PTR tv81[ebp]
  0008c	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN18@parse_numb[edx]
  00093	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN19@parse_numb[eax*4]
$LN8@parse_numb:

; 282  : 		{
; 283  : 		case '0':
; 284  : 		case '1':
; 285  : 		case '2':
; 286  : 		case '3':
; 287  : 		case '4':
; 288  : 		case '5':
; 289  : 		case '6':
; 290  : 		case '7':
; 291  : 		case '8':
; 292  : 		case '9':
; 293  : 		case '+':
; 294  : 		case '-':
; 295  : 		case 'e':
; 296  : 		case 'E':
; 297  : 			number_c_string[i] = buffer_at_offset(input_buffer)[i];

  0009a	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  0009d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009f	8b 45 0c	 mov	 eax, DWORD PTR _input_buffer$[ebp]
  000a2	03 50 08	 add	 edx, DWORD PTR [eax+8]
  000a5	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  000a8	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000ab	8a 14 02	 mov	 dl, BYTE PTR [edx+eax]
  000ae	88 54 0d a4	 mov	 BYTE PTR _number_c_string$[ebp+ecx], dl

; 298  : 			break;

  000b2	eb 0e		 jmp	 SHORT $LN9@parse_numb
$LN7@parse_numb:

; 299  : 
; 300  : 		case '.':
; 301  : 			number_c_string[i] = decimal_point;

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000b7	8a 4d ff	 mov	 cl, BYTE PTR _decimal_point$[ebp]
  000ba	88 4c 05 a4	 mov	 BYTE PTR _number_c_string$[ebp+eax], cl

; 302  : 			break;

  000be	eb 02		 jmp	 SHORT $LN9@parse_numb
$LN6@parse_numb:

; 303  : 
; 304  : 		default:
; 305  : 			goto loop_end;

  000c0	eb 05		 jmp	 SHORT $loop_end$20
$LN9@parse_numb:

; 306  : 		}
; 307  : 	}

  000c2	e9 78 ff ff ff	 jmp	 $LN12@parse_numb
$loop_end$20:

; 308  : loop_end:
; 309  : 	number_c_string[i] = '\0';

  000c7	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  000ca	c6 44 15 a4 00	 mov	 BYTE PTR _number_c_string$[ebp+edx], 0

; 310  : 
; 311  : 	number = strtod((const char*)number_c_string, (char**)&after_end);

  000cf	8d 45 f0	 lea	 eax, DWORD PTR _after_end$[ebp]
  000d2	50		 push	 eax
  000d3	8d 4d a4	 lea	 ecx, DWORD PTR _number_c_string$[ebp]
  000d6	51		 push	 ecx
  000d7	e8 00 00 00 00	 call	 _strtod
  000dc	83 c4 08	 add	 esp, 8
  000df	89 45 ec	 mov	 DWORD PTR tv174[ebp], eax
  000e2	db 45 ec	 fild	 DWORD PTR tv174[ebp]
  000e5	dd 5d e4	 fstp	 QWORD PTR _number$[ebp]

; 312  : 	if (number_c_string == after_end)

  000e8	8d 55 a4	 lea	 edx, DWORD PTR _number_c_string$[ebp]
  000eb	3b 55 f0	 cmp	 edx, DWORD PTR _after_end$[ebp]
  000ee	75 04		 jne	 SHORT $LN5@parse_numb

; 313  : 	{
; 314  : 		return false; /* parse_error */

  000f0	33 c0		 xor	 eax, eax
  000f2	eb 72		 jmp	 SHORT $LN16@parse_numb
$LN5@parse_numb:

; 315  : 	}
; 316  : 
; 317  : 	item->valuedouble = number;

  000f4	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  000f7	dd 45 e4	 fld	 QWORD PTR _number$[ebp]
  000fa	dd 58 18	 fstp	 QWORD PTR [eax+24]

; 318  : 
; 319  : 	/* use saturation in case of overflow */
; 320  : 	if (number >= INT_MAX)

  000fd	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@41dfffffffc00000
  00103	dc 5d e4	 fcomp	 QWORD PTR _number$[ebp]
  00106	df e0		 fnstsw	 ax
  00108	f6 c4 41	 test	 ah, 65			; 00000041H
  0010b	7a 0c		 jp	 SHORT $LN4@parse_numb

; 321  : 	{
; 322  : 		item->valueint = INT_MAX;

  0010d	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00110	c7 41 14 ff ff
	ff 7f		 mov	 DWORD PTR [ecx+20], 2147483647 ; 7fffffffH
  00117	eb 2a		 jmp	 SHORT $LN1@parse_numb
$LN4@parse_numb:

; 323  : 	}
; 324  : 	else if (number <= INT_MIN)

  00119	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@c1e0000000000000
  0011f	dc 5d e4	 fcomp	 QWORD PTR _number$[ebp]
  00122	df e0		 fnstsw	 ax
  00124	f6 c4 01	 test	 ah, 1
  00127	75 0c		 jne	 SHORT $LN2@parse_numb

; 325  : 	{
; 326  : 		item->valueint = INT_MIN;

  00129	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  0012c	c7 42 14 00 00
	00 80		 mov	 DWORD PTR [edx+20], -2147483648 ; 80000000H

; 327  : 	}
; 328  : 	else

  00133	eb 0e		 jmp	 SHORT $LN1@parse_numb
$LN2@parse_numb:

; 329  : 	{
; 330  : 		item->valueint = (int)number;

  00135	dd 45 e4	 fld	 QWORD PTR _number$[ebp]
  00138	e8 00 00 00 00	 call	 __ftol2_sse
  0013d	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00140	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$LN1@parse_numb:

; 331  : 	}
; 332  : 
; 333  : 	item->type = cJSON_Number;

  00143	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00146	c7 42 0c 08 00
	00 00		 mov	 DWORD PTR [edx+12], 8

; 334  : 
; 335  : 	input_buffer->offset += (size_t)(after_end - number_c_string);

  0014d	8b 45 f0	 mov	 eax, DWORD PTR _after_end$[ebp]
  00150	8d 4d a4	 lea	 ecx, DWORD PTR _number_c_string$[ebp]
  00153	2b c1		 sub	 eax, ecx
  00155	8b 55 0c	 mov	 edx, DWORD PTR _input_buffer$[ebp]
  00158	03 42 08	 add	 eax, DWORD PTR [edx+8]
  0015b	8b 4d 0c	 mov	 ecx, DWORD PTR _input_buffer$[ebp]
  0015e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 336  : 	return true;

  00161	b8 01 00 00 00	 mov	 eax, 1
$LN16@parse_numb:

; 337  : }

  00166	8b e5		 mov	 esp, ebp
  00168	5d		 pop	 ebp
  00169	c3		 ret	 0
  0016a	8b ff		 npad	 2
$LN19@parse_numb:
  0016c	00 00 00 00	 DD	 $LN8@parse_numb
  00170	00 00 00 00	 DD	 $LN7@parse_numb
  00174	00 00 00 00	 DD	 $LN6@parse_numb
$LN18@parse_numb:
  00178	00		 DB	 0
  00179	02		 DB	 2
  0017a	00		 DB	 0
  0017b	01		 DB	 1
  0017c	02		 DB	 2
  0017d	00		 DB	 0
  0017e	00		 DB	 0
  0017f	00		 DB	 0
  00180	00		 DB	 0
  00181	00		 DB	 0
  00182	00		 DB	 0
  00183	00		 DB	 0
  00184	00		 DB	 0
  00185	00		 DB	 0
  00186	00		 DB	 0
  00187	02		 DB	 2
  00188	02		 DB	 2
  00189	02		 DB	 2
  0018a	02		 DB	 2
  0018b	02		 DB	 2
  0018c	02		 DB	 2
  0018d	02		 DB	 2
  0018e	02		 DB	 2
  0018f	02		 DB	 2
  00190	02		 DB	 2
  00191	02		 DB	 2
  00192	00		 DB	 0
  00193	02		 DB	 2
  00194	02		 DB	 2
  00195	02		 DB	 2
  00196	02		 DB	 2
  00197	02		 DB	 2
  00198	02		 DB	 2
  00199	02		 DB	 2
  0019a	02		 DB	 2
  0019b	02		 DB	 2
  0019c	02		 DB	 2
  0019d	02		 DB	 2
  0019e	02		 DB	 2
  0019f	02		 DB	 2
  001a0	02		 DB	 2
  001a1	02		 DB	 2
  001a2	02		 DB	 2
  001a3	02		 DB	 2
  001a4	02		 DB	 2
  001a5	02		 DB	 2
  001a6	02		 DB	 2
  001a7	02		 DB	 2
  001a8	02		 DB	 2
  001a9	02		 DB	 2
  001aa	02		 DB	 2
  001ab	02		 DB	 2
  001ac	02		 DB	 2
  001ad	02		 DB	 2
  001ae	02		 DB	 2
  001af	02		 DB	 2
  001b0	02		 DB	 2
  001b1	02		 DB	 2
  001b2	00		 DB	 0
_parse_number ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _get_decimal_point
_TEXT	SEGMENT
_get_decimal_point PROC					; COMDAT

; 236  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 237  : #ifdef ENABLE_LOCALES
; 238  : 	struct lconv *lconv = localeconv();
; 239  : 	return (unsigned char)lconv->decimal_point[0];
; 240  : #else
; 241  : 	return '.';

  00003	b0 2e		 mov	 al, 46			; 0000002eH

; 242  : #endif
; 243  : }

  00005	5d		 pop	 ebp
  00006	c3		 ret	 0
_get_decimal_point ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_New_Item
_TEXT	SEGMENT
_node$ = -4						; size = 4
_hooks$ = 8						; size = 4
_cJSON_New_Item PROC					; COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 201  : 	cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));

  00004	6a 28		 push	 40			; 00000028H
  00006	8b 45 08	 mov	 eax, DWORD PTR _hooks$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	ff d1		 call	 ecx
  0000d	83 c4 04	 add	 esp, 4
  00010	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax

; 202  : 	if (node)

  00013	83 7d fc 00	 cmp	 DWORD PTR _node$[ebp], 0
  00017	74 10		 je	 SHORT $LN1@cJSON_New_

; 203  : 	{
; 204  : 		memset(node, '\0', sizeof(cJSON));

  00019	6a 28		 push	 40			; 00000028H
  0001b	6a 00		 push	 0
  0001d	8b 55 fc	 mov	 edx, DWORD PTR _node$[ebp]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 _memset
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@cJSON_New_:

; 205  : 	}
; 206  : 
; 207  : 	return node;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]

; 208  : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_cJSON_New_Item ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_strdup
_TEXT	SEGMENT
_length$ = -8						; size = 4
_copy$ = -4						; size = 4
_string$ = 8						; size = 4
_hooks$ = 12						; size = 4
_cJSON_strdup PROC					; COMDAT

; 147  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 148  : 	size_t length = 0;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _length$[ebp], 0

; 149  : 	unsigned char *copy = NULL;

  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _copy$[ebp], 0

; 150  : 
; 151  : 	if (string == NULL)

  00014	83 7d 08 00	 cmp	 DWORD PTR _string$[ebp], 0
  00018	75 04		 jne	 SHORT $LN2@cJSON_strd

; 152  : 	{
; 153  : 		return NULL;

  0001a	33 c0		 xor	 eax, eax
  0001c	eb 44		 jmp	 SHORT $LN3@cJSON_strd
$LN2@cJSON_strd:

; 154  : 	}
; 155  : 
; 156  : 	length = strlen((const char*)string) + sizeof("");

  0001e	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _strlen
  00027	83 c4 04	 add	 esp, 4
  0002a	83 c0 01	 add	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _length$[ebp], eax

; 157  : 	copy = (unsigned char*)hooks->allocate(length);

  00030	8b 4d f8	 mov	 ecx, DWORD PTR _length$[ebp]
  00033	51		 push	 ecx
  00034	8b 55 0c	 mov	 edx, DWORD PTR _hooks$[ebp]
  00037	8b 02		 mov	 eax, DWORD PTR [edx]
  00039	ff d0		 call	 eax
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 fc	 mov	 DWORD PTR _copy$[ebp], eax

; 158  : 	if (copy == NULL)

  00041	83 7d fc 00	 cmp	 DWORD PTR _copy$[ebp], 0
  00045	75 04		 jne	 SHORT $LN1@cJSON_strd

; 159  : 	{
; 160  : 		return NULL;

  00047	33 c0		 xor	 eax, eax
  00049	eb 17		 jmp	 SHORT $LN3@cJSON_strd
$LN1@cJSON_strd:

; 161  : 	}
; 162  : 	memcpy(copy, string, length);

  0004b	8b 4d f8	 mov	 ecx, DWORD PTR _length$[ebp]
  0004e	51		 push	 ecx
  0004f	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  00052	52		 push	 edx
  00053	8b 45 fc	 mov	 eax, DWORD PTR _copy$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _memcpy
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 163  : 
; 164  : 	return copy;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _copy$[ebp]
$LN3@cJSON_strd:

; 165  : }

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
_cJSON_strdup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _internal_realloc
_TEXT	SEGMENT
_pointer$ = 8						; size = 4
_size$ = 12						; size = 4
_internal_realloc PROC					; COMDAT

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 136  : 	return _hx_realloc(pointer, size);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _pointer$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 __hx_realloc
  00010	83 c4 08	 add	 esp, 8

; 137  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_internal_realloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _internal_free
_TEXT	SEGMENT
_pointer$ = 8						; size = 4
_internal_free PROC					; COMDAT

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 132  : 	_hx_free(pointer);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pointer$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 __hx_free
  0000c	83 c4 04	 add	 esp, 4

; 133  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
_internal_free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _internal_malloc
_TEXT	SEGMENT
_size$ = 8						; size = 4
_internal_malloc PROC					; COMDAT

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 128  : 	return _hx_malloc(size);

  00003	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 __hx_malloc
  0000c	83 c4 04	 add	 esp, 4

; 129  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
_internal_malloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _case_insensitive_strcmp
_TEXT	SEGMENT
tv139 = -16						; size = 4
tv130 = -12						; size = 4
tv86 = -8						; size = 4
tv77 = -4						; size = 4
_string1$ = 8						; size = 4
_string2$ = 12						; size = 4
_case_insensitive_strcmp PROC				; COMDAT

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 96   : 	if ((string1 == NULL) || (string2 == NULL))

  00006	83 7d 08 00	 cmp	 DWORD PTR _string1$[ebp], 0
  0000a	74 06		 je	 SHORT $LN6@case_insen
  0000c	83 7d 0c 00	 cmp	 DWORD PTR _string2$[ebp], 0
  00010	75 0a		 jne	 SHORT $LN7@case_insen
$LN6@case_insen:

; 97   : 	{
; 98   : 		return 1;

  00012	b8 01 00 00 00	 mov	 eax, 1
  00017	e9 f8 00 00 00	 jmp	 $LN8@case_insen
$LN7@case_insen:

; 99   : 	}
; 100  : 
; 101  : 	if (string1 == string2)

  0001c	8b 45 08	 mov	 eax, DWORD PTR _string1$[ebp]
  0001f	3b 45 0c	 cmp	 eax, DWORD PTR _string2$[ebp]
  00022	75 07		 jne	 SHORT $LN5@case_insen

; 102  : 	{
; 103  : 		return 0;

  00024	33 c0		 xor	 eax, eax
  00026	e9 e9 00 00 00	 jmp	 $LN8@case_insen
$LN5@case_insen:

; 104  : 	}
; 105  : 
; 106  : 	for (; tolower(*string1) == tolower(*string2); (void)string1++, string2++)

  0002b	eb 12		 jmp	 SHORT $LN4@case_insen
$LN3@case_insen:
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _string1$[ebp]
  00030	83 c1 01	 add	 ecx, 1
  00033	89 4d 08	 mov	 DWORD PTR _string1$[ebp], ecx
  00036	8b 55 0c	 mov	 edx, DWORD PTR _string2$[ebp]
  00039	83 c2 01	 add	 edx, 1
  0003c	89 55 0c	 mov	 DWORD PTR _string2$[ebp], edx
$LN4@case_insen:
  0003f	8b 45 08	 mov	 eax, DWORD PTR _string1$[ebp]
  00042	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00045	83 f9 41	 cmp	 ecx, 65			; 00000041H
  00048	7c 19		 jl	 SHORT $LN10@case_insen
  0004a	8b 55 08	 mov	 edx, DWORD PTR _string1$[ebp]
  0004d	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00050	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  00053	7f 0e		 jg	 SHORT $LN10@case_insen
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _string1$[ebp]
  00058	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0005b	83 c2 20	 add	 edx, 32			; 00000020H
  0005e	89 55 fc	 mov	 DWORD PTR tv77[ebp], edx
  00061	eb 09		 jmp	 SHORT $LN11@case_insen
$LN10@case_insen:
  00063	8b 45 08	 mov	 eax, DWORD PTR _string1$[ebp]
  00066	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00069	89 4d fc	 mov	 DWORD PTR tv77[ebp], ecx
$LN11@case_insen:
  0006c	8b 55 0c	 mov	 edx, DWORD PTR _string2$[ebp]
  0006f	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00072	83 f8 41	 cmp	 eax, 65			; 00000041H
  00075	7c 19		 jl	 SHORT $LN12@case_insen
  00077	8b 4d 0c	 mov	 ecx, DWORD PTR _string2$[ebp]
  0007a	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0007d	83 fa 5a	 cmp	 edx, 90			; 0000005aH
  00080	7f 0e		 jg	 SHORT $LN12@case_insen
  00082	8b 45 0c	 mov	 eax, DWORD PTR _string2$[ebp]
  00085	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00088	83 c1 20	 add	 ecx, 32			; 00000020H
  0008b	89 4d f8	 mov	 DWORD PTR tv86[ebp], ecx
  0008e	eb 09		 jmp	 SHORT $LN13@case_insen
$LN12@case_insen:
  00090	8b 55 0c	 mov	 edx, DWORD PTR _string2$[ebp]
  00093	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00096	89 45 f8	 mov	 DWORD PTR tv86[ebp], eax
$LN13@case_insen:
  00099	8b 4d fc	 mov	 ecx, DWORD PTR tv77[ebp]
  0009c	3b 4d f8	 cmp	 ecx, DWORD PTR tv86[ebp]
  0009f	75 13		 jne	 SHORT $LN2@case_insen

; 107  : 	{
; 108  : 		if (*string1 == '\0')

  000a1	8b 55 08	 mov	 edx, DWORD PTR _string1$[ebp]
  000a4	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000a7	85 c0		 test	 eax, eax
  000a9	75 04		 jne	 SHORT $LN1@case_insen

; 109  : 		{
; 110  : 			return 0;

  000ab	33 c0		 xor	 eax, eax
  000ad	eb 65		 jmp	 SHORT $LN8@case_insen
$LN1@case_insen:

; 111  : 		}
; 112  : 	}

  000af	e9 79 ff ff ff	 jmp	 $LN3@case_insen
$LN2@case_insen:

; 113  : 
; 114  : 	return tolower(*string1) - tolower(*string2);

  000b4	8b 4d 08	 mov	 ecx, DWORD PTR _string1$[ebp]
  000b7	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  000ba	83 fa 41	 cmp	 edx, 65			; 00000041H
  000bd	7c 19		 jl	 SHORT $LN14@case_insen
  000bf	8b 45 08	 mov	 eax, DWORD PTR _string1$[ebp]
  000c2	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000c5	83 f9 5a	 cmp	 ecx, 90			; 0000005aH
  000c8	7f 0e		 jg	 SHORT $LN14@case_insen
  000ca	8b 55 08	 mov	 edx, DWORD PTR _string1$[ebp]
  000cd	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000d0	83 c0 20	 add	 eax, 32			; 00000020H
  000d3	89 45 f4	 mov	 DWORD PTR tv130[ebp], eax
  000d6	eb 09		 jmp	 SHORT $LN15@case_insen
$LN14@case_insen:
  000d8	8b 4d 08	 mov	 ecx, DWORD PTR _string1$[ebp]
  000db	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  000de	89 55 f4	 mov	 DWORD PTR tv130[ebp], edx
$LN15@case_insen:
  000e1	8b 45 0c	 mov	 eax, DWORD PTR _string2$[ebp]
  000e4	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000e7	83 f9 41	 cmp	 ecx, 65			; 00000041H
  000ea	7c 19		 jl	 SHORT $LN16@case_insen
  000ec	8b 55 0c	 mov	 edx, DWORD PTR _string2$[ebp]
  000ef	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000f2	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  000f5	7f 0e		 jg	 SHORT $LN16@case_insen
  000f7	8b 4d 0c	 mov	 ecx, DWORD PTR _string2$[ebp]
  000fa	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  000fd	83 c2 20	 add	 edx, 32			; 00000020H
  00100	89 55 f0	 mov	 DWORD PTR tv139[ebp], edx
  00103	eb 09		 jmp	 SHORT $LN17@case_insen
$LN16@case_insen:
  00105	8b 45 0c	 mov	 eax, DWORD PTR _string2$[ebp]
  00108	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0010b	89 4d f0	 mov	 DWORD PTR tv139[ebp], ecx
$LN17@case_insen:
  0010e	8b 45 f4	 mov	 eax, DWORD PTR tv130[ebp]
  00111	2b 45 f0	 sub	 eax, DWORD PTR tv139[ebp]
$LN8@case_insen:

; 115  : }

  00114	8b e5		 mov	 esp, ebp
  00116	5d		 pop	 ebp
  00117	c3		 ret	 0
_case_insensitive_strcmp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_free@4
_TEXT	SEGMENT
_object$ = 8						; size = 4
_cJSON_free@4 PROC					; COMDAT

; 2925 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2926 : 	global_hooks.deallocate(object);

  00003	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00006	50		 push	 eax
  00007	ff 15 04 00 00
	00		 call	 DWORD PTR _global_hooks+4
  0000d	83 c4 04	 add	 esp, 4

; 2927 : }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
_cJSON_free@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_malloc@4
_TEXT	SEGMENT
_size$ = 8						; size = 4
_cJSON_malloc@4 PROC					; COMDAT

; 2920 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2921 : 	return global_hooks.allocate(size);

  00003	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR _global_hooks
  0000d	83 c4 04	 add	 esp, 4

; 2922 : }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
_cJSON_malloc@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_SetNumberHelper@12
_TEXT	SEGMENT
_object$ = 8						; size = 4
_number$ = 12						; size = 8
_cJSON_SetNumberHelper@12 PROC				; COMDAT

; 341  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 342  : 	if (number >= INT_MAX)

  00003	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@41dfffffffc00000
  00009	dc 5d 0c	 fcomp	 QWORD PTR _number$[ebp]
  0000c	df e0		 fnstsw	 ax
  0000e	f6 c4 41	 test	 ah, 65			; 00000041H
  00011	7a 0c		 jp	 SHORT $LN4@cJSON_SetN

; 343  : 	{
; 344  : 		object->valueint = INT_MAX;

  00013	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00016	c7 40 14 ff ff
	ff 7f		 mov	 DWORD PTR [eax+20], 2147483647 ; 7fffffffH
  0001d	eb 2a		 jmp	 SHORT $LN1@cJSON_SetN
$LN4@cJSON_SetN:

; 345  : 	}
; 346  : 	else if (number <= INT_MIN)

  0001f	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@c1e0000000000000
  00025	dc 5d 0c	 fcomp	 QWORD PTR _number$[ebp]
  00028	df e0		 fnstsw	 ax
  0002a	f6 c4 01	 test	 ah, 1
  0002d	75 0c		 jne	 SHORT $LN2@cJSON_SetN

; 347  : 	{
; 348  : 		object->valueint = INT_MIN;

  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _object$[ebp]
  00032	c7 41 14 00 00
	00 80		 mov	 DWORD PTR [ecx+20], -2147483648 ; 80000000H

; 349  : 	}
; 350  : 	else

  00039	eb 0e		 jmp	 SHORT $LN1@cJSON_SetN
$LN2@cJSON_SetN:

; 351  : 	{
; 352  : 		object->valueint = (int)number;

  0003b	dd 45 0c	 fld	 QWORD PTR _number$[ebp]
  0003e	e8 00 00 00 00	 call	 __ftol2_sse
  00043	8b 55 08	 mov	 edx, DWORD PTR _object$[ebp]
  00046	89 42 14	 mov	 DWORD PTR [edx+20], eax
$LN1@cJSON_SetN:

; 353  : 	}
; 354  : 
; 355  : 	return object->valuedouble = number;

  00049	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  0004c	dd 45 0c	 fld	 QWORD PTR _number$[ebp]
  0004f	dd 58 18	 fstp	 QWORD PTR [eax+24]
  00052	dd 45 0c	 fld	 QWORD PTR _number$[ebp]

; 356  : }

  00055	5d		 pop	 ebp
  00056	c2 0c 00	 ret	 12			; 0000000cH
_cJSON_SetNumberHelper@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_AddArrayToObject@8
_TEXT	SEGMENT
_array$ = -4						; size = 4
_object$ = 8						; size = 4
_name$ = 12						; size = 4
_cJSON_AddArrayToObject@8 PROC				; COMDAT

; 2055 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2056 : 	cJSON *array = cJSON_CreateArray();

  00004	e8 00 00 00 00	 call	 _cJSON_CreateArray@0
  00009	89 45 fc	 mov	 DWORD PTR _array$[ebp], eax

; 2057 : 	if (add_item_to_object(object, name, array, &global_hooks, false))

  0000c	6a 00		 push	 0
  0000e	68 00 00 00 00	 push	 OFFSET _global_hooks
  00013	8b 45 fc	 mov	 eax, DWORD PTR _array$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _name$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 08	 mov	 edx, DWORD PTR _object$[ebp]
  0001e	52		 push	 edx
  0001f	e8 00 00 00 00	 call	 _add_item_to_object
  00024	83 c4 14	 add	 esp, 20			; 00000014H
  00027	85 c0		 test	 eax, eax
  00029	74 05		 je	 SHORT $LN1@cJSON_AddA

; 2058 : 	{
; 2059 : 		return array;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _array$[ebp]
  0002e	eb 0b		 jmp	 SHORT $LN2@cJSON_AddA
$LN1@cJSON_AddA:

; 2060 : 	}
; 2061 : 
; 2062 : 	cJSON_Delete(array);

  00030	8b 45 fc	 mov	 eax, DWORD PTR _array$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _cJSON_Delete@4

; 2063 : 	return NULL;

  00039	33 c0		 xor	 eax, eax
$LN2@cJSON_AddA:

; 2064 : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
_cJSON_AddArrayToObject@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_AddObjectToObject@8
_TEXT	SEGMENT
_object_item$ = -4					; size = 4
_object$ = 8						; size = 4
_name$ = 12						; size = 4
_cJSON_AddObjectToObject@8 PROC				; COMDAT

; 2043 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2044 : 	cJSON *object_item = cJSON_CreateObject();

  00004	e8 00 00 00 00	 call	 _cJSON_CreateObject@0
  00009	89 45 fc	 mov	 DWORD PTR _object_item$[ebp], eax

; 2045 : 	if (add_item_to_object(object, name, object_item, &global_hooks, false))

  0000c	6a 00		 push	 0
  0000e	68 00 00 00 00	 push	 OFFSET _global_hooks
  00013	8b 45 fc	 mov	 eax, DWORD PTR _object_item$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _name$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 08	 mov	 edx, DWORD PTR _object$[ebp]
  0001e	52		 push	 edx
  0001f	e8 00 00 00 00	 call	 _add_item_to_object
  00024	83 c4 14	 add	 esp, 20			; 00000014H
  00027	85 c0		 test	 eax, eax
  00029	74 05		 je	 SHORT $LN1@cJSON_AddO

; 2046 : 	{
; 2047 : 		return object_item;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _object_item$[ebp]
  0002e	eb 0b		 jmp	 SHORT $LN2@cJSON_AddO
$LN1@cJSON_AddO:

; 2048 : 	}
; 2049 : 
; 2050 : 	cJSON_Delete(object_item);

  00030	8b 45 fc	 mov	 eax, DWORD PTR _object_item$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _cJSON_Delete@4

; 2051 : 	return NULL;

  00039	33 c0		 xor	 eax, eax
$LN2@cJSON_AddO:

; 2052 : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
_cJSON_AddObjectToObject@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_AddRawToObject@12
_TEXT	SEGMENT
_raw_item$ = -4						; size = 4
_object$ = 8						; size = 4
_name$ = 12						; size = 4
_raw$ = 16						; size = 4
_cJSON_AddRawToObject@12 PROC				; COMDAT

; 2031 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2032 : 	cJSON *raw_item = cJSON_CreateRaw(raw);

  00004	8b 45 10	 mov	 eax, DWORD PTR _raw$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _cJSON_CreateRaw@4
  0000d	89 45 fc	 mov	 DWORD PTR _raw_item$[ebp], eax

; 2033 : 	if (add_item_to_object(object, name, raw_item, &global_hooks, false))

  00010	6a 00		 push	 0
  00012	68 00 00 00 00	 push	 OFFSET _global_hooks
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _raw_item$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 0c	 mov	 edx, DWORD PTR _name$[ebp]
  0001e	52		 push	 edx
  0001f	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _add_item_to_object
  00028	83 c4 14	 add	 esp, 20			; 00000014H
  0002b	85 c0		 test	 eax, eax
  0002d	74 05		 je	 SHORT $LN1@cJSON_AddR

; 2034 : 	{
; 2035 : 		return raw_item;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _raw_item$[ebp]
  00032	eb 0b		 jmp	 SHORT $LN2@cJSON_AddR
$LN1@cJSON_AddR:

; 2036 : 	}
; 2037 : 
; 2038 : 	cJSON_Delete(raw_item);

  00034	8b 4d fc	 mov	 ecx, DWORD PTR _raw_item$[ebp]
  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 _cJSON_Delete@4

; 2039 : 	return NULL;

  0003d	33 c0		 xor	 eax, eax
$LN2@cJSON_AddR:

; 2040 : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 0c 00	 ret	 12			; 0000000cH
_cJSON_AddRawToObject@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_AddStringToObject@12
_TEXT	SEGMENT
_string_item$ = -4					; size = 4
_object$ = 8						; size = 4
_name$ = 12						; size = 4
_string$ = 16						; size = 4
_cJSON_AddStringToObject@12 PROC			; COMDAT

; 2019 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2020 : 	cJSON *string_item = cJSON_CreateString(string);

  00004	8b 45 10	 mov	 eax, DWORD PTR _string$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _cJSON_CreateString@4
  0000d	89 45 fc	 mov	 DWORD PTR _string_item$[ebp], eax

; 2021 : 	if (add_item_to_object(object, name, string_item, &global_hooks, false))

  00010	6a 00		 push	 0
  00012	68 00 00 00 00	 push	 OFFSET _global_hooks
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _string_item$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 0c	 mov	 edx, DWORD PTR _name$[ebp]
  0001e	52		 push	 edx
  0001f	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _add_item_to_object
  00028	83 c4 14	 add	 esp, 20			; 00000014H
  0002b	85 c0		 test	 eax, eax
  0002d	74 05		 je	 SHORT $LN1@cJSON_AddS

; 2022 : 	{
; 2023 : 		return string_item;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _string_item$[ebp]
  00032	eb 0b		 jmp	 SHORT $LN2@cJSON_AddS
$LN1@cJSON_AddS:

; 2024 : 	}
; 2025 : 
; 2026 : 	cJSON_Delete(string_item);

  00034	8b 4d fc	 mov	 ecx, DWORD PTR _string_item$[ebp]
  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 _cJSON_Delete@4

; 2027 : 	return NULL;

  0003d	33 c0		 xor	 eax, eax
$LN2@cJSON_AddS:

; 2028 : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 0c 00	 ret	 12			; 0000000cH
_cJSON_AddStringToObject@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_AddNumberToObject@16
_TEXT	SEGMENT
_number_item$ = -4					; size = 4
_object$ = 8						; size = 4
_name$ = 12						; size = 4
_number$ = 16						; size = 8
_cJSON_AddNumberToObject@16 PROC			; COMDAT

; 2007 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2008 : 	cJSON *number_item = cJSON_CreateNumber(number);

  00004	83 ec 08	 sub	 esp, 8
  00007	dd 45 10	 fld	 QWORD PTR _number$[ebp]
  0000a	dd 1c 24	 fstp	 QWORD PTR [esp]
  0000d	e8 00 00 00 00	 call	 _cJSON_CreateNumber@8
  00012	89 45 fc	 mov	 DWORD PTR _number_item$[ebp], eax

; 2009 : 	if (add_item_to_object(object, name, number_item, &global_hooks, false))

  00015	6a 00		 push	 0
  00017	68 00 00 00 00	 push	 OFFSET _global_hooks
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _number_item$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 0c	 mov	 ecx, DWORD PTR _name$[ebp]
  00023	51		 push	 ecx
  00024	8b 55 08	 mov	 edx, DWORD PTR _object$[ebp]
  00027	52		 push	 edx
  00028	e8 00 00 00 00	 call	 _add_item_to_object
  0002d	83 c4 14	 add	 esp, 20			; 00000014H
  00030	85 c0		 test	 eax, eax
  00032	74 05		 je	 SHORT $LN1@cJSON_AddN

; 2010 : 	{
; 2011 : 		return number_item;

  00034	8b 45 fc	 mov	 eax, DWORD PTR _number_item$[ebp]
  00037	eb 0b		 jmp	 SHORT $LN2@cJSON_AddN
$LN1@cJSON_AddN:

; 2012 : 	}
; 2013 : 
; 2014 : 	cJSON_Delete(number_item);

  00039	8b 45 fc	 mov	 eax, DWORD PTR _number_item$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _cJSON_Delete@4

; 2015 : 	return NULL;

  00042	33 c0		 xor	 eax, eax
$LN2@cJSON_AddN:

; 2016 : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 10 00	 ret	 16			; 00000010H
_cJSON_AddNumberToObject@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_AddBoolToObject@12
_TEXT	SEGMENT
_bool_item$ = -4					; size = 4
_object$ = 8						; size = 4
_name$ = 12						; size = 4
_boolean$ = 16						; size = 4
_cJSON_AddBoolToObject@12 PROC				; COMDAT

; 1995 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1996 : 	cJSON *bool_item = cJSON_CreateBool(boolean);

  00004	8b 45 10	 mov	 eax, DWORD PTR _boolean$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 _cJSON_CreateBool@4
  0000d	89 45 fc	 mov	 DWORD PTR _bool_item$[ebp], eax

; 1997 : 	if (add_item_to_object(object, name, bool_item, &global_hooks, false))

  00010	6a 00		 push	 0
  00012	68 00 00 00 00	 push	 OFFSET _global_hooks
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _bool_item$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 0c	 mov	 edx, DWORD PTR _name$[ebp]
  0001e	52		 push	 edx
  0001f	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _add_item_to_object
  00028	83 c4 14	 add	 esp, 20			; 00000014H
  0002b	85 c0		 test	 eax, eax
  0002d	74 05		 je	 SHORT $LN1@cJSON_AddB

; 1998 : 	{
; 1999 : 		return bool_item;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _bool_item$[ebp]
  00032	eb 0b		 jmp	 SHORT $LN2@cJSON_AddB
$LN1@cJSON_AddB:

; 2000 : 	}
; 2001 : 
; 2002 : 	cJSON_Delete(bool_item);

  00034	8b 4d fc	 mov	 ecx, DWORD PTR _bool_item$[ebp]
  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 _cJSON_Delete@4

; 2003 : 	return NULL;

  0003d	33 c0		 xor	 eax, eax
$LN2@cJSON_AddB:

; 2004 : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 0c 00	 ret	 12			; 0000000cH
_cJSON_AddBoolToObject@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_AddFalseToObject@8
_TEXT	SEGMENT
_false_item$ = -4					; size = 4
_object$ = 8						; size = 4
_name$ = 12						; size = 4
_cJSON_AddFalseToObject@8 PROC				; COMDAT

; 1983 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1984 : 	cJSON *false_item = cJSON_CreateFalse();

  00004	e8 00 00 00 00	 call	 _cJSON_CreateFalse@0
  00009	89 45 fc	 mov	 DWORD PTR _false_item$[ebp], eax

; 1985 : 	if (add_item_to_object(object, name, false_item, &global_hooks, false))

  0000c	6a 00		 push	 0
  0000e	68 00 00 00 00	 push	 OFFSET _global_hooks
  00013	8b 45 fc	 mov	 eax, DWORD PTR _false_item$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _name$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 08	 mov	 edx, DWORD PTR _object$[ebp]
  0001e	52		 push	 edx
  0001f	e8 00 00 00 00	 call	 _add_item_to_object
  00024	83 c4 14	 add	 esp, 20			; 00000014H
  00027	85 c0		 test	 eax, eax
  00029	74 05		 je	 SHORT $LN1@cJSON_AddF

; 1986 : 	{
; 1987 : 		return false_item;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _false_item$[ebp]
  0002e	eb 0b		 jmp	 SHORT $LN2@cJSON_AddF
$LN1@cJSON_AddF:

; 1988 : 	}
; 1989 : 
; 1990 : 	cJSON_Delete(false_item);

  00030	8b 45 fc	 mov	 eax, DWORD PTR _false_item$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _cJSON_Delete@4

; 1991 : 	return NULL;

  00039	33 c0		 xor	 eax, eax
$LN2@cJSON_AddF:

; 1992 : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
_cJSON_AddFalseToObject@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_AddTrueToObject@8
_TEXT	SEGMENT
_true_item$ = -4					; size = 4
_object$ = 8						; size = 4
_name$ = 12						; size = 4
_cJSON_AddTrueToObject@8 PROC				; COMDAT

; 1971 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1972 : 	cJSON *true_item = cJSON_CreateTrue();

  00004	e8 00 00 00 00	 call	 _cJSON_CreateTrue@0
  00009	89 45 fc	 mov	 DWORD PTR _true_item$[ebp], eax

; 1973 : 	if (add_item_to_object(object, name, true_item, &global_hooks, false))

  0000c	6a 00		 push	 0
  0000e	68 00 00 00 00	 push	 OFFSET _global_hooks
  00013	8b 45 fc	 mov	 eax, DWORD PTR _true_item$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _name$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 08	 mov	 edx, DWORD PTR _object$[ebp]
  0001e	52		 push	 edx
  0001f	e8 00 00 00 00	 call	 _add_item_to_object
  00024	83 c4 14	 add	 esp, 20			; 00000014H
  00027	85 c0		 test	 eax, eax
  00029	74 05		 je	 SHORT $LN1@cJSON_AddT

; 1974 : 	{
; 1975 : 		return true_item;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _true_item$[ebp]
  0002e	eb 0b		 jmp	 SHORT $LN2@cJSON_AddT
$LN1@cJSON_AddT:

; 1976 : 	}
; 1977 : 
; 1978 : 	cJSON_Delete(true_item);

  00030	8b 45 fc	 mov	 eax, DWORD PTR _true_item$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _cJSON_Delete@4

; 1979 : 	return NULL;

  00039	33 c0		 xor	 eax, eax
$LN2@cJSON_AddT:

; 1980 : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
_cJSON_AddTrueToObject@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_AddNullToObject@8
_TEXT	SEGMENT
_null$ = -4						; size = 4
_object$ = 8						; size = 4
_name$ = 12						; size = 4
_cJSON_AddNullToObject@8 PROC				; COMDAT

; 1959 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1960 : 	cJSON *null = cJSON_CreateNull();

  00004	e8 00 00 00 00	 call	 _cJSON_CreateNull@0
  00009	89 45 fc	 mov	 DWORD PTR _null$[ebp], eax

; 1961 : 	if (add_item_to_object(object, name, null, &global_hooks, false))

  0000c	6a 00		 push	 0
  0000e	68 00 00 00 00	 push	 OFFSET _global_hooks
  00013	8b 45 fc	 mov	 eax, DWORD PTR _null$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR _name$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 08	 mov	 edx, DWORD PTR _object$[ebp]
  0001e	52		 push	 edx
  0001f	e8 00 00 00 00	 call	 _add_item_to_object
  00024	83 c4 14	 add	 esp, 20			; 00000014H
  00027	85 c0		 test	 eax, eax
  00029	74 05		 je	 SHORT $LN1@cJSON_AddN

; 1962 : 	{
; 1963 : 		return null;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _null$[ebp]
  0002e	eb 0b		 jmp	 SHORT $LN2@cJSON_AddN
$LN1@cJSON_AddN:

; 1964 : 	}
; 1965 : 
; 1966 : 	cJSON_Delete(null);

  00030	8b 45 fc	 mov	 eax, DWORD PTR _null$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _cJSON_Delete@4

; 1967 : 	return NULL;

  00039	33 c0		 xor	 eax, eax
$LN2@cJSON_AddN:

; 1968 : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
_cJSON_AddNullToObject@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_Minify@4
_TEXT	SEGMENT
_into$ = -4						; size = 4
_json$ = 8						; size = 4
_cJSON_Minify@4 PROC					; COMDAT

; 2625 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2626 : 	unsigned char *into = (unsigned char*)json;

  00004	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _into$[ebp], eax

; 2627 : 
; 2628 : 	if (json == NULL)

  0000a	83 7d 08 00	 cmp	 DWORD PTR _json$[ebp], 0
  0000e	75 05		 jne	 SHORT $LN24@cJSON_Mini

; 2629 : 	{
; 2630 : 		return;

  00010	e9 e1 01 00 00	 jmp	 $LN26@cJSON_Mini
$LN24@cJSON_Mini:

; 2631 : 	}
; 2632 : 
; 2633 : 	while (*json)

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _json$[ebp]
  00018	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0001b	85 d2		 test	 edx, edx
  0001d	0f 84 cd 01 00
	00		 je	 $LN23@cJSON_Mini

; 2634 : 	{
; 2635 : 		if (*json == ' ')

  00023	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  00026	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00029	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0002c	75 0e		 jne	 SHORT $LN22@cJSON_Mini

; 2636 : 		{
; 2637 : 			json++;

  0002e	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  00031	83 c2 01	 add	 edx, 1
  00034	89 55 08	 mov	 DWORD PTR _json$[ebp], edx
  00037	e9 af 01 00 00	 jmp	 $LN21@cJSON_Mini
$LN22@cJSON_Mini:

; 2638 : 		}
; 2639 : 		else if (*json == '\t')

  0003c	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  0003f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00042	83 f9 09	 cmp	 ecx, 9
  00045	75 0e		 jne	 SHORT $LN20@cJSON_Mini

; 2640 : 		{
; 2641 : 			/* Whitespace characters. */
; 2642 : 			json++;

  00047	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  0004a	83 c2 01	 add	 edx, 1
  0004d	89 55 08	 mov	 DWORD PTR _json$[ebp], edx
  00050	e9 96 01 00 00	 jmp	 $LN21@cJSON_Mini
$LN20@cJSON_Mini:

; 2643 : 		}
; 2644 : 		else if (*json == '\r')

  00055	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  00058	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0005b	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  0005e	75 0e		 jne	 SHORT $LN18@cJSON_Mini

; 2645 : 		{
; 2646 : 			json++;

  00060	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  00063	83 c2 01	 add	 edx, 1
  00066	89 55 08	 mov	 DWORD PTR _json$[ebp], edx
  00069	e9 7d 01 00 00	 jmp	 $LN21@cJSON_Mini
$LN18@cJSON_Mini:

; 2647 : 		}
; 2648 : 		else if (*json == '\n')

  0006e	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  00071	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00074	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  00077	75 0e		 jne	 SHORT $LN16@cJSON_Mini

; 2649 : 		{
; 2650 : 			json++;

  00079	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  0007c	83 c2 01	 add	 edx, 1
  0007f	89 55 08	 mov	 DWORD PTR _json$[ebp], edx
  00082	e9 64 01 00 00	 jmp	 $LN21@cJSON_Mini
$LN16@cJSON_Mini:

; 2651 : 		}
; 2652 : 		else if ((*json == '/') && (json[1] == '/'))

  00087	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  0008a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0008d	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00090	75 39		 jne	 SHORT $LN14@cJSON_Mini
  00092	ba 01 00 00 00	 mov	 edx, 1
  00097	c1 e2 00	 shl	 edx, 0
  0009a	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  0009d	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  000a1	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  000a4	75 25		 jne	 SHORT $LN14@cJSON_Mini
$LN13@cJSON_Mini:

; 2653 : 		{
; 2654 : 			/* double-slash comments, to end of line. */
; 2655 : 			while (*json && (*json != '\n'))

  000a6	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  000a9	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000ac	85 c0		 test	 eax, eax
  000ae	74 16		 je	 SHORT $LN12@cJSON_Mini
  000b0	8b 4d 08	 mov	 ecx, DWORD PTR _json$[ebp]
  000b3	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000b6	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  000b9	74 0b		 je	 SHORT $LN12@cJSON_Mini

; 2656 : 			{
; 2657 : 				json++;

  000bb	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  000be	83 c0 01	 add	 eax, 1
  000c1	89 45 08	 mov	 DWORD PTR _json$[ebp], eax

; 2658 : 			}

  000c4	eb e0		 jmp	 SHORT $LN13@cJSON_Mini
$LN12@cJSON_Mini:

; 2659 : 		}
; 2660 : 		else if ((*json == '/') && (json[1] == '*'))

  000c6	e9 20 01 00 00	 jmp	 $LN21@cJSON_Mini
$LN14@cJSON_Mini:
  000cb	8b 4d 08	 mov	 ecx, DWORD PTR _json$[ebp]
  000ce	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000d1	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  000d4	75 56		 jne	 SHORT $LN10@cJSON_Mini
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	c1 e0 00	 shl	 eax, 0
  000de	8b 4d 08	 mov	 ecx, DWORD PTR _json$[ebp]
  000e1	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  000e5	83 fa 2a	 cmp	 edx, 42			; 0000002aH
  000e8	75 42		 jne	 SHORT $LN10@cJSON_Mini
$LN9@cJSON_Mini:

; 2661 : 		{
; 2662 : 			/* multiline comments. */
; 2663 : 			while (*json && !((*json == '*') && (json[1] == '/')))

  000ea	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  000ed	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000f0	85 c9		 test	 ecx, ecx
  000f2	74 2a		 je	 SHORT $LN8@cJSON_Mini
  000f4	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  000f7	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000fa	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  000fd	75 14		 jne	 SHORT $LN7@cJSON_Mini
  000ff	b9 01 00 00 00	 mov	 ecx, 1
  00104	c1 e1 00	 shl	 ecx, 0
  00107	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  0010a	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  0010e	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00111	74 0b		 je	 SHORT $LN8@cJSON_Mini
$LN7@cJSON_Mini:

; 2664 : 			{
; 2665 : 				json++;

  00113	8b 4d 08	 mov	 ecx, DWORD PTR _json$[ebp]
  00116	83 c1 01	 add	 ecx, 1
  00119	89 4d 08	 mov	 DWORD PTR _json$[ebp], ecx

; 2666 : 			}

  0011c	eb cc		 jmp	 SHORT $LN9@cJSON_Mini
$LN8@cJSON_Mini:

; 2667 : 			json += 2;

  0011e	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  00121	83 c2 02	 add	 edx, 2
  00124	89 55 08	 mov	 DWORD PTR _json$[ebp], edx
  00127	e9 bf 00 00 00	 jmp	 $LN21@cJSON_Mini
$LN10@cJSON_Mini:

; 2668 : 		}
; 2669 : 		else if (*json == '\"')

  0012c	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  0012f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00132	83 f9 22	 cmp	 ecx, 34			; 00000022H
  00135	0f 85 94 00 00
	00		 jne	 $LN5@cJSON_Mini

; 2670 : 		{
; 2671 : 			/* string literals, which are \" sensitive. */
; 2672 : 			*into++ = (unsigned char)*json++;

  0013b	8b 55 fc	 mov	 edx, DWORD PTR _into$[ebp]
  0013e	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  00141	8a 08		 mov	 cl, BYTE PTR [eax]
  00143	88 0a		 mov	 BYTE PTR [edx], cl
  00145	8b 55 fc	 mov	 edx, DWORD PTR _into$[ebp]
  00148	83 c2 01	 add	 edx, 1
  0014b	89 55 fc	 mov	 DWORD PTR _into$[ebp], edx
  0014e	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  00151	83 c0 01	 add	 eax, 1
  00154	89 45 08	 mov	 DWORD PTR _json$[ebp], eax
$LN4@cJSON_Mini:

; 2673 : 			while (*json && (*json != '\"'))

  00157	8b 4d 08	 mov	 ecx, DWORD PTR _json$[ebp]
  0015a	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0015d	85 d2		 test	 edx, edx
  0015f	74 50		 je	 SHORT $LN3@cJSON_Mini
  00161	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  00164	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00167	83 f9 22	 cmp	 ecx, 34			; 00000022H
  0016a	74 45		 je	 SHORT $LN3@cJSON_Mini

; 2674 : 			{
; 2675 : 				if (*json == '\\')

  0016c	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  0016f	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00172	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  00175	75 1c		 jne	 SHORT $LN2@cJSON_Mini

; 2676 : 				{
; 2677 : 					*into++ = (unsigned char)*json++;

  00177	8b 4d fc	 mov	 ecx, DWORD PTR _into$[ebp]
  0017a	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  0017d	8a 02		 mov	 al, BYTE PTR [edx]
  0017f	88 01		 mov	 BYTE PTR [ecx], al
  00181	8b 4d fc	 mov	 ecx, DWORD PTR _into$[ebp]
  00184	83 c1 01	 add	 ecx, 1
  00187	89 4d fc	 mov	 DWORD PTR _into$[ebp], ecx
  0018a	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  0018d	83 c2 01	 add	 edx, 1
  00190	89 55 08	 mov	 DWORD PTR _json$[ebp], edx
$LN2@cJSON_Mini:

; 2678 : 				}
; 2679 : 				*into++ = (unsigned char)*json++;

  00193	8b 45 fc	 mov	 eax, DWORD PTR _into$[ebp]
  00196	8b 4d 08	 mov	 ecx, DWORD PTR _json$[ebp]
  00199	8a 11		 mov	 dl, BYTE PTR [ecx]
  0019b	88 10		 mov	 BYTE PTR [eax], dl
  0019d	8b 45 fc	 mov	 eax, DWORD PTR _into$[ebp]
  001a0	83 c0 01	 add	 eax, 1
  001a3	89 45 fc	 mov	 DWORD PTR _into$[ebp], eax
  001a6	8b 4d 08	 mov	 ecx, DWORD PTR _json$[ebp]
  001a9	83 c1 01	 add	 ecx, 1
  001ac	89 4d 08	 mov	 DWORD PTR _json$[ebp], ecx

; 2680 : 			}

  001af	eb a6		 jmp	 SHORT $LN4@cJSON_Mini
$LN3@cJSON_Mini:

; 2681 : 			*into++ = (unsigned char)*json++;

  001b1	8b 55 fc	 mov	 edx, DWORD PTR _into$[ebp]
  001b4	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  001b7	8a 08		 mov	 cl, BYTE PTR [eax]
  001b9	88 0a		 mov	 BYTE PTR [edx], cl
  001bb	8b 55 fc	 mov	 edx, DWORD PTR _into$[ebp]
  001be	83 c2 01	 add	 edx, 1
  001c1	89 55 fc	 mov	 DWORD PTR _into$[ebp], edx
  001c4	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  001c7	83 c0 01	 add	 eax, 1
  001ca	89 45 08	 mov	 DWORD PTR _json$[ebp], eax

; 2682 : 		}
; 2683 : 		else

  001cd	eb 1c		 jmp	 SHORT $LN21@cJSON_Mini
$LN5@cJSON_Mini:

; 2684 : 		{
; 2685 : 			/* All other characters. */
; 2686 : 			*into++ = (unsigned char)*json++;

  001cf	8b 4d fc	 mov	 ecx, DWORD PTR _into$[ebp]
  001d2	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  001d5	8a 02		 mov	 al, BYTE PTR [edx]
  001d7	88 01		 mov	 BYTE PTR [ecx], al
  001d9	8b 4d fc	 mov	 ecx, DWORD PTR _into$[ebp]
  001dc	83 c1 01	 add	 ecx, 1
  001df	89 4d fc	 mov	 DWORD PTR _into$[ebp], ecx
  001e2	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  001e5	83 c2 01	 add	 edx, 1
  001e8	89 55 08	 mov	 DWORD PTR _json$[ebp], edx
$LN21@cJSON_Mini:

; 2687 : 		}
; 2688 : 	}

  001eb	e9 25 fe ff ff	 jmp	 $LN24@cJSON_Mini
$LN23@cJSON_Mini:

; 2689 : 
; 2690 : 	/* and null-terminate. */
; 2691 : 	*into = '\0';

  001f0	8b 45 fc	 mov	 eax, DWORD PTR _into$[ebp]
  001f3	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN26@cJSON_Mini:

; 2692 : }

  001f6	8b e5		 mov	 esp, ebp
  001f8	5d		 pop	 ebp
  001f9	c2 04 00	 ret	 4
_cJSON_Minify@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_Compare@12
_TEXT	SEGMENT
tv158 = -32						; size = 4
tv142 = -28						; size = 4
tv82 = -24						; size = 4
tv76 = -20						; size = 4
_b_element$1 = -16					; size = 4
_a_element$2 = -12					; size = 4
_b_element$3 = -8					; size = 4
_a_element$4 = -4					; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_case_sensitive$ = 16					; size = 4
_cJSON_Compare@12 PROC					; COMDAT

; 2795 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 2796 : 	if ((a == NULL) || (b == NULL) || ((a->type & 0xFF) != (b->type & 0xFF)) || cJSON_IsInvalid(a))

  00006	83 7d 08 00	 cmp	 DWORD PTR _a$[ebp], 0
  0000a	74 2e		 je	 SHORT $LN32@cJSON_Comp
  0000c	83 7d 0c 00	 cmp	 DWORD PTR _b$[ebp], 0
  00010	74 28		 je	 SHORT $LN32@cJSON_Comp
  00012	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00015	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00018	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0001e	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  00021	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00024	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00029	3b c8		 cmp	 ecx, eax
  0002b	75 0d		 jne	 SHORT $LN32@cJSON_Comp
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 _cJSON_IsInvalid@4
  00036	85 c0		 test	 eax, eax
  00038	74 07		 je	 SHORT $LN33@cJSON_Comp
$LN32@cJSON_Comp:

; 2797 : 	{
; 2798 : 		return false;

  0003a	33 c0		 xor	 eax, eax
  0003c	e9 48 02 00 00	 jmp	 $LN25@cJSON_Comp
$LN33@cJSON_Comp:

; 2799 : 	}
; 2800 : 
; 2801 : 	/* check if type is valid */
; 2802 : 	switch (a->type & 0xFF)

  00041	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  00044	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00047	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0004c	89 45 ec	 mov	 DWORD PTR tv76[ebp], eax
  0004f	8b 4d ec	 mov	 ecx, DWORD PTR tv76[ebp]
  00052	83 e9 01	 sub	 ecx, 1
  00055	89 4d ec	 mov	 DWORD PTR tv76[ebp], ecx
  00058	83 7d ec 7f	 cmp	 DWORD PTR tv76[ebp], 127 ; 0000007fH
  0005c	77 13		 ja	 SHORT $LN28@cJSON_Comp
  0005e	8b 55 ec	 mov	 edx, DWORD PTR tv76[ebp]
  00061	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN40@cJSON_Comp[edx]
  00068	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN42@cJSON_Comp[eax*4]
$LN29@cJSON_Comp:

; 2803 : 	{
; 2804 : 	case cJSON_False:
; 2805 : 	case cJSON_True:
; 2806 : 	case cJSON_NULL:
; 2807 : 	case cJSON_Number:
; 2808 : 	case cJSON_String:
; 2809 : 	case cJSON_Raw:
; 2810 : 	case cJSON_Array:
; 2811 : 	case cJSON_Object:
; 2812 : 		break;

  0006f	eb 07		 jmp	 SHORT $LN30@cJSON_Comp
$LN28@cJSON_Comp:

; 2813 : 
; 2814 : 	default:
; 2815 : 		return false;

  00071	33 c0		 xor	 eax, eax
  00073	e9 11 02 00 00	 jmp	 $LN25@cJSON_Comp
$LN30@cJSON_Comp:

; 2816 : 	}
; 2817 : 
; 2818 : 	/* identical objects are equal */
; 2819 : 	if (a == b)

  00078	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0007b	3b 4d 0c	 cmp	 ecx, DWORD PTR _b$[ebp]
  0007e	75 0a		 jne	 SHORT $LN27@cJSON_Comp

; 2820 : 	{
; 2821 : 		return true;

  00080	b8 01 00 00 00	 mov	 eax, 1
  00085	e9 ff 01 00 00	 jmp	 $LN25@cJSON_Comp
$LN27@cJSON_Comp:

; 2822 : 	}
; 2823 : 
; 2824 : 	switch (a->type & 0xFF)

  0008a	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0008d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00090	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00095	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  00098	8b 4d e8	 mov	 ecx, DWORD PTR tv82[ebp]
  0009b	83 e9 01	 sub	 ecx, 1
  0009e	89 4d e8	 mov	 DWORD PTR tv82[ebp], ecx
  000a1	83 7d e8 7f	 cmp	 DWORD PTR tv82[ebp], 127 ; 0000007fH
  000a5	0f 87 dc 01 00
	00		 ja	 $LN1@cJSON_Comp
  000ab	8b 55 e8	 mov	 edx, DWORD PTR tv82[ebp]
  000ae	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN41@cJSON_Comp[edx]
  000b5	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN43@cJSON_Comp[eax*4]
$LN24@cJSON_Comp:

; 2825 : 	{
; 2826 : 		/* in these cases and equal type is enough */
; 2827 : 	case cJSON_False:
; 2828 : 	case cJSON_True:
; 2829 : 	case cJSON_NULL:
; 2830 : 		return true;

  000bc	b8 01 00 00 00	 mov	 eax, 1
  000c1	e9 c3 01 00 00	 jmp	 $LN25@cJSON_Comp
$LN23@cJSON_Comp:

; 2831 : 
; 2832 : 	case cJSON_Number:
; 2833 : 		if (a->valuedouble == b->valuedouble)

  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  000c9	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  000cc	dd 41 18	 fld	 QWORD PTR [ecx+24]
  000cf	dd 42 18	 fld	 QWORD PTR [edx+24]
  000d2	da e9		 fucompp
  000d4	df e0		 fnstsw	 ax
  000d6	f6 c4 44	 test	 ah, 68			; 00000044H
  000d9	7a 0a		 jp	 SHORT $LN22@cJSON_Comp

; 2834 : 		{
; 2835 : 			return true;

  000db	b8 01 00 00 00	 mov	 eax, 1
  000e0	e9 a4 01 00 00	 jmp	 $LN25@cJSON_Comp
$LN22@cJSON_Comp:

; 2836 : 		}
; 2837 : 		return false;

  000e5	33 c0		 xor	 eax, eax
  000e7	e9 9d 01 00 00	 jmp	 $LN25@cJSON_Comp
$LN21@cJSON_Comp:

; 2838 : 
; 2839 : 	case cJSON_String:
; 2840 : 	case cJSON_Raw:
; 2841 : 		if ((a->valuestring == NULL) || (b->valuestring == NULL))

  000ec	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  000ef	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  000f3	74 09		 je	 SHORT $LN19@cJSON_Comp
  000f5	8b 4d 0c	 mov	 ecx, DWORD PTR _b$[ebp]
  000f8	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  000fc	75 07		 jne	 SHORT $LN20@cJSON_Comp
$LN19@cJSON_Comp:

; 2842 : 		{
; 2843 : 			return false;

  000fe	33 c0		 xor	 eax, eax
  00100	e9 84 01 00 00	 jmp	 $LN25@cJSON_Comp
$LN20@cJSON_Comp:

; 2844 : 		}
; 2845 : 		if (strcmp(a->valuestring, b->valuestring) == 0)

  00105	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  00108	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0010b	50		 push	 eax
  0010c	8b 4d 08	 mov	 ecx, DWORD PTR _a$[ebp]
  0010f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00112	52		 push	 edx
  00113	e8 00 00 00 00	 call	 _strcmp
  00118	83 c4 08	 add	 esp, 8
  0011b	85 c0		 test	 eax, eax
  0011d	75 0a		 jne	 SHORT $LN18@cJSON_Comp

; 2846 : 		{
; 2847 : 			return true;

  0011f	b8 01 00 00 00	 mov	 eax, 1
  00124	e9 60 01 00 00	 jmp	 $LN25@cJSON_Comp
$LN18@cJSON_Comp:

; 2848 : 		}
; 2849 : 
; 2850 : 		return false;

  00129	33 c0		 xor	 eax, eax
  0012b	e9 59 01 00 00	 jmp	 $LN25@cJSON_Comp
$LN17@cJSON_Comp:

; 2851 : 
; 2852 : 	case cJSON_Array:
; 2853 : 	{
; 2854 : 		cJSON *a_element = a->child;

  00130	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  00133	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00136	89 4d f4	 mov	 DWORD PTR _a_element$2[ebp], ecx

; 2855 : 		cJSON *b_element = b->child;

  00139	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  0013c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0013f	89 45 f0	 mov	 DWORD PTR _b_element$1[ebp], eax
$LN16@cJSON_Comp:

; 2856 : 
; 2857 : 		for (; (a_element != NULL) && (b_element != NULL);)

  00142	83 7d f4 00	 cmp	 DWORD PTR _a_element$2[ebp], 0
  00146	74 34		 je	 SHORT $LN15@cJSON_Comp
  00148	83 7d f0 00	 cmp	 DWORD PTR _b_element$1[ebp], 0
  0014c	74 2e		 je	 SHORT $LN15@cJSON_Comp

; 2858 : 		{
; 2859 : 			if (!cJSON_Compare(a_element, b_element, case_sensitive))

  0014e	8b 4d 10	 mov	 ecx, DWORD PTR _case_sensitive$[ebp]
  00151	51		 push	 ecx
  00152	8b 55 f0	 mov	 edx, DWORD PTR _b_element$1[ebp]
  00155	52		 push	 edx
  00156	8b 45 f4	 mov	 eax, DWORD PTR _a_element$2[ebp]
  00159	50		 push	 eax
  0015a	e8 00 00 00 00	 call	 _cJSON_Compare@12
  0015f	85 c0		 test	 eax, eax
  00161	75 07		 jne	 SHORT $LN14@cJSON_Comp

; 2860 : 			{
; 2861 : 				return false;

  00163	33 c0		 xor	 eax, eax
  00165	e9 1f 01 00 00	 jmp	 $LN25@cJSON_Comp
$LN14@cJSON_Comp:

; 2862 : 			}
; 2863 : 
; 2864 : 			a_element = a_element->next;

  0016a	8b 4d f4	 mov	 ecx, DWORD PTR _a_element$2[ebp]
  0016d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0016f	89 55 f4	 mov	 DWORD PTR _a_element$2[ebp], edx

; 2865 : 			b_element = b_element->next;

  00172	8b 45 f0	 mov	 eax, DWORD PTR _b_element$1[ebp]
  00175	8b 08		 mov	 ecx, DWORD PTR [eax]
  00177	89 4d f0	 mov	 DWORD PTR _b_element$1[ebp], ecx

; 2866 : 		}

  0017a	eb c6		 jmp	 SHORT $LN16@cJSON_Comp
$LN15@cJSON_Comp:

; 2867 : 
; 2868 : 		/* one of the arrays is longer than the other */
; 2869 : 		if (a_element != b_element) {

  0017c	8b 55 f4	 mov	 edx, DWORD PTR _a_element$2[ebp]
  0017f	3b 55 f0	 cmp	 edx, DWORD PTR _b_element$1[ebp]
  00182	74 07		 je	 SHORT $LN13@cJSON_Comp

; 2870 : 			return false;

  00184	33 c0		 xor	 eax, eax
  00186	e9 fe 00 00 00	 jmp	 $LN25@cJSON_Comp
$LN13@cJSON_Comp:

; 2871 : 		}
; 2872 : 
; 2873 : 		return true;

  0018b	b8 01 00 00 00	 mov	 eax, 1
  00190	e9 f4 00 00 00	 jmp	 $LN25@cJSON_Comp
$LN12@cJSON_Comp:

; 2874 : 	}
; 2875 : 
; 2876 : 	case cJSON_Object:
; 2877 : 	{
; 2878 : 		cJSON *a_element = NULL;

  00195	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _a_element$4[ebp], 0

; 2879 : 		cJSON *b_element = NULL;

  0019c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _b_element$3[ebp], 0

; 2880 : 		cJSON_ArrayForEach(a_element, a)

  001a3	83 7d 08 00	 cmp	 DWORD PTR _a$[ebp], 0
  001a7	74 0b		 je	 SHORT $LN36@cJSON_Comp
  001a9	8b 45 08	 mov	 eax, DWORD PTR _a$[ebp]
  001ac	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001af	89 4d e4	 mov	 DWORD PTR tv142[ebp], ecx
  001b2	eb 07		 jmp	 SHORT $LN37@cJSON_Comp
$LN36@cJSON_Comp:
  001b4	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv142[ebp], 0
$LN37@cJSON_Comp:
  001bb	8b 55 e4	 mov	 edx, DWORD PTR tv142[ebp]
  001be	89 55 fc	 mov	 DWORD PTR _a_element$4[ebp], edx
  001c1	eb 08		 jmp	 SHORT $LN11@cJSON_Comp
$LN10@cJSON_Comp:
  001c3	8b 45 fc	 mov	 eax, DWORD PTR _a_element$4[ebp]
  001c6	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c8	89 4d fc	 mov	 DWORD PTR _a_element$4[ebp], ecx
$LN11@cJSON_Comp:
  001cb	83 7d fc 00	 cmp	 DWORD PTR _a_element$4[ebp], 0
  001cf	74 42		 je	 SHORT $LN9@cJSON_Comp

; 2881 : 		{
; 2882 : 			/* TODO This has O(n^2) runtime, which is horrible! */
; 2883 : 			b_element = get_object_item(b, a_element->string, case_sensitive);

  001d1	8b 55 10	 mov	 edx, DWORD PTR _case_sensitive$[ebp]
  001d4	52		 push	 edx
  001d5	8b 45 fc	 mov	 eax, DWORD PTR _a_element$4[ebp]
  001d8	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  001db	51		 push	 ecx
  001dc	8b 55 0c	 mov	 edx, DWORD PTR _b$[ebp]
  001df	52		 push	 edx
  001e0	e8 00 00 00 00	 call	 _get_object_item
  001e5	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e8	89 45 f8	 mov	 DWORD PTR _b_element$3[ebp], eax

; 2884 : 			if (b_element == NULL)

  001eb	83 7d f8 00	 cmp	 DWORD PTR _b_element$3[ebp], 0
  001ef	75 07		 jne	 SHORT $LN8@cJSON_Comp

; 2885 : 			{
; 2886 : 				return false;

  001f1	33 c0		 xor	 eax, eax
  001f3	e9 91 00 00 00	 jmp	 $LN25@cJSON_Comp
$LN8@cJSON_Comp:

; 2887 : 			}
; 2888 : 
; 2889 : 			if (!cJSON_Compare(a_element, b_element, case_sensitive))

  001f8	8b 45 10	 mov	 eax, DWORD PTR _case_sensitive$[ebp]
  001fb	50		 push	 eax
  001fc	8b 4d f8	 mov	 ecx, DWORD PTR _b_element$3[ebp]
  001ff	51		 push	 ecx
  00200	8b 55 fc	 mov	 edx, DWORD PTR _a_element$4[ebp]
  00203	52		 push	 edx
  00204	e8 00 00 00 00	 call	 _cJSON_Compare@12
  00209	85 c0		 test	 eax, eax
  0020b	75 04		 jne	 SHORT $LN7@cJSON_Comp

; 2890 : 			{
; 2891 : 				return false;

  0020d	33 c0		 xor	 eax, eax
  0020f	eb 78		 jmp	 SHORT $LN25@cJSON_Comp
$LN7@cJSON_Comp:

; 2892 : 			}
; 2893 : 		}

  00211	eb b0		 jmp	 SHORT $LN10@cJSON_Comp
$LN9@cJSON_Comp:

; 2894 : 
; 2895 : 		/* doing this twice, once on a and b to prevent true comparison if a subset of b
; 2896 : 		* TODO: Do this the proper way, this is just a fix for now */
; 2897 : 		cJSON_ArrayForEach(b_element, b)

  00213	83 7d 0c 00	 cmp	 DWORD PTR _b$[ebp], 0
  00217	74 0b		 je	 SHORT $LN38@cJSON_Comp
  00219	8b 45 0c	 mov	 eax, DWORD PTR _b$[ebp]
  0021c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0021f	89 4d e0	 mov	 DWORD PTR tv158[ebp], ecx
  00222	eb 07		 jmp	 SHORT $LN39@cJSON_Comp
$LN38@cJSON_Comp:
  00224	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR tv158[ebp], 0
$LN39@cJSON_Comp:
  0022b	8b 55 e0	 mov	 edx, DWORD PTR tv158[ebp]
  0022e	89 55 f8	 mov	 DWORD PTR _b_element$3[ebp], edx
  00231	eb 08		 jmp	 SHORT $LN6@cJSON_Comp
$LN5@cJSON_Comp:
  00233	8b 45 f8	 mov	 eax, DWORD PTR _b_element$3[ebp]
  00236	8b 08		 mov	 ecx, DWORD PTR [eax]
  00238	89 4d f8	 mov	 DWORD PTR _b_element$3[ebp], ecx
$LN6@cJSON_Comp:
  0023b	83 7d f8 00	 cmp	 DWORD PTR _b_element$3[ebp], 0
  0023f	74 3f		 je	 SHORT $LN4@cJSON_Comp

; 2898 : 		{
; 2899 : 			a_element = get_object_item(a, b_element->string, case_sensitive);

  00241	8b 55 10	 mov	 edx, DWORD PTR _case_sensitive$[ebp]
  00244	52		 push	 edx
  00245	8b 45 f8	 mov	 eax, DWORD PTR _b_element$3[ebp]
  00248	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0024b	51		 push	 ecx
  0024c	8b 55 08	 mov	 edx, DWORD PTR _a$[ebp]
  0024f	52		 push	 edx
  00250	e8 00 00 00 00	 call	 _get_object_item
  00255	83 c4 0c	 add	 esp, 12			; 0000000cH
  00258	89 45 fc	 mov	 DWORD PTR _a_element$4[ebp], eax

; 2900 : 			if (a_element == NULL)

  0025b	83 7d fc 00	 cmp	 DWORD PTR _a_element$4[ebp], 0
  0025f	75 04		 jne	 SHORT $LN3@cJSON_Comp

; 2901 : 			{
; 2902 : 				return false;

  00261	33 c0		 xor	 eax, eax
  00263	eb 24		 jmp	 SHORT $LN25@cJSON_Comp
$LN3@cJSON_Comp:

; 2903 : 			}
; 2904 : 
; 2905 : 			if (!cJSON_Compare(b_element, a_element, case_sensitive))

  00265	8b 45 10	 mov	 eax, DWORD PTR _case_sensitive$[ebp]
  00268	50		 push	 eax
  00269	8b 4d fc	 mov	 ecx, DWORD PTR _a_element$4[ebp]
  0026c	51		 push	 ecx
  0026d	8b 55 f8	 mov	 edx, DWORD PTR _b_element$3[ebp]
  00270	52		 push	 edx
  00271	e8 00 00 00 00	 call	 _cJSON_Compare@12
  00276	85 c0		 test	 eax, eax
  00278	75 04		 jne	 SHORT $LN2@cJSON_Comp

; 2906 : 			{
; 2907 : 				return false;

  0027a	33 c0		 xor	 eax, eax
  0027c	eb 0b		 jmp	 SHORT $LN25@cJSON_Comp
$LN2@cJSON_Comp:

; 2908 : 			}
; 2909 : 		}

  0027e	eb b3		 jmp	 SHORT $LN5@cJSON_Comp
$LN4@cJSON_Comp:

; 2910 : 
; 2911 : 		return true;

  00280	b8 01 00 00 00	 mov	 eax, 1
  00285	eb 02		 jmp	 SHORT $LN25@cJSON_Comp
$LN1@cJSON_Comp:

; 2912 : 	}
; 2913 : 
; 2914 : 	default:
; 2915 : 		return false;

  00287	33 c0		 xor	 eax, eax
$LN25@cJSON_Comp:

; 2916 : 	}
; 2917 : }

  00289	8b e5		 mov	 esp, ebp
  0028b	5d		 pop	 ebp
  0028c	c2 0c 00	 ret	 12			; 0000000cH
  0028f	90		 npad	 1
$LN42@cJSON_Comp:
  00290	00 00 00 00	 DD	 $LN29@cJSON_Comp
  00294	00 00 00 00	 DD	 $LN28@cJSON_Comp
$LN40@cJSON_Comp:
  00298	00		 DB	 0
  00299	00		 DB	 0
  0029a	01		 DB	 1
  0029b	00		 DB	 0
  0029c	01		 DB	 1
  0029d	01		 DB	 1
  0029e	01		 DB	 1
  0029f	00		 DB	 0
  002a0	01		 DB	 1
  002a1	01		 DB	 1
  002a2	01		 DB	 1
  002a3	01		 DB	 1
  002a4	01		 DB	 1
  002a5	01		 DB	 1
  002a6	01		 DB	 1
  002a7	00		 DB	 0
  002a8	01		 DB	 1
  002a9	01		 DB	 1
  002aa	01		 DB	 1
  002ab	01		 DB	 1
  002ac	01		 DB	 1
  002ad	01		 DB	 1
  002ae	01		 DB	 1
  002af	01		 DB	 1
  002b0	01		 DB	 1
  002b1	01		 DB	 1
  002b2	01		 DB	 1
  002b3	01		 DB	 1
  002b4	01		 DB	 1
  002b5	01		 DB	 1
  002b6	01		 DB	 1
  002b7	00		 DB	 0
  002b8	01		 DB	 1
  002b9	01		 DB	 1
  002ba	01		 DB	 1
  002bb	01		 DB	 1
  002bc	01		 DB	 1
  002bd	01		 DB	 1
  002be	01		 DB	 1
  002bf	01		 DB	 1
  002c0	01		 DB	 1
  002c1	01		 DB	 1
  002c2	01		 DB	 1
  002c3	01		 DB	 1
  002c4	01		 DB	 1
  002c5	01		 DB	 1
  002c6	01		 DB	 1
  002c7	01		 DB	 1
  002c8	01		 DB	 1
  002c9	01		 DB	 1
  002ca	01		 DB	 1
  002cb	01		 DB	 1
  002cc	01		 DB	 1
  002cd	01		 DB	 1
  002ce	01		 DB	 1
  002cf	01		 DB	 1
  002d0	01		 DB	 1
  002d1	01		 DB	 1
  002d2	01		 DB	 1
  002d3	01		 DB	 1
  002d4	01		 DB	 1
  002d5	01		 DB	 1
  002d6	01		 DB	 1
  002d7	00		 DB	 0
  002d8	01		 DB	 1
  002d9	01		 DB	 1
  002da	01		 DB	 1
  002db	01		 DB	 1
  002dc	01		 DB	 1
  002dd	01		 DB	 1
  002de	01		 DB	 1
  002df	01		 DB	 1
  002e0	01		 DB	 1
  002e1	01		 DB	 1
  002e2	01		 DB	 1
  002e3	01		 DB	 1
  002e4	01		 DB	 1
  002e5	01		 DB	 1
  002e6	01		 DB	 1
  002e7	01		 DB	 1
  002e8	01		 DB	 1
  002e9	01		 DB	 1
  002ea	01		 DB	 1
  002eb	01		 DB	 1
  002ec	01		 DB	 1
  002ed	01		 DB	 1
  002ee	01		 DB	 1
  002ef	01		 DB	 1
  002f0	01		 DB	 1
  002f1	01		 DB	 1
  002f2	01		 DB	 1
  002f3	01		 DB	 1
  002f4	01		 DB	 1
  002f5	01		 DB	 1
  002f6	01		 DB	 1
  002f7	01		 DB	 1
  002f8	01		 DB	 1
  002f9	01		 DB	 1
  002fa	01		 DB	 1
  002fb	01		 DB	 1
  002fc	01		 DB	 1
  002fd	01		 DB	 1
  002fe	01		 DB	 1
  002ff	01		 DB	 1
  00300	01		 DB	 1
  00301	01		 DB	 1
  00302	01		 DB	 1
  00303	01		 DB	 1
  00304	01		 DB	 1
  00305	01		 DB	 1
  00306	01		 DB	 1
  00307	01		 DB	 1
  00308	01		 DB	 1
  00309	01		 DB	 1
  0030a	01		 DB	 1
  0030b	01		 DB	 1
  0030c	01		 DB	 1
  0030d	01		 DB	 1
  0030e	01		 DB	 1
  0030f	01		 DB	 1
  00310	01		 DB	 1
  00311	01		 DB	 1
  00312	01		 DB	 1
  00313	01		 DB	 1
  00314	01		 DB	 1
  00315	01		 DB	 1
  00316	01		 DB	 1
  00317	00		 DB	 0
$LN43@cJSON_Comp:
  00318	00 00 00 00	 DD	 $LN24@cJSON_Comp
  0031c	00 00 00 00	 DD	 $LN23@cJSON_Comp
  00320	00 00 00 00	 DD	 $LN21@cJSON_Comp
  00324	00 00 00 00	 DD	 $LN17@cJSON_Comp
  00328	00 00 00 00	 DD	 $LN12@cJSON_Comp
  0032c	00 00 00 00	 DD	 $LN1@cJSON_Comp
$LN41@cJSON_Comp:
  00330	00		 DB	 0
  00331	00		 DB	 0
  00332	05		 DB	 5
  00333	00		 DB	 0
  00334	05		 DB	 5
  00335	05		 DB	 5
  00336	05		 DB	 5
  00337	01		 DB	 1
  00338	05		 DB	 5
  00339	05		 DB	 5
  0033a	05		 DB	 5
  0033b	05		 DB	 5
  0033c	05		 DB	 5
  0033d	05		 DB	 5
  0033e	05		 DB	 5
  0033f	02		 DB	 2
  00340	05		 DB	 5
  00341	05		 DB	 5
  00342	05		 DB	 5
  00343	05		 DB	 5
  00344	05		 DB	 5
  00345	05		 DB	 5
  00346	05		 DB	 5
  00347	05		 DB	 5
  00348	05		 DB	 5
  00349	05		 DB	 5
  0034a	05		 DB	 5
  0034b	05		 DB	 5
  0034c	05		 DB	 5
  0034d	05		 DB	 5
  0034e	05		 DB	 5
  0034f	03		 DB	 3
  00350	05		 DB	 5
  00351	05		 DB	 5
  00352	05		 DB	 5
  00353	05		 DB	 5
  00354	05		 DB	 5
  00355	05		 DB	 5
  00356	05		 DB	 5
  00357	05		 DB	 5
  00358	05		 DB	 5
  00359	05		 DB	 5
  0035a	05		 DB	 5
  0035b	05		 DB	 5
  0035c	05		 DB	 5
  0035d	05		 DB	 5
  0035e	05		 DB	 5
  0035f	05		 DB	 5
  00360	05		 DB	 5
  00361	05		 DB	 5
  00362	05		 DB	 5
  00363	05		 DB	 5
  00364	05		 DB	 5
  00365	05		 DB	 5
  00366	05		 DB	 5
  00367	05		 DB	 5
  00368	05		 DB	 5
  00369	05		 DB	 5
  0036a	05		 DB	 5
  0036b	05		 DB	 5
  0036c	05		 DB	 5
  0036d	05		 DB	 5
  0036e	05		 DB	 5
  0036f	04		 DB	 4
  00370	05		 DB	 5
  00371	05		 DB	 5
  00372	05		 DB	 5
  00373	05		 DB	 5
  00374	05		 DB	 5
  00375	05		 DB	 5
  00376	05		 DB	 5
  00377	05		 DB	 5
  00378	05		 DB	 5
  00379	05		 DB	 5
  0037a	05		 DB	 5
  0037b	05		 DB	 5
  0037c	05		 DB	 5
  0037d	05		 DB	 5
  0037e	05		 DB	 5
  0037f	05		 DB	 5
  00380	05		 DB	 5
  00381	05		 DB	 5
  00382	05		 DB	 5
  00383	05		 DB	 5
  00384	05		 DB	 5
  00385	05		 DB	 5
  00386	05		 DB	 5
  00387	05		 DB	 5
  00388	05		 DB	 5
  00389	05		 DB	 5
  0038a	05		 DB	 5
  0038b	05		 DB	 5
  0038c	05		 DB	 5
  0038d	05		 DB	 5
  0038e	05		 DB	 5
  0038f	05		 DB	 5
  00390	05		 DB	 5
  00391	05		 DB	 5
  00392	05		 DB	 5
  00393	05		 DB	 5
  00394	05		 DB	 5
  00395	05		 DB	 5
  00396	05		 DB	 5
  00397	05		 DB	 5
  00398	05		 DB	 5
  00399	05		 DB	 5
  0039a	05		 DB	 5
  0039b	05		 DB	 5
  0039c	05		 DB	 5
  0039d	05		 DB	 5
  0039e	05		 DB	 5
  0039f	05		 DB	 5
  003a0	05		 DB	 5
  003a1	05		 DB	 5
  003a2	05		 DB	 5
  003a3	05		 DB	 5
  003a4	05		 DB	 5
  003a5	05		 DB	 5
  003a6	05		 DB	 5
  003a7	05		 DB	 5
  003a8	05		 DB	 5
  003a9	05		 DB	 5
  003aa	05		 DB	 5
  003ab	05		 DB	 5
  003ac	05		 DB	 5
  003ad	05		 DB	 5
  003ae	05		 DB	 5
  003af	02		 DB	 2
_cJSON_Compare@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_Duplicate@8
_TEXT	SEGMENT
tv95 = -20						; size = 4
_child$ = -16						; size = 4
_next$ = -12						; size = 4
_newchild$ = -8						; size = 4
_newitem$ = -4						; size = 4
_item$ = 8						; size = 4
_recurse$ = 12						; size = 4
_cJSON_Duplicate@8 PROC					; COMDAT

; 2546 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 2547 : 	cJSON *newitem = NULL;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _newitem$[ebp], 0

; 2548 : 	cJSON *child = NULL;

  0000d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _child$[ebp], 0

; 2549 : 	cJSON *next = NULL;

  00014	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0

; 2550 : 	cJSON *newchild = NULL;

  0001b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _newchild$[ebp], 0

; 2551 : 
; 2552 : 	/* Bail on bad ptr */
; 2553 : 	if (!item)

  00022	83 7d 08 00	 cmp	 DWORD PTR _item$[ebp], 0
  00026	75 05		 jne	 SHORT $LN13@cJSON_Dupl

; 2554 : 	{
; 2555 : 		goto fail;

  00028	e9 2f 01 00 00	 jmp	 $fail$18
$LN13@cJSON_Dupl:

; 2556 : 	}
; 2557 : 	/* Create new item */
; 2558 : 	newitem = cJSON_New_Item(&global_hooks);

  0002d	68 00 00 00 00	 push	 OFFSET _global_hooks
  00032	e8 00 00 00 00	 call	 _cJSON_New_Item
  00037	83 c4 04	 add	 esp, 4
  0003a	89 45 fc	 mov	 DWORD PTR _newitem$[ebp], eax

; 2559 : 	if (!newitem)

  0003d	83 7d fc 00	 cmp	 DWORD PTR _newitem$[ebp], 0
  00041	75 05		 jne	 SHORT $LN12@cJSON_Dupl

; 2560 : 	{
; 2561 : 		goto fail;

  00043	e9 14 01 00 00	 jmp	 $fail$18
$LN12@cJSON_Dupl:

; 2562 : 	}
; 2563 : 	/* Copy over all vars */
; 2564 : 	newitem->type = item->type & (~cJSON_IsReference);

  00048	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  0004b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0004e	81 e1 ff fe ff
	ff		 and	 ecx, -257		; fffffeffH
  00054	8b 55 fc	 mov	 edx, DWORD PTR _newitem$[ebp]
  00057	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 2565 : 	newitem->valueint = item->valueint;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _newitem$[ebp]
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00060	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00063	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 2566 : 	newitem->valuedouble = item->valuedouble;

  00066	8b 45 fc	 mov	 eax, DWORD PTR _newitem$[ebp]
  00069	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  0006c	dd 41 18	 fld	 QWORD PTR [ecx+24]
  0006f	dd 58 18	 fstp	 QWORD PTR [eax+24]

; 2567 : 	if (item->valuestring)

  00072	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00075	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  00079	74 28		 je	 SHORT $LN10@cJSON_Dupl

; 2568 : 	{
; 2569 : 		newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);

  0007b	68 00 00 00 00	 push	 OFFSET _global_hooks
  00080	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00083	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 _cJSON_strdup
  0008c	83 c4 08	 add	 esp, 8
  0008f	8b 55 fc	 mov	 edx, DWORD PTR _newitem$[ebp]
  00092	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 2570 : 		if (!newitem->valuestring)

  00095	8b 45 fc	 mov	 eax, DWORD PTR _newitem$[ebp]
  00098	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0009c	75 05		 jne	 SHORT $LN10@cJSON_Dupl

; 2571 : 		{
; 2572 : 			goto fail;

  0009e	e9 b9 00 00 00	 jmp	 $fail$18
$LN10@cJSON_Dupl:

; 2573 : 		}
; 2574 : 	}
; 2575 : 	if (item->string)

  000a3	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  000a6	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  000aa	74 43		 je	 SHORT $LN8@cJSON_Dupl

; 2576 : 	{
; 2577 : 		newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);

  000ac	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  000af	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000b2	25 00 02 00 00	 and	 eax, 512		; 00000200H
  000b7	74 0b		 je	 SHORT $LN16@cJSON_Dupl
  000b9	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  000bc	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  000bf	89 55 ec	 mov	 DWORD PTR tv95[ebp], edx
  000c2	eb 17		 jmp	 SHORT $LN17@cJSON_Dupl
$LN16@cJSON_Dupl:
  000c4	68 00 00 00 00	 push	 OFFSET _global_hooks
  000c9	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  000cc	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000cf	51		 push	 ecx
  000d0	e8 00 00 00 00	 call	 _cJSON_strdup
  000d5	83 c4 08	 add	 esp, 8
  000d8	89 45 ec	 mov	 DWORD PTR tv95[ebp], eax
$LN17@cJSON_Dupl:
  000db	8b 55 fc	 mov	 edx, DWORD PTR _newitem$[ebp]
  000de	8b 45 ec	 mov	 eax, DWORD PTR tv95[ebp]
  000e1	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 2578 : 		if (!newitem->string)

  000e4	8b 4d fc	 mov	 ecx, DWORD PTR _newitem$[ebp]
  000e7	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  000eb	75 02		 jne	 SHORT $LN8@cJSON_Dupl

; 2579 : 		{
; 2580 : 			goto fail;

  000ed	eb 6d		 jmp	 SHORT $fail$18
$LN8@cJSON_Dupl:

; 2581 : 		}
; 2582 : 	}
; 2583 : 	/* If non-recursive, then we're done! */
; 2584 : 	if (!recurse)

  000ef	83 7d 0c 00	 cmp	 DWORD PTR _recurse$[ebp], 0
  000f3	75 05		 jne	 SHORT $LN7@cJSON_Dupl

; 2585 : 	{
; 2586 : 		return newitem;

  000f5	8b 45 fc	 mov	 eax, DWORD PTR _newitem$[ebp]
  000f8	eb 73		 jmp	 SHORT $LN14@cJSON_Dupl
$LN7@cJSON_Dupl:

; 2587 : 	}
; 2588 : 	/* Walk the ->next chain for the child. */
; 2589 : 	child = item->child;

  000fa	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  000fd	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00100	89 45 f0	 mov	 DWORD PTR _child$[ebp], eax
$LN6@cJSON_Dupl:

; 2590 : 	while (child != NULL)

  00103	83 7d f0 00	 cmp	 DWORD PTR _child$[ebp], 0
  00107	74 4e		 je	 SHORT $LN5@cJSON_Dupl

; 2591 : 	{
; 2592 : 		newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the ->next chain */

  00109	6a 01		 push	 1
  0010b	8b 4d f0	 mov	 ecx, DWORD PTR _child$[ebp]
  0010e	51		 push	 ecx
  0010f	e8 00 00 00 00	 call	 _cJSON_Duplicate@8
  00114	89 45 f8	 mov	 DWORD PTR _newchild$[ebp], eax

; 2593 : 		if (!newchild)

  00117	83 7d f8 00	 cmp	 DWORD PTR _newchild$[ebp], 0
  0011b	75 02		 jne	 SHORT $LN4@cJSON_Dupl

; 2594 : 		{
; 2595 : 			goto fail;

  0011d	eb 3d		 jmp	 SHORT $fail$18
$LN4@cJSON_Dupl:

; 2596 : 		}
; 2597 : 		if (next != NULL)

  0011f	83 7d f4 00	 cmp	 DWORD PTR _next$[ebp], 0
  00123	74 19		 je	 SHORT $LN3@cJSON_Dupl

; 2598 : 		{
; 2599 : 			/* If newitem->child already set, then crosswire ->prev and ->next and move on */
; 2600 : 			next->next = newchild;

  00125	8b 55 f4	 mov	 edx, DWORD PTR _next$[ebp]
  00128	8b 45 f8	 mov	 eax, DWORD PTR _newchild$[ebp]
  0012b	89 02		 mov	 DWORD PTR [edx], eax

; 2601 : 			newchild->prev = next;

  0012d	8b 4d f8	 mov	 ecx, DWORD PTR _newchild$[ebp]
  00130	8b 55 f4	 mov	 edx, DWORD PTR _next$[ebp]
  00133	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 2602 : 			next = newchild;

  00136	8b 45 f8	 mov	 eax, DWORD PTR _newchild$[ebp]
  00139	89 45 f4	 mov	 DWORD PTR _next$[ebp], eax

; 2603 : 		}
; 2604 : 		else

  0013c	eb 0f		 jmp	 SHORT $LN2@cJSON_Dupl
$LN3@cJSON_Dupl:

; 2605 : 		{
; 2606 : 			/* Set newitem->child and move to it */
; 2607 : 			newitem->child = newchild;

  0013e	8b 4d fc	 mov	 ecx, DWORD PTR _newitem$[ebp]
  00141	8b 55 f8	 mov	 edx, DWORD PTR _newchild$[ebp]
  00144	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 2608 : 			next = newchild;

  00147	8b 45 f8	 mov	 eax, DWORD PTR _newchild$[ebp]
  0014a	89 45 f4	 mov	 DWORD PTR _next$[ebp], eax
$LN2@cJSON_Dupl:

; 2609 : 		}
; 2610 : 		child = child->next;

  0014d	8b 4d f0	 mov	 ecx, DWORD PTR _child$[ebp]
  00150	8b 11		 mov	 edx, DWORD PTR [ecx]
  00152	89 55 f0	 mov	 DWORD PTR _child$[ebp], edx

; 2611 : 	}

  00155	eb ac		 jmp	 SHORT $LN6@cJSON_Dupl
$LN5@cJSON_Dupl:

; 2612 : 
; 2613 : 	return newitem;

  00157	8b 45 fc	 mov	 eax, DWORD PTR _newitem$[ebp]
  0015a	eb 11		 jmp	 SHORT $LN14@cJSON_Dupl
$fail$18:

; 2614 : 
; 2615 : fail:
; 2616 : 	if (newitem != NULL)

  0015c	83 7d fc 00	 cmp	 DWORD PTR _newitem$[ebp], 0
  00160	74 09		 je	 SHORT $LN1@cJSON_Dupl

; 2617 : 	{
; 2618 : 		cJSON_Delete(newitem);

  00162	8b 45 fc	 mov	 eax, DWORD PTR _newitem$[ebp]
  00165	50		 push	 eax
  00166	e8 00 00 00 00	 call	 _cJSON_Delete@4
$LN1@cJSON_Dupl:

; 2619 : 	}
; 2620 : 
; 2621 : 	return NULL;

  0016b	33 c0		 xor	 eax, eax
$LN14@cJSON_Dupl:

; 2622 : }

  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c2 08 00	 ret	 8
_cJSON_Duplicate@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_ReplaceItemInObjectCaseSensitive@12
_TEXT	SEGMENT
_object$ = 8						; size = 4
_string$ = 12						; size = 4
_newitem$ = 16						; size = 4
_cJSON_ReplaceItemInObjectCaseSensitive@12 PROC		; COMDAT

; 2236 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2237 : 	replace_item_in_object(object, string, newitem, true);

  00003	6a 01		 push	 1
  00005	8b 45 10	 mov	 eax, DWORD PTR _newitem$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _string$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 08	 mov	 edx, DWORD PTR _object$[ebp]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 _replace_item_in_object
  00016	83 c4 10	 add	 esp, 16			; 00000010H

; 2238 : }

  00019	5d		 pop	 ebp
  0001a	c2 0c 00	 ret	 12			; 0000000cH
_cJSON_ReplaceItemInObjectCaseSensitive@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_ReplaceItemInObject@12
_TEXT	SEGMENT
_object$ = 8						; size = 4
_string$ = 12						; size = 4
_newitem$ = 16						; size = 4
_cJSON_ReplaceItemInObject@12 PROC			; COMDAT

; 2231 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2232 : 	replace_item_in_object(object, string, newitem, false);

  00003	6a 00		 push	 0
  00005	8b 45 10	 mov	 eax, DWORD PTR _newitem$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _string$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 08	 mov	 edx, DWORD PTR _object$[ebp]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 _replace_item_in_object
  00016	83 c4 10	 add	 esp, 16			; 00000010H

; 2233 : }

  00019	5d		 pop	 ebp
  0001a	c2 0c 00	 ret	 12			; 0000000cH
_cJSON_ReplaceItemInObject@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_ReplaceItemInArray@12
_TEXT	SEGMENT
_array$ = 8						; size = 4
_which$ = 12						; size = 4
_newitem$ = 16						; size = 4
_cJSON_ReplaceItemInArray@12 PROC			; COMDAT

; 2201 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2202 : 	if (which < 0)

  00003	83 7d 0c 00	 cmp	 DWORD PTR _which$[ebp], 0
  00007	7d 02		 jge	 SHORT $LN1@cJSON_Repl

; 2203 : 	{
; 2204 : 		return;

  00009	eb 1e		 jmp	 SHORT $LN2@cJSON_Repl
$LN1@cJSON_Repl:

; 2205 : 	}
; 2206 : 
; 2207 : 	cJSON_ReplaceItemViaPointer(array, get_array_item(array, (size_t)which), newitem);

  0000b	8b 45 10	 mov	 eax, DWORD PTR _newitem$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR _which$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 08	 mov	 edx, DWORD PTR _array$[ebp]
  00016	52		 push	 edx
  00017	e8 00 00 00 00	 call	 _get_array_item
  0001c	83 c4 08	 add	 esp, 8
  0001f	50		 push	 eax
  00020	8b 45 08	 mov	 eax, DWORD PTR _array$[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _cJSON_ReplaceItemViaPointer@12
$LN2@cJSON_Repl:

; 2208 : }

  00029	5d		 pop	 ebp
  0002a	c2 0c 00	 ret	 12			; 0000000cH
_cJSON_ReplaceItemInArray@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_ReplaceItemViaPointer@12
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_item$ = 12						; size = 4
_replacement$ = 16					; size = 4
_cJSON_ReplaceItemViaPointer@12 PROC			; COMDAT

; 2166 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2167 : 	if ((parent == NULL) || (replacement == NULL) || (item == NULL))

  00003	83 7d 08 00	 cmp	 DWORD PTR _parent$[ebp], 0
  00007	74 0c		 je	 SHORT $LN5@cJSON_Repl
  00009	83 7d 10 00	 cmp	 DWORD PTR _replacement$[ebp], 0
  0000d	74 06		 je	 SHORT $LN5@cJSON_Repl
  0000f	83 7d 0c 00	 cmp	 DWORD PTR _item$[ebp], 0
  00013	75 07		 jne	 SHORT $LN6@cJSON_Repl
$LN5@cJSON_Repl:

; 2168 : 	{
; 2169 : 		return false;

  00015	33 c0		 xor	 eax, eax
  00017	e9 81 00 00 00	 jmp	 $LN7@cJSON_Repl
$LN6@cJSON_Repl:

; 2170 : 	}
; 2171 : 
; 2172 : 	if (replacement == item)

  0001c	8b 45 10	 mov	 eax, DWORD PTR _replacement$[ebp]
  0001f	3b 45 0c	 cmp	 eax, DWORD PTR _item$[ebp]
  00022	75 07		 jne	 SHORT $LN4@cJSON_Repl

; 2173 : 	{
; 2174 : 		return true;

  00024	b8 01 00 00 00	 mov	 eax, 1
  00029	eb 72		 jmp	 SHORT $LN7@cJSON_Repl
$LN4@cJSON_Repl:

; 2175 : 	}
; 2176 : 
; 2177 : 	replacement->next = item->next;

  0002b	8b 4d 10	 mov	 ecx, DWORD PTR _replacement$[ebp]
  0002e	8b 55 0c	 mov	 edx, DWORD PTR _item$[ebp]
  00031	8b 02		 mov	 eax, DWORD PTR [edx]
  00033	89 01		 mov	 DWORD PTR [ecx], eax

; 2178 : 	replacement->prev = item->prev;

  00035	8b 4d 10	 mov	 ecx, DWORD PTR _replacement$[ebp]
  00038	8b 55 0c	 mov	 edx, DWORD PTR _item$[ebp]
  0003b	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 2179 : 
; 2180 : 	if (replacement->next != NULL)

  00041	8b 4d 10	 mov	 ecx, DWORD PTR _replacement$[ebp]
  00044	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00047	74 0b		 je	 SHORT $LN3@cJSON_Repl

; 2181 : 	{
; 2182 : 		replacement->next->prev = replacement;

  00049	8b 55 10	 mov	 edx, DWORD PTR _replacement$[ebp]
  0004c	8b 02		 mov	 eax, DWORD PTR [edx]
  0004e	8b 4d 10	 mov	 ecx, DWORD PTR _replacement$[ebp]
  00051	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@cJSON_Repl:

; 2183 : 	}
; 2184 : 	if (replacement->prev != NULL)

  00054	8b 55 10	 mov	 edx, DWORD PTR _replacement$[ebp]
  00057	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0005b	74 0b		 je	 SHORT $LN2@cJSON_Repl

; 2185 : 	{
; 2186 : 		replacement->prev->next = replacement;

  0005d	8b 45 10	 mov	 eax, DWORD PTR _replacement$[ebp]
  00060	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00063	8b 55 10	 mov	 edx, DWORD PTR _replacement$[ebp]
  00066	89 11		 mov	 DWORD PTR [ecx], edx
$LN2@cJSON_Repl:

; 2187 : 	}
; 2188 : 	if (parent->child == item)

  00068	8b 45 08	 mov	 eax, DWORD PTR _parent$[ebp]
  0006b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0006e	3b 4d 0c	 cmp	 ecx, DWORD PTR _item$[ebp]
  00071	75 09		 jne	 SHORT $LN1@cJSON_Repl

; 2189 : 	{
; 2190 : 		parent->child = replacement;

  00073	8b 55 08	 mov	 edx, DWORD PTR _parent$[ebp]
  00076	8b 45 10	 mov	 eax, DWORD PTR _replacement$[ebp]
  00079	89 42 08	 mov	 DWORD PTR [edx+8], eax
$LN1@cJSON_Repl:

; 2191 : 	}
; 2192 : 
; 2193 : 	item->next = NULL;

  0007c	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  0007f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 2194 : 	item->prev = NULL;

  00085	8b 55 0c	 mov	 edx, DWORD PTR _item$[ebp]
  00088	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 2195 : 	cJSON_Delete(item);

  0008f	8b 45 0c	 mov	 eax, DWORD PTR _item$[ebp]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 _cJSON_Delete@4

; 2196 : 
; 2197 : 	return true;

  00098	b8 01 00 00 00	 mov	 eax, 1
$LN7@cJSON_Repl:

; 2198 : }

  0009d	5d		 pop	 ebp
  0009e	c2 0c 00	 ret	 12			; 0000000cH
_cJSON_ReplaceItemViaPointer@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_InsertItemInArray@12
_TEXT	SEGMENT
_after_inserted$ = -4					; size = 4
_array$ = 8						; size = 4
_which$ = 12						; size = 4
_newitem$ = 16						; size = 4
_cJSON_InsertItemInArray@12 PROC			; COMDAT

; 2137 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2138 : 	cJSON *after_inserted = NULL;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _after_inserted$[ebp], 0

; 2139 : 
; 2140 : 	if (which < 0)

  0000b	83 7d 0c 00	 cmp	 DWORD PTR _which$[ebp], 0
  0000f	7d 02		 jge	 SHORT $LN4@cJSON_Inse

; 2141 : 	{
; 2142 : 		return;

  00011	eb 69		 jmp	 SHORT $LN5@cJSON_Inse
$LN4@cJSON_Inse:

; 2143 : 	}
; 2144 : 
; 2145 : 	after_inserted = get_array_item(array, (size_t)which);

  00013	8b 45 0c	 mov	 eax, DWORD PTR _which$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _array$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 _get_array_item
  00020	83 c4 08	 add	 esp, 8
  00023	89 45 fc	 mov	 DWORD PTR _after_inserted$[ebp], eax

; 2146 : 	if (after_inserted == NULL)

  00026	83 7d fc 00	 cmp	 DWORD PTR _after_inserted$[ebp], 0
  0002a	75 12		 jne	 SHORT $LN3@cJSON_Inse

; 2147 : 	{
; 2148 : 		add_item_to_array(array, newitem);

  0002c	8b 55 10	 mov	 edx, DWORD PTR _newitem$[ebp]
  0002f	52		 push	 edx
  00030	8b 45 08	 mov	 eax, DWORD PTR _array$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _add_item_to_array
  00039	83 c4 08	 add	 esp, 8

; 2149 : 		return;

  0003c	eb 3e		 jmp	 SHORT $LN5@cJSON_Inse
$LN3@cJSON_Inse:

; 2150 : 	}
; 2151 : 
; 2152 : 	newitem->next = after_inserted;

  0003e	8b 4d 10	 mov	 ecx, DWORD PTR _newitem$[ebp]
  00041	8b 55 fc	 mov	 edx, DWORD PTR _after_inserted$[ebp]
  00044	89 11		 mov	 DWORD PTR [ecx], edx

; 2153 : 	newitem->prev = after_inserted->prev;

  00046	8b 45 10	 mov	 eax, DWORD PTR _newitem$[ebp]
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _after_inserted$[ebp]
  0004c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004f	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 2154 : 	after_inserted->prev = newitem;

  00052	8b 45 fc	 mov	 eax, DWORD PTR _after_inserted$[ebp]
  00055	8b 4d 10	 mov	 ecx, DWORD PTR _newitem$[ebp]
  00058	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 2155 : 	if (after_inserted == array->child)

  0005b	8b 55 08	 mov	 edx, DWORD PTR _array$[ebp]
  0005e	8b 45 fc	 mov	 eax, DWORD PTR _after_inserted$[ebp]
  00061	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00064	75 0b		 jne	 SHORT $LN2@cJSON_Inse

; 2156 : 	{
; 2157 : 		array->child = newitem;

  00066	8b 4d 08	 mov	 ecx, DWORD PTR _array$[ebp]
  00069	8b 55 10	 mov	 edx, DWORD PTR _newitem$[ebp]
  0006c	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 2158 : 	}
; 2159 : 	else

  0006f	eb 0b		 jmp	 SHORT $LN5@cJSON_Inse
$LN2@cJSON_Inse:

; 2160 : 	{
; 2161 : 		newitem->prev->next = newitem;

  00071	8b 45 10	 mov	 eax, DWORD PTR _newitem$[ebp]
  00074	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00077	8b 55 10	 mov	 edx, DWORD PTR _newitem$[ebp]
  0007a	89 11		 mov	 DWORD PTR [ecx], edx
$LN5@cJSON_Inse:

; 2162 : 	}
; 2163 : }

  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c2 0c 00	 ret	 12			; 0000000cH
_cJSON_InsertItemInArray@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_DeleteItemFromObjectCaseSensitive@8
_TEXT	SEGMENT
_object$ = 8						; size = 4
_string$ = 12						; size = 4
_cJSON_DeleteItemFromObjectCaseSensitive@8 PROC		; COMDAT

; 2131 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2132 : 	cJSON_Delete(cJSON_DetachItemFromObjectCaseSensitive(object, string));

  00003	8b 45 0c	 mov	 eax, DWORD PTR _string$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _object$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _cJSON_DetachItemFromObjectCaseSensitive@8
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _cJSON_Delete@4

; 2133 : }

  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
_cJSON_DeleteItemFromObjectCaseSensitive@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_DeleteItemFromObject@8
_TEXT	SEGMENT
_object$ = 8						; size = 4
_string$ = 12						; size = 4
_cJSON_DeleteItemFromObject@8 PROC			; COMDAT

; 2126 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2127 : 	cJSON_Delete(cJSON_DetachItemFromObject(object, string));

  00003	8b 45 0c	 mov	 eax, DWORD PTR _string$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _object$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _cJSON_DetachItemFromObject@8
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _cJSON_Delete@4

; 2128 : }

  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
_cJSON_DeleteItemFromObject@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_DetachItemFromObjectCaseSensitive@8
_TEXT	SEGMENT
_to_detach$ = -4					; size = 4
_object$ = 8						; size = 4
_string$ = 12						; size = 4
_cJSON_DetachItemFromObjectCaseSensitive@8 PROC		; COMDAT

; 2119 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2120 : 	cJSON *to_detach = cJSON_GetObjectItemCaseSensitive(object, string);

  00004	8b 45 0c	 mov	 eax, DWORD PTR _string$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _object$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 _cJSON_GetObjectItemCaseSensitive@8
  00011	89 45 fc	 mov	 DWORD PTR _to_detach$[ebp], eax

; 2121 : 
; 2122 : 	return cJSON_DetachItemViaPointer(object, to_detach);

  00014	8b 55 fc	 mov	 edx, DWORD PTR _to_detach$[ebp]
  00017	52		 push	 edx
  00018	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _cJSON_DetachItemViaPointer@8

; 2123 : }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
_cJSON_DetachItemFromObjectCaseSensitive@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_DetachItemFromObject@8
_TEXT	SEGMENT
_to_detach$ = -4					; size = 4
_object$ = 8						; size = 4
_string$ = 12						; size = 4
_cJSON_DetachItemFromObject@8 PROC			; COMDAT

; 2112 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2113 : 	cJSON *to_detach = cJSON_GetObjectItem(object, string);

  00004	8b 45 0c	 mov	 eax, DWORD PTR _string$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _object$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 _cJSON_GetObjectItem@8
  00011	89 45 fc	 mov	 DWORD PTR _to_detach$[ebp], eax

; 2114 : 
; 2115 : 	return cJSON_DetachItemViaPointer(object, to_detach);

  00014	8b 55 fc	 mov	 edx, DWORD PTR _to_detach$[ebp]
  00017	52		 push	 edx
  00018	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _cJSON_DetachItemViaPointer@8

; 2116 : }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
_cJSON_DetachItemFromObject@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_DeleteItemFromArray@8
_TEXT	SEGMENT
_array$ = 8						; size = 4
_which$ = 12						; size = 4
_cJSON_DeleteItemFromArray@8 PROC			; COMDAT

; 2107 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2108 : 	cJSON_Delete(cJSON_DetachItemFromArray(array, which));

  00003	8b 45 0c	 mov	 eax, DWORD PTR _which$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _array$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _cJSON_DetachItemFromArray@8
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _cJSON_Delete@4

; 2109 : }

  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
_cJSON_DeleteItemFromArray@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_DetachItemFromArray@8
_TEXT	SEGMENT
_array$ = 8						; size = 4
_which$ = 12						; size = 4
_cJSON_DetachItemFromArray@8 PROC			; COMDAT

; 2097 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2098 : 	if (which < 0)

  00003	83 7d 0c 00	 cmp	 DWORD PTR _which$[ebp], 0
  00007	7d 04		 jge	 SHORT $LN1@cJSON_Deta

; 2099 : 	{
; 2100 : 		return NULL;

  00009	33 c0		 xor	 eax, eax
  0000b	eb 1a		 jmp	 SHORT $LN2@cJSON_Deta
$LN1@cJSON_Deta:

; 2101 : 	}
; 2102 : 
; 2103 : 	return cJSON_DetachItemViaPointer(array, get_array_item(array, (size_t)which));

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _which$[ebp]
  00010	50		 push	 eax
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _array$[ebp]
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 _get_array_item
  0001a	83 c4 08	 add	 esp, 8
  0001d	50		 push	 eax
  0001e	8b 55 08	 mov	 edx, DWORD PTR _array$[ebp]
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 _cJSON_DetachItemViaPointer@8
$LN2@cJSON_Deta:

; 2104 : }

  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
_cJSON_DetachItemFromArray@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_DetachItemViaPointer@8
_TEXT	SEGMENT
_parent$ = 8						; size = 4
_item$ = 12						; size = 4
_cJSON_DetachItemViaPointer@8 PROC			; COMDAT

; 2067 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2068 : 	if ((parent == NULL) || (item == NULL))

  00003	83 7d 08 00	 cmp	 DWORD PTR _parent$[ebp], 0
  00007	74 06		 je	 SHORT $LN4@cJSON_Deta
  00009	83 7d 0c 00	 cmp	 DWORD PTR _item$[ebp], 0
  0000d	75 04		 jne	 SHORT $LN5@cJSON_Deta
$LN4@cJSON_Deta:

; 2069 : 	{
; 2070 : 		return NULL;

  0000f	33 c0		 xor	 eax, eax
  00011	eb 58		 jmp	 SHORT $LN6@cJSON_Deta
$LN5@cJSON_Deta:

; 2071 : 	}
; 2072 : 
; 2073 : 	if (item->prev != NULL)

  00013	8b 45 0c	 mov	 eax, DWORD PTR _item$[ebp]
  00016	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0001a	74 0d		 je	 SHORT $LN3@cJSON_Deta

; 2074 : 	{
; 2075 : 		/* not the first element */
; 2076 : 		item->prev->next = item->next;

  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  0001f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00022	8b 45 0c	 mov	 eax, DWORD PTR _item$[ebp]
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	89 0a		 mov	 DWORD PTR [edx], ecx
$LN3@cJSON_Deta:

; 2077 : 	}
; 2078 : 	if (item->next != NULL)

  00029	8b 55 0c	 mov	 edx, DWORD PTR _item$[ebp]
  0002c	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0002f	74 0e		 je	 SHORT $LN2@cJSON_Deta

; 2079 : 	{
; 2080 : 		/* not the last element */
; 2081 : 		item->next->prev = item->prev;

  00031	8b 45 0c	 mov	 eax, DWORD PTR _item$[ebp]
  00034	8b 08		 mov	 ecx, DWORD PTR [eax]
  00036	8b 55 0c	 mov	 edx, DWORD PTR _item$[ebp]
  00039	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003c	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN2@cJSON_Deta:

; 2082 : 	}
; 2083 : 
; 2084 : 	if (item == parent->child)

  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _parent$[ebp]
  00042	8b 55 0c	 mov	 edx, DWORD PTR _item$[ebp]
  00045	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00048	75 0b		 jne	 SHORT $LN1@cJSON_Deta

; 2085 : 	{
; 2086 : 		/* first element */
; 2087 : 		parent->child = item->next;

  0004a	8b 45 08	 mov	 eax, DWORD PTR _parent$[ebp]
  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  00050	8b 11		 mov	 edx, DWORD PTR [ecx]
  00052	89 50 08	 mov	 DWORD PTR [eax+8], edx
$LN1@cJSON_Deta:

; 2088 : 	}
; 2089 : 	/* make sure the detached item doesn't point anywhere anymore */
; 2090 : 	item->prev = NULL;

  00055	8b 45 0c	 mov	 eax, DWORD PTR _item$[ebp]
  00058	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 2091 : 	item->next = NULL;

  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  00062	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 2092 : 
; 2093 : 	return item;

  00068	8b 45 0c	 mov	 eax, DWORD PTR _item$[ebp]
$LN6@cJSON_Deta:

; 2094 : }

  0006b	5d		 pop	 ebp
  0006c	c2 08 00	 ret	 8
_cJSON_DetachItemViaPointer@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_AddItemReferenceToObject@12
_TEXT	SEGMENT
_object$ = 8						; size = 4
_string$ = 12						; size = 4
_item$ = 16						; size = 4
_cJSON_AddItemReferenceToObject@12 PROC			; COMDAT

; 1949 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1950 : 	if ((object == NULL) || (string == NULL))

  00003	83 7d 08 00	 cmp	 DWORD PTR _object$[ebp], 0
  00007	74 06		 je	 SHORT $LN1@cJSON_AddI
  00009	83 7d 0c 00	 cmp	 DWORD PTR _string$[ebp], 0
  0000d	75 02		 jne	 SHORT $LN2@cJSON_AddI
$LN1@cJSON_AddI:

; 1951 : 	{
; 1952 : 		return;

  0000f	eb 29		 jmp	 SHORT $LN3@cJSON_AddI
$LN2@cJSON_AddI:

; 1953 : 	}
; 1954 : 
; 1955 : 	add_item_to_object(object, string, create_reference(item, &global_hooks), &global_hooks, false);

  00011	6a 00		 push	 0
  00013	68 00 00 00 00	 push	 OFFSET _global_hooks
  00018	68 00 00 00 00	 push	 OFFSET _global_hooks
  0001d	8b 45 10	 mov	 eax, DWORD PTR _item$[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 _create_reference
  00026	83 c4 08	 add	 esp, 8
  00029	50		 push	 eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _string$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 55 08	 mov	 edx, DWORD PTR _object$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 _add_item_to_object
  00037	83 c4 14	 add	 esp, 20			; 00000014H
$LN3@cJSON_AddI:

; 1956 : }

  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
_cJSON_AddItemReferenceToObject@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_AddItemReferenceToArray@8
_TEXT	SEGMENT
_array$ = 8						; size = 4
_item$ = 12						; size = 4
_cJSON_AddItemReferenceToArray@8 PROC			; COMDAT

; 1939 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1940 : 	if (array == NULL)

  00003	83 7d 08 00	 cmp	 DWORD PTR _array$[ebp], 0
  00007	75 02		 jne	 SHORT $LN1@cJSON_AddI

; 1941 : 	{
; 1942 : 		return;

  00009	eb 1e		 jmp	 SHORT $LN2@cJSON_AddI
$LN1@cJSON_AddI:

; 1943 : 	}
; 1944 : 
; 1945 : 	add_item_to_array(array, create_reference(item, &global_hooks));

  0000b	68 00 00 00 00	 push	 OFFSET _global_hooks
  00010	8b 45 0c	 mov	 eax, DWORD PTR _item$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _create_reference
  00019	83 c4 08	 add	 esp, 8
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _array$[ebp]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 _add_item_to_array
  00026	83 c4 08	 add	 esp, 8
$LN2@cJSON_AddI:

; 1946 : }

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
_cJSON_AddItemReferenceToArray@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_AddItemToObjectCS@12
_TEXT	SEGMENT
_object$ = 8						; size = 4
_string$ = 12						; size = 4
_item$ = 16						; size = 4
_cJSON_AddItemToObjectCS@12 PROC			; COMDAT

; 1934 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1935 : 	add_item_to_object(object, string, item, &global_hooks, true);

  00003	6a 01		 push	 1
  00005	68 00 00 00 00	 push	 OFFSET _global_hooks
  0000a	8b 45 10	 mov	 eax, DWORD PTR _item$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR _string$[ebp]
  00011	51		 push	 ecx
  00012	8b 55 08	 mov	 edx, DWORD PTR _object$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 _add_item_to_object
  0001b	83 c4 14	 add	 esp, 20			; 00000014H

; 1936 : }

  0001e	5d		 pop	 ebp
  0001f	c2 0c 00	 ret	 12			; 0000000cH
_cJSON_AddItemToObjectCS@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_AddItemToObject@12
_TEXT	SEGMENT
_object$ = 8						; size = 4
_string$ = 12						; size = 4
_item$ = 16						; size = 4
_cJSON_AddItemToObject@12 PROC				; COMDAT

; 1928 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1929 : 	add_item_to_object(object, string, item, &global_hooks, false);

  00003	6a 00		 push	 0
  00005	68 00 00 00 00	 push	 OFFSET _global_hooks
  0000a	8b 45 10	 mov	 eax, DWORD PTR _item$[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR _string$[ebp]
  00011	51		 push	 ecx
  00012	8b 55 08	 mov	 edx, DWORD PTR _object$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 _add_item_to_object
  0001b	83 c4 14	 add	 esp, 20			; 00000014H

; 1930 : }

  0001e	5d		 pop	 ebp
  0001f	c2 0c 00	 ret	 12			; 0000000cH
_cJSON_AddItemToObject@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_AddItemToArray@8
_TEXT	SEGMENT
_array$ = 8						; size = 4
_item$ = 12						; size = 4
_cJSON_AddItemToArray@8 PROC				; COMDAT

; 1870 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1871 : 	add_item_to_array(array, item);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _item$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _array$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _add_item_to_array
  00010	83 c4 08	 add	 esp, 8

; 1872 : }

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
_cJSON_AddItemToArray@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateStringArray@8
_TEXT	SEGMENT
_p$ = -16						; size = 4
_a$ = -12						; size = 4
_n$ = -8						; size = 4
_i$ = -4						; size = 4
_strings$ = 8						; size = 4
_count$ = 12						; size = 4
_cJSON_CreateStringArray@8 PROC				; COMDAT

; 2509 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 2510 : 	size_t i = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 2511 : 	cJSON *n = NULL;

  0000d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0

; 2512 : 	cJSON *p = NULL;

  00014	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], 0

; 2513 : 	cJSON *a = NULL;

  0001b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _a$[ebp], 0

; 2514 : 
; 2515 : 	if ((count < 0) || (strings == NULL))

  00022	83 7d 0c 00	 cmp	 DWORD PTR _count$[ebp], 0
  00026	7c 06		 jl	 SHORT $LN7@cJSON_Crea
  00028	83 7d 08 00	 cmp	 DWORD PTR _strings$[ebp], 0
  0002c	75 04		 jne	 SHORT $LN8@cJSON_Crea
$LN7@cJSON_Crea:

; 2516 : 	{
; 2517 : 		return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	eb 79		 jmp	 SHORT $LN9@cJSON_Crea
$LN8@cJSON_Crea:

; 2518 : 	}
; 2519 : 
; 2520 : 	a = cJSON_CreateArray();

  00032	e8 00 00 00 00	 call	 _cJSON_CreateArray@0
  00037	89 45 f4	 mov	 DWORD PTR _a$[ebp], eax

; 2521 : 
; 2522 : 	for (i = 0; a && (i < (size_t)count); i++)

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00041	eb 09		 jmp	 SHORT $LN6@cJSON_Crea
$LN5@cJSON_Crea:
  00043	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00046	83 c0 01	 add	 eax, 1
  00049	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN6@cJSON_Crea:
  0004c	83 7d f4 00	 cmp	 DWORD PTR _a$[ebp], 0
  00050	74 56		 je	 SHORT $LN4@cJSON_Crea
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00055	3b 4d 0c	 cmp	 ecx, DWORD PTR _count$[ebp]
  00058	73 4e		 jae	 SHORT $LN4@cJSON_Crea

; 2523 : 	{
; 2524 : 		n = cJSON_CreateString(strings[i]);

  0005a	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0005d	8b 45 08	 mov	 eax, DWORD PTR _strings$[ebp]
  00060	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 _cJSON_CreateString@4
  00069	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax

; 2525 : 		if (!n)

  0006c	83 7d f8 00	 cmp	 DWORD PTR _n$[ebp], 0
  00070	75 0d		 jne	 SHORT $LN3@cJSON_Crea

; 2526 : 		{
; 2527 : 			cJSON_Delete(a);

  00072	8b 55 f4	 mov	 edx, DWORD PTR _a$[ebp]
  00075	52		 push	 edx
  00076	e8 00 00 00 00	 call	 _cJSON_Delete@4

; 2528 : 			return NULL;

  0007b	33 c0		 xor	 eax, eax
  0007d	eb 2c		 jmp	 SHORT $LN9@cJSON_Crea
$LN3@cJSON_Crea:

; 2529 : 		}
; 2530 : 		if (!i)

  0007f	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00083	75 0b		 jne	 SHORT $LN2@cJSON_Crea

; 2531 : 		{
; 2532 : 			a->child = n;

  00085	8b 45 f4	 mov	 eax, DWORD PTR _a$[ebp]
  00088	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  0008b	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 2533 : 		}
; 2534 : 		else

  0008e	eb 10		 jmp	 SHORT $LN1@cJSON_Crea
$LN2@cJSON_Crea:

; 2535 : 		{
; 2536 : 			suffix_object(p, n);

  00090	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  00093	52		 push	 edx
  00094	8b 45 f0	 mov	 eax, DWORD PTR _p$[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 _suffix_object
  0009d	83 c4 08	 add	 esp, 8
$LN1@cJSON_Crea:

; 2537 : 		}
; 2538 : 		p = n;

  000a0	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  000a3	89 4d f0	 mov	 DWORD PTR _p$[ebp], ecx

; 2539 : 	}

  000a6	eb 9b		 jmp	 SHORT $LN5@cJSON_Crea
$LN4@cJSON_Crea:

; 2540 : 
; 2541 : 	return a;

  000a8	8b 45 f4	 mov	 eax, DWORD PTR _a$[ebp]
$LN9@cJSON_Crea:

; 2542 : }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c2 08 00	 ret	 8
_cJSON_CreateStringArray@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateDoubleArray@8
_TEXT	SEGMENT
_p$ = -16						; size = 4
_a$ = -12						; size = 4
_n$ = -8						; size = 4
_i$ = -4						; size = 4
_numbers$ = 8						; size = 4
_count$ = 12						; size = 4
_cJSON_CreateDoubleArray@8 PROC				; COMDAT

; 2473 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 2474 : 	size_t i = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 2475 : 	cJSON *n = NULL;

  0000d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0

; 2476 : 	cJSON *p = NULL;

  00014	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], 0

; 2477 : 	cJSON *a = NULL;

  0001b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _a$[ebp], 0

; 2478 : 
; 2479 : 	if ((count < 0) || (numbers == NULL))

  00022	83 7d 0c 00	 cmp	 DWORD PTR _count$[ebp], 0
  00026	7c 06		 jl	 SHORT $LN7@cJSON_Crea
  00028	83 7d 08 00	 cmp	 DWORD PTR _numbers$[ebp], 0
  0002c	75 04		 jne	 SHORT $LN8@cJSON_Crea
$LN7@cJSON_Crea:

; 2480 : 	{
; 2481 : 		return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	eb 7e		 jmp	 SHORT $LN9@cJSON_Crea
$LN8@cJSON_Crea:

; 2482 : 	}
; 2483 : 
; 2484 : 	a = cJSON_CreateArray();

  00032	e8 00 00 00 00	 call	 _cJSON_CreateArray@0
  00037	89 45 f4	 mov	 DWORD PTR _a$[ebp], eax

; 2485 : 
; 2486 : 	for (i = 0; a && (i < (size_t)count); i++)

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00041	eb 09		 jmp	 SHORT $LN6@cJSON_Crea
$LN5@cJSON_Crea:
  00043	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00046	83 c0 01	 add	 eax, 1
  00049	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN6@cJSON_Crea:
  0004c	83 7d f4 00	 cmp	 DWORD PTR _a$[ebp], 0
  00050	74 5b		 je	 SHORT $LN4@cJSON_Crea
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00055	3b 4d 0c	 cmp	 ecx, DWORD PTR _count$[ebp]
  00058	73 53		 jae	 SHORT $LN4@cJSON_Crea

; 2487 : 	{
; 2488 : 		n = cJSON_CreateNumber(numbers[i]);

  0005a	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0005d	8b 45 08	 mov	 eax, DWORD PTR _numbers$[ebp]
  00060	83 ec 08	 sub	 esp, 8
  00063	dd 04 d0	 fld	 QWORD PTR [eax+edx*8]
  00066	dd 1c 24	 fstp	 QWORD PTR [esp]
  00069	e8 00 00 00 00	 call	 _cJSON_CreateNumber@8
  0006e	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax

; 2489 : 		if (!n)

  00071	83 7d f8 00	 cmp	 DWORD PTR _n$[ebp], 0
  00075	75 0d		 jne	 SHORT $LN3@cJSON_Crea

; 2490 : 		{
; 2491 : 			cJSON_Delete(a);

  00077	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  0007a	51		 push	 ecx
  0007b	e8 00 00 00 00	 call	 _cJSON_Delete@4

; 2492 : 			return NULL;

  00080	33 c0		 xor	 eax, eax
  00082	eb 2c		 jmp	 SHORT $LN9@cJSON_Crea
$LN3@cJSON_Crea:

; 2493 : 		}
; 2494 : 		if (!i)

  00084	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00088	75 0b		 jne	 SHORT $LN2@cJSON_Crea

; 2495 : 		{
; 2496 : 			a->child = n;

  0008a	8b 55 f4	 mov	 edx, DWORD PTR _a$[ebp]
  0008d	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00090	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 2497 : 		}
; 2498 : 		else

  00093	eb 10		 jmp	 SHORT $LN1@cJSON_Crea
$LN2@cJSON_Crea:

; 2499 : 		{
; 2500 : 			suffix_object(p, n);

  00095	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  00098	51		 push	 ecx
  00099	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  0009c	52		 push	 edx
  0009d	e8 00 00 00 00	 call	 _suffix_object
  000a2	83 c4 08	 add	 esp, 8
$LN1@cJSON_Crea:

; 2501 : 		}
; 2502 : 		p = n;

  000a5	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000a8	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax

; 2503 : 	}

  000ab	eb 96		 jmp	 SHORT $LN5@cJSON_Crea
$LN4@cJSON_Crea:

; 2504 : 
; 2505 : 	return a;

  000ad	8b 45 f4	 mov	 eax, DWORD PTR _a$[ebp]
$LN9@cJSON_Crea:

; 2506 : }

  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 08 00	 ret	 8
_cJSON_CreateDoubleArray@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateFloatArray@8
_TEXT	SEGMENT
_p$ = -16						; size = 4
_a$ = -12						; size = 4
_n$ = -8						; size = 4
_i$ = -4						; size = 4
_numbers$ = 8						; size = 4
_count$ = 12						; size = 4
_cJSON_CreateFloatArray@8 PROC				; COMDAT

; 2437 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 2438 : 	size_t i = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 2439 : 	cJSON *n = NULL;

  0000d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0

; 2440 : 	cJSON *p = NULL;

  00014	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], 0

; 2441 : 	cJSON *a = NULL;

  0001b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _a$[ebp], 0

; 2442 : 
; 2443 : 	if ((count < 0) || (numbers == NULL))

  00022	83 7d 0c 00	 cmp	 DWORD PTR _count$[ebp], 0
  00026	7c 06		 jl	 SHORT $LN7@cJSON_Crea
  00028	83 7d 08 00	 cmp	 DWORD PTR _numbers$[ebp], 0
  0002c	75 04		 jne	 SHORT $LN8@cJSON_Crea
$LN7@cJSON_Crea:

; 2444 : 	{
; 2445 : 		return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	eb 7e		 jmp	 SHORT $LN9@cJSON_Crea
$LN8@cJSON_Crea:

; 2446 : 	}
; 2447 : 
; 2448 : 	a = cJSON_CreateArray();

  00032	e8 00 00 00 00	 call	 _cJSON_CreateArray@0
  00037	89 45 f4	 mov	 DWORD PTR _a$[ebp], eax

; 2449 : 
; 2450 : 	for (i = 0; a && (i < (size_t)count); i++)

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00041	eb 09		 jmp	 SHORT $LN6@cJSON_Crea
$LN5@cJSON_Crea:
  00043	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00046	83 c0 01	 add	 eax, 1
  00049	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN6@cJSON_Crea:
  0004c	83 7d f4 00	 cmp	 DWORD PTR _a$[ebp], 0
  00050	74 5b		 je	 SHORT $LN4@cJSON_Crea
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00055	3b 4d 0c	 cmp	 ecx, DWORD PTR _count$[ebp]
  00058	73 53		 jae	 SHORT $LN4@cJSON_Crea

; 2451 : 	{
; 2452 : 		n = cJSON_CreateNumber((double)numbers[i]);

  0005a	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0005d	8b 45 08	 mov	 eax, DWORD PTR _numbers$[ebp]
  00060	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  00063	83 ec 08	 sub	 esp, 8
  00066	dd 1c 24	 fstp	 QWORD PTR [esp]
  00069	e8 00 00 00 00	 call	 _cJSON_CreateNumber@8
  0006e	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax

; 2453 : 		if (!n)

  00071	83 7d f8 00	 cmp	 DWORD PTR _n$[ebp], 0
  00075	75 0d		 jne	 SHORT $LN3@cJSON_Crea

; 2454 : 		{
; 2455 : 			cJSON_Delete(a);

  00077	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  0007a	51		 push	 ecx
  0007b	e8 00 00 00 00	 call	 _cJSON_Delete@4

; 2456 : 			return NULL;

  00080	33 c0		 xor	 eax, eax
  00082	eb 2c		 jmp	 SHORT $LN9@cJSON_Crea
$LN3@cJSON_Crea:

; 2457 : 		}
; 2458 : 		if (!i)

  00084	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00088	75 0b		 jne	 SHORT $LN2@cJSON_Crea

; 2459 : 		{
; 2460 : 			a->child = n;

  0008a	8b 55 f4	 mov	 edx, DWORD PTR _a$[ebp]
  0008d	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00090	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 2461 : 		}
; 2462 : 		else

  00093	eb 10		 jmp	 SHORT $LN1@cJSON_Crea
$LN2@cJSON_Crea:

; 2463 : 		{
; 2464 : 			suffix_object(p, n);

  00095	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  00098	51		 push	 ecx
  00099	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  0009c	52		 push	 edx
  0009d	e8 00 00 00 00	 call	 _suffix_object
  000a2	83 c4 08	 add	 esp, 8
$LN1@cJSON_Crea:

; 2465 : 		}
; 2466 : 		p = n;

  000a5	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000a8	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax

; 2467 : 	}

  000ab	eb 96		 jmp	 SHORT $LN5@cJSON_Crea
$LN4@cJSON_Crea:

; 2468 : 
; 2469 : 	return a;

  000ad	8b 45 f4	 mov	 eax, DWORD PTR _a$[ebp]
$LN9@cJSON_Crea:

; 2470 : }

  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 08 00	 ret	 8
_cJSON_CreateFloatArray@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateIntArray@8
_TEXT	SEGMENT
tv87 = -24						; size = 8
_p$ = -16						; size = 4
_a$ = -12						; size = 4
_n$ = -8						; size = 4
_i$ = -4						; size = 4
_numbers$ = 8						; size = 4
_count$ = 12						; size = 4
_cJSON_CreateIntArray@8 PROC				; COMDAT

; 2402 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 2403 : 	size_t i = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 2404 : 	cJSON *n = NULL;

  0000d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0

; 2405 : 	cJSON *p = NULL;

  00014	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], 0

; 2406 : 	cJSON *a = NULL;

  0001b	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _a$[ebp], 0

; 2407 : 
; 2408 : 	if ((count < 0) || (numbers == NULL))

  00022	83 7d 0c 00	 cmp	 DWORD PTR _count$[ebp], 0
  00026	7c 06		 jl	 SHORT $LN7@cJSON_Crea
  00028	83 7d 08 00	 cmp	 DWORD PTR _numbers$[ebp], 0
  0002c	75 07		 jne	 SHORT $LN8@cJSON_Crea
$LN7@cJSON_Crea:

; 2409 : 	{
; 2410 : 		return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	e9 84 00 00 00	 jmp	 $LN9@cJSON_Crea
$LN8@cJSON_Crea:

; 2411 : 	}
; 2412 : 
; 2413 : 	a = cJSON_CreateArray();

  00035	e8 00 00 00 00	 call	 _cJSON_CreateArray@0
  0003a	89 45 f4	 mov	 DWORD PTR _a$[ebp], eax

; 2414 : 	for (i = 0; a && (i < (size_t)count); i++)

  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00044	eb 09		 jmp	 SHORT $LN6@cJSON_Crea
$LN5@cJSON_Crea:
  00046	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00049	83 c0 01	 add	 eax, 1
  0004c	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN6@cJSON_Crea:
  0004f	83 7d f4 00	 cmp	 DWORD PTR _a$[ebp], 0
  00053	74 61		 je	 SHORT $LN4@cJSON_Crea
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00058	3b 4d 0c	 cmp	 ecx, DWORD PTR _count$[ebp]
  0005b	73 59		 jae	 SHORT $LN4@cJSON_Crea

; 2415 : 	{
; 2416 : 		n = cJSON_CreateNumber(numbers[i]);

  0005d	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00060	8b 45 08	 mov	 eax, DWORD PTR _numbers$[ebp]
  00063	db 04 90	 fild	 DWORD PTR [eax+edx*4]
  00066	dd 5d e8	 fstp	 QWORD PTR tv87[ebp]
  00069	dd 45 e8	 fld	 QWORD PTR tv87[ebp]
  0006c	83 ec 08	 sub	 esp, 8
  0006f	dd 1c 24	 fstp	 QWORD PTR [esp]
  00072	e8 00 00 00 00	 call	 _cJSON_CreateNumber@8
  00077	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax

; 2417 : 		if (!n)

  0007a	83 7d f8 00	 cmp	 DWORD PTR _n$[ebp], 0
  0007e	75 0d		 jne	 SHORT $LN3@cJSON_Crea

; 2418 : 		{
; 2419 : 			cJSON_Delete(a);

  00080	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  00083	51		 push	 ecx
  00084	e8 00 00 00 00	 call	 _cJSON_Delete@4

; 2420 : 			return NULL;

  00089	33 c0		 xor	 eax, eax
  0008b	eb 2c		 jmp	 SHORT $LN9@cJSON_Crea
$LN3@cJSON_Crea:

; 2421 : 		}
; 2422 : 		if (!i)

  0008d	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00091	75 0b		 jne	 SHORT $LN2@cJSON_Crea

; 2423 : 		{
; 2424 : 			a->child = n;

  00093	8b 55 f4	 mov	 edx, DWORD PTR _a$[ebp]
  00096	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00099	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 2425 : 		}
; 2426 : 		else

  0009c	eb 10		 jmp	 SHORT $LN1@cJSON_Crea
$LN2@cJSON_Crea:

; 2427 : 		{
; 2428 : 			suffix_object(p, n);

  0009e	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  000a1	51		 push	 ecx
  000a2	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 _suffix_object
  000ab	83 c4 08	 add	 esp, 8
$LN1@cJSON_Crea:

; 2429 : 		}
; 2430 : 		p = n;

  000ae	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  000b1	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax

; 2431 : 	}

  000b4	eb 90		 jmp	 SHORT $LN5@cJSON_Crea
$LN4@cJSON_Crea:

; 2432 : 
; 2433 : 	return a;

  000b6	8b 45 f4	 mov	 eax, DWORD PTR _a$[ebp]
$LN9@cJSON_Crea:

; 2434 : }

  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c2 08 00	 ret	 8
_cJSON_CreateIntArray@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateArrayReference@4
_TEXT	SEGMENT
_item$ = -4						; size = 4
_child$ = 8						; size = 4
_cJSON_CreateArrayReference@4 PROC			; COMDAT

; 2351 : CJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2352 : 	cJSON *item = cJSON_New_Item(&global_hooks);

  00004	68 00 00 00 00	 push	 OFFSET _global_hooks
  00009	e8 00 00 00 00	 call	 _cJSON_New_Item
  0000e	83 c4 04	 add	 esp, 4
  00011	89 45 fc	 mov	 DWORD PTR _item$[ebp], eax

; 2353 : 	if (item != NULL) {

  00014	83 7d fc 00	 cmp	 DWORD PTR _item$[ebp], 0
  00018	74 1c		 je	 SHORT $LN1@cJSON_Crea

; 2354 : 		item->type = cJSON_Array | cJSON_IsReference;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  0001d	c7 40 0c 20 01
	00 00		 mov	 DWORD PTR [eax+12], 288	; 00000120H

; 2355 : 		item->child = (cJSON*)cast_away_const(child);

  00024	8b 4d 08	 mov	 ecx, DWORD PTR _child$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _cast_away_const
  0002d	83 c4 04	 add	 esp, 4
  00030	8b 55 fc	 mov	 edx, DWORD PTR _item$[ebp]
  00033	89 42 08	 mov	 DWORD PTR [edx+8], eax
$LN1@cJSON_Crea:

; 2356 : 	}
; 2357 : 
; 2358 : 	return item;

  00036	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]

; 2359 : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
_cJSON_CreateArrayReference@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateObjectReference@4
_TEXT	SEGMENT
_item$ = -4						; size = 4
_child$ = 8						; size = 4
_cJSON_CreateObjectReference@4 PROC			; COMDAT

; 2341 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2342 : 	cJSON *item = cJSON_New_Item(&global_hooks);

  00004	68 00 00 00 00	 push	 OFFSET _global_hooks
  00009	e8 00 00 00 00	 call	 _cJSON_New_Item
  0000e	83 c4 04	 add	 esp, 4
  00011	89 45 fc	 mov	 DWORD PTR _item$[ebp], eax

; 2343 : 	if (item != NULL) {

  00014	83 7d fc 00	 cmp	 DWORD PTR _item$[ebp], 0
  00018	74 1c		 je	 SHORT $LN1@cJSON_Crea

; 2344 : 		item->type = cJSON_Object | cJSON_IsReference;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  0001d	c7 40 0c 40 01
	00 00		 mov	 DWORD PTR [eax+12], 320	; 00000140H

; 2345 : 		item->child = (cJSON*)cast_away_const(child);

  00024	8b 4d 08	 mov	 ecx, DWORD PTR _child$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _cast_away_const
  0002d	83 c4 04	 add	 esp, 4
  00030	8b 55 fc	 mov	 edx, DWORD PTR _item$[ebp]
  00033	89 42 08	 mov	 DWORD PTR [edx+8], eax
$LN1@cJSON_Crea:

; 2346 : 	}
; 2347 : 
; 2348 : 	return item;

  00036	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]

; 2349 : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
_cJSON_CreateObjectReference@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateStringReference@4
_TEXT	SEGMENT
_item$ = -4						; size = 4
_string$ = 8						; size = 4
_cJSON_CreateStringReference@4 PROC			; COMDAT

; 2329 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2330 : 	cJSON *item = cJSON_New_Item(&global_hooks);

  00004	68 00 00 00 00	 push	 OFFSET _global_hooks
  00009	e8 00 00 00 00	 call	 _cJSON_New_Item
  0000e	83 c4 04	 add	 esp, 4
  00011	89 45 fc	 mov	 DWORD PTR _item$[ebp], eax

; 2331 : 	if (item != NULL)

  00014	83 7d fc 00	 cmp	 DWORD PTR _item$[ebp], 0
  00018	74 1c		 je	 SHORT $LN1@cJSON_Crea

; 2332 : 	{
; 2333 : 		item->type = cJSON_String | cJSON_IsReference;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  0001d	c7 40 0c 10 01
	00 00		 mov	 DWORD PTR [eax+12], 272	; 00000110H

; 2334 : 		item->valuestring = (char*)cast_away_const(string);

  00024	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _cast_away_const
  0002d	83 c4 04	 add	 esp, 4
  00030	8b 55 fc	 mov	 edx, DWORD PTR _item$[ebp]
  00033	89 42 10	 mov	 DWORD PTR [edx+16], eax
$LN1@cJSON_Crea:

; 2335 : 	}
; 2336 : 
; 2337 : 	return item;

  00036	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]

; 2338 : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
_cJSON_CreateStringReference@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateObject@0
_TEXT	SEGMENT
_item$ = -4						; size = 4
_cJSON_CreateObject@0 PROC				; COMDAT

; 2390 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2391 : 	cJSON *item = cJSON_New_Item(&global_hooks);

  00004	68 00 00 00 00	 push	 OFFSET _global_hooks
  00009	e8 00 00 00 00	 call	 _cJSON_New_Item
  0000e	83 c4 04	 add	 esp, 4
  00011	89 45 fc	 mov	 DWORD PTR _item$[ebp], eax

; 2392 : 	if (item)

  00014	83 7d fc 00	 cmp	 DWORD PTR _item$[ebp], 0
  00018	74 0a		 je	 SHORT $LN1@cJSON_Crea

; 2393 : 	{
; 2394 : 		item->type = cJSON_Object;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  0001d	c7 40 0c 40 00
	00 00		 mov	 DWORD PTR [eax+12], 64	; 00000040H
$LN1@cJSON_Crea:

; 2395 : 	}
; 2396 : 
; 2397 : 	return item;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]

; 2398 : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_cJSON_CreateObject@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateArray@0
_TEXT	SEGMENT
_item$ = -4						; size = 4
_cJSON_CreateArray@0 PROC				; COMDAT

; 2379 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2380 : 	cJSON *item = cJSON_New_Item(&global_hooks);

  00004	68 00 00 00 00	 push	 OFFSET _global_hooks
  00009	e8 00 00 00 00	 call	 _cJSON_New_Item
  0000e	83 c4 04	 add	 esp, 4
  00011	89 45 fc	 mov	 DWORD PTR _item$[ebp], eax

; 2381 : 	if (item)

  00014	83 7d fc 00	 cmp	 DWORD PTR _item$[ebp], 0
  00018	74 0a		 je	 SHORT $LN1@cJSON_Crea

; 2382 : 	{
; 2383 : 		item->type = cJSON_Array;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  0001d	c7 40 0c 20 00
	00 00		 mov	 DWORD PTR [eax+12], 32	; 00000020H
$LN1@cJSON_Crea:

; 2384 : 	}
; 2385 : 
; 2386 : 	return item;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]

; 2387 : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_cJSON_CreateArray@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateRaw@4
_TEXT	SEGMENT
_item$ = -4						; size = 4
_raw$ = 8						; size = 4
_cJSON_CreateRaw@4 PROC					; COMDAT

; 2362 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2363 : 	cJSON *item = cJSON_New_Item(&global_hooks);

  00004	68 00 00 00 00	 push	 OFFSET _global_hooks
  00009	e8 00 00 00 00	 call	 _cJSON_New_Item
  0000e	83 c4 04	 add	 esp, 4
  00011	89 45 fc	 mov	 DWORD PTR _item$[ebp], eax

; 2364 : 	if (item)

  00014	83 7d fc 00	 cmp	 DWORD PTR _item$[ebp], 0
  00018	74 37		 je	 SHORT $LN2@cJSON_Crea

; 2365 : 	{
; 2366 : 		item->type = cJSON_Raw;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  0001d	c7 40 0c 80 00
	00 00		 mov	 DWORD PTR [eax+12], 128	; 00000080H

; 2367 : 		item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw, &global_hooks);

  00024	68 00 00 00 00	 push	 OFFSET _global_hooks
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _raw$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 _cJSON_strdup
  00032	83 c4 08	 add	 esp, 8
  00035	8b 55 fc	 mov	 edx, DWORD PTR _item$[ebp]
  00038	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 2368 : 		if (!item->valuestring)

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  0003e	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00042	75 0d		 jne	 SHORT $LN2@cJSON_Crea

; 2369 : 		{
; 2370 : 			cJSON_Delete(item);

  00044	8b 4d fc	 mov	 ecx, DWORD PTR _item$[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 _cJSON_Delete@4

; 2371 : 			return NULL;

  0004d	33 c0		 xor	 eax, eax
  0004f	eb 03		 jmp	 SHORT $LN3@cJSON_Crea
$LN2@cJSON_Crea:

; 2372 : 		}
; 2373 : 	}
; 2374 : 
; 2375 : 	return item;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
$LN3@cJSON_Crea:

; 2376 : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
_cJSON_CreateRaw@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateString@4
_TEXT	SEGMENT
_item$ = -4						; size = 4
_string$ = 8						; size = 4
_cJSON_CreateString@4 PROC				; COMDAT

; 2312 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2313 : 	cJSON *item = cJSON_New_Item(&global_hooks);

  00004	68 00 00 00 00	 push	 OFFSET _global_hooks
  00009	e8 00 00 00 00	 call	 _cJSON_New_Item
  0000e	83 c4 04	 add	 esp, 4
  00011	89 45 fc	 mov	 DWORD PTR _item$[ebp], eax

; 2314 : 	if (item)

  00014	83 7d fc 00	 cmp	 DWORD PTR _item$[ebp], 0
  00018	74 37		 je	 SHORT $LN2@cJSON_Crea

; 2315 : 	{
; 2316 : 		item->type = cJSON_String;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  0001d	c7 40 0c 10 00
	00 00		 mov	 DWORD PTR [eax+12], 16	; 00000010H

; 2317 : 		item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);

  00024	68 00 00 00 00	 push	 OFFSET _global_hooks
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 _cJSON_strdup
  00032	83 c4 08	 add	 esp, 8
  00035	8b 55 fc	 mov	 edx, DWORD PTR _item$[ebp]
  00038	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 2318 : 		if (!item->valuestring)

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  0003e	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00042	75 0d		 jne	 SHORT $LN2@cJSON_Crea

; 2319 : 		{
; 2320 : 			cJSON_Delete(item);

  00044	8b 4d fc	 mov	 ecx, DWORD PTR _item$[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 _cJSON_Delete@4

; 2321 : 			return NULL;

  0004d	33 c0		 xor	 eax, eax
  0004f	eb 03		 jmp	 SHORT $LN3@cJSON_Crea
$LN2@cJSON_Crea:

; 2322 : 		}
; 2323 : 	}
; 2324 : 
; 2325 : 	return item;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
$LN3@cJSON_Crea:

; 2326 : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
_cJSON_CreateString@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateNumber@8
_TEXT	SEGMENT
_item$ = -4						; size = 4
_num$ = 8						; size = 8
_cJSON_CreateNumber@8 PROC				; COMDAT

; 2286 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2287 : 	cJSON *item = cJSON_New_Item(&global_hooks);

  00004	68 00 00 00 00	 push	 OFFSET _global_hooks
  00009	e8 00 00 00 00	 call	 _cJSON_New_Item
  0000e	83 c4 04	 add	 esp, 4
  00011	89 45 fc	 mov	 DWORD PTR _item$[ebp], eax

; 2288 : 	if (item)

  00014	83 7d fc 00	 cmp	 DWORD PTR _item$[ebp], 0
  00018	74 59		 je	 SHORT $LN1@cJSON_Crea

; 2289 : 	{
; 2290 : 		item->type = cJSON_Number;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  0001d	c7 40 0c 08 00
	00 00		 mov	 DWORD PTR [eax+12], 8

; 2291 : 		item->valuedouble = num;

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _item$[ebp]
  00027	dd 45 08	 fld	 QWORD PTR _num$[ebp]
  0002a	dd 59 18	 fstp	 QWORD PTR [ecx+24]

; 2292 : 
; 2293 : 		/* use saturation in case of overflow */
; 2294 : 		if (num >= INT_MAX)

  0002d	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@41dfffffffc00000
  00033	dc 5d 08	 fcomp	 QWORD PTR _num$[ebp]
  00036	df e0		 fnstsw	 ax
  00038	f6 c4 41	 test	 ah, 65			; 00000041H
  0003b	7a 0c		 jp	 SHORT $LN4@cJSON_Crea

; 2295 : 		{
; 2296 : 			item->valueint = INT_MAX;

  0003d	8b 55 fc	 mov	 edx, DWORD PTR _item$[ebp]
  00040	c7 42 14 ff ff
	ff 7f		 mov	 DWORD PTR [edx+20], 2147483647 ; 7fffffffH
  00047	eb 2a		 jmp	 SHORT $LN1@cJSON_Crea
$LN4@cJSON_Crea:

; 2297 : 		}
; 2298 : 		else if (num <= INT_MIN)

  00049	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@c1e0000000000000
  0004f	dc 5d 08	 fcomp	 QWORD PTR _num$[ebp]
  00052	df e0		 fnstsw	 ax
  00054	f6 c4 01	 test	 ah, 1
  00057	75 0c		 jne	 SHORT $LN2@cJSON_Crea

; 2299 : 		{
; 2300 : 			item->valueint = INT_MIN;

  00059	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  0005c	c7 40 14 00 00
	00 80		 mov	 DWORD PTR [eax+20], -2147483648 ; 80000000H

; 2301 : 		}
; 2302 : 		else

  00063	eb 0e		 jmp	 SHORT $LN1@cJSON_Crea
$LN2@cJSON_Crea:

; 2303 : 		{
; 2304 : 			item->valueint = (int)num;

  00065	dd 45 08	 fld	 QWORD PTR _num$[ebp]
  00068	e8 00 00 00 00	 call	 __ftol2_sse
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR _item$[ebp]
  00070	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$LN1@cJSON_Crea:

; 2305 : 		}
; 2306 : 	}
; 2307 : 
; 2308 : 	return item;

  00073	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]

; 2309 : }

  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c2 08 00	 ret	 8
_cJSON_CreateNumber@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateBool@4
_TEXT	SEGMENT
tv69 = -8						; size = 4
_item$ = -4						; size = 4
_b$ = 8							; size = 4
_cJSON_CreateBool@4 PROC				; COMDAT

; 2275 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2276 : 	cJSON *item = cJSON_New_Item(&global_hooks);

  00006	68 00 00 00 00	 push	 OFFSET _global_hooks
  0000b	e8 00 00 00 00	 call	 _cJSON_New_Item
  00010	83 c4 04	 add	 esp, 4
  00013	89 45 fc	 mov	 DWORD PTR _item$[ebp], eax

; 2277 : 	if (item)

  00016	83 7d fc 00	 cmp	 DWORD PTR _item$[ebp], 0
  0001a	74 1f		 je	 SHORT $LN1@cJSON_Crea

; 2278 : 	{
; 2279 : 		item->type = b ? cJSON_True : cJSON_False;

  0001c	83 7d 08 00	 cmp	 DWORD PTR _b$[ebp], 0
  00020	74 09		 je	 SHORT $LN4@cJSON_Crea
  00022	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR tv69[ebp], 2
  00029	eb 07		 jmp	 SHORT $LN5@cJSON_Crea
$LN4@cJSON_Crea:
  0002b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
$LN5@cJSON_Crea:
  00032	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  00035	8b 4d f8	 mov	 ecx, DWORD PTR tv69[ebp]
  00038	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
$LN1@cJSON_Crea:

; 2280 : 	}
; 2281 : 
; 2282 : 	return item;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]

; 2283 : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
_cJSON_CreateBool@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateFalse@0
_TEXT	SEGMENT
_item$ = -4						; size = 4
_cJSON_CreateFalse@0 PROC				; COMDAT

; 2264 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2265 : 	cJSON *item = cJSON_New_Item(&global_hooks);

  00004	68 00 00 00 00	 push	 OFFSET _global_hooks
  00009	e8 00 00 00 00	 call	 _cJSON_New_Item
  0000e	83 c4 04	 add	 esp, 4
  00011	89 45 fc	 mov	 DWORD PTR _item$[ebp], eax

; 2266 : 	if (item)

  00014	83 7d fc 00	 cmp	 DWORD PTR _item$[ebp], 0
  00018	74 0a		 je	 SHORT $LN1@cJSON_Crea

; 2267 : 	{
; 2268 : 		item->type = cJSON_False;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  0001d	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [eax+12], 1
$LN1@cJSON_Crea:

; 2269 : 	}
; 2270 : 
; 2271 : 	return item;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]

; 2272 : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_cJSON_CreateFalse@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateTrue@0
_TEXT	SEGMENT
_item$ = -4						; size = 4
_cJSON_CreateTrue@0 PROC				; COMDAT

; 2253 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2254 : 	cJSON *item = cJSON_New_Item(&global_hooks);

  00004	68 00 00 00 00	 push	 OFFSET _global_hooks
  00009	e8 00 00 00 00	 call	 _cJSON_New_Item
  0000e	83 c4 04	 add	 esp, 4
  00011	89 45 fc	 mov	 DWORD PTR _item$[ebp], eax

; 2255 : 	if (item)

  00014	83 7d fc 00	 cmp	 DWORD PTR _item$[ebp], 0
  00018	74 0a		 je	 SHORT $LN1@cJSON_Crea

; 2256 : 	{
; 2257 : 		item->type = cJSON_True;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  0001d	c7 40 0c 02 00
	00 00		 mov	 DWORD PTR [eax+12], 2
$LN1@cJSON_Crea:

; 2258 : 	}
; 2259 : 
; 2260 : 	return item;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]

; 2261 : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_cJSON_CreateTrue@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateNull@0
_TEXT	SEGMENT
_item$ = -4						; size = 4
_cJSON_CreateNull@0 PROC				; COMDAT

; 2242 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2243 : 	cJSON *item = cJSON_New_Item(&global_hooks);

  00004	68 00 00 00 00	 push	 OFFSET _global_hooks
  00009	e8 00 00 00 00	 call	 _cJSON_New_Item
  0000e	83 c4 04	 add	 esp, 4
  00011	89 45 fc	 mov	 DWORD PTR _item$[ebp], eax

; 2244 : 	if (item)

  00014	83 7d fc 00	 cmp	 DWORD PTR _item$[ebp], 0
  00018	74 0a		 je	 SHORT $LN1@cJSON_Crea

; 2245 : 	{
; 2246 : 		item->type = cJSON_NULL;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  0001d	c7 40 0c 04 00
	00 00		 mov	 DWORD PTR [eax+12], 4
$LN1@cJSON_Crea:

; 2247 : 	}
; 2248 : 
; 2249 : 	return item;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]

; 2250 : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
_cJSON_CreateNull@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_IsRaw@4
_TEXT	SEGMENT
tv68 = -4						; size = 4
_item$ = 8						; size = 4
_cJSON_IsRaw@4 PROC					; COMDAT

; 2785 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2786 : 	if (item == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _item$[ebp], 0
  00008	75 04		 jne	 SHORT $LN1@cJSON_IsRa

; 2787 : 	{
; 2788 : 		return false;

  0000a	33 c0		 xor	 eax, eax
  0000c	eb 27		 jmp	 SHORT $LN2@cJSON_IsRa
$LN1@cJSON_IsRa:

; 2789 : 	}
; 2790 : 
; 2791 : 	return (item->type & 0xFF) == cJSON_Raw;

  0000e	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00011	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00014	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0001a	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  00020	75 09		 jne	 SHORT $LN4@cJSON_IsRa
  00022	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00029	eb 07		 jmp	 SHORT $LN5@cJSON_IsRa
$LN4@cJSON_IsRa:
  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN5@cJSON_IsRa:
  00032	8b 45 fc	 mov	 eax, DWORD PTR tv68[ebp]
$LN2@cJSON_IsRa:

; 2792 : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
_cJSON_IsRaw@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_IsObject@4
_TEXT	SEGMENT
tv68 = -4						; size = 4
_item$ = 8						; size = 4
_cJSON_IsObject@4 PROC					; COMDAT

; 2775 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2776 : 	if (item == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _item$[ebp], 0
  00008	75 04		 jne	 SHORT $LN1@cJSON_IsOb

; 2777 : 	{
; 2778 : 		return false;

  0000a	33 c0		 xor	 eax, eax
  0000c	eb 24		 jmp	 SHORT $LN2@cJSON_IsOb
$LN1@cJSON_IsOb:

; 2779 : 	}
; 2780 : 
; 2781 : 	return (item->type & 0xFF) == cJSON_Object;

  0000e	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00011	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00014	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0001a	83 f9 40	 cmp	 ecx, 64			; 00000040H
  0001d	75 09		 jne	 SHORT $LN4@cJSON_IsOb
  0001f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00026	eb 07		 jmp	 SHORT $LN5@cJSON_IsOb
$LN4@cJSON_IsOb:
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN5@cJSON_IsOb:
  0002f	8b 45 fc	 mov	 eax, DWORD PTR tv68[ebp]
$LN2@cJSON_IsOb:

; 2782 : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
_cJSON_IsObject@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_IsArray@4
_TEXT	SEGMENT
tv68 = -4						; size = 4
_item$ = 8						; size = 4
_cJSON_IsArray@4 PROC					; COMDAT

; 2765 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2766 : 	if (item == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _item$[ebp], 0
  00008	75 04		 jne	 SHORT $LN1@cJSON_IsAr

; 2767 : 	{
; 2768 : 		return false;

  0000a	33 c0		 xor	 eax, eax
  0000c	eb 24		 jmp	 SHORT $LN2@cJSON_IsAr
$LN1@cJSON_IsAr:

; 2769 : 	}
; 2770 : 
; 2771 : 	return (item->type & 0xFF) == cJSON_Array;

  0000e	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00011	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00014	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0001a	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0001d	75 09		 jne	 SHORT $LN4@cJSON_IsAr
  0001f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00026	eb 07		 jmp	 SHORT $LN5@cJSON_IsAr
$LN4@cJSON_IsAr:
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN5@cJSON_IsAr:
  0002f	8b 45 fc	 mov	 eax, DWORD PTR tv68[ebp]
$LN2@cJSON_IsAr:

; 2772 : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
_cJSON_IsArray@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_IsString@4
_TEXT	SEGMENT
tv68 = -4						; size = 4
_item$ = 8						; size = 4
_cJSON_IsString@4 PROC					; COMDAT

; 2755 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2756 : 	if (item == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _item$[ebp], 0
  00008	75 04		 jne	 SHORT $LN1@cJSON_IsSt

; 2757 : 	{
; 2758 : 		return false;

  0000a	33 c0		 xor	 eax, eax
  0000c	eb 24		 jmp	 SHORT $LN2@cJSON_IsSt
$LN1@cJSON_IsSt:

; 2759 : 	}
; 2760 : 
; 2761 : 	return (item->type & 0xFF) == cJSON_String;

  0000e	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00011	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00014	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0001a	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0001d	75 09		 jne	 SHORT $LN4@cJSON_IsSt
  0001f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00026	eb 07		 jmp	 SHORT $LN5@cJSON_IsSt
$LN4@cJSON_IsSt:
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN5@cJSON_IsSt:
  0002f	8b 45 fc	 mov	 eax, DWORD PTR tv68[ebp]
$LN2@cJSON_IsSt:

; 2762 : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
_cJSON_IsString@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_IsNumber@4
_TEXT	SEGMENT
tv68 = -4						; size = 4
_item$ = 8						; size = 4
_cJSON_IsNumber@4 PROC					; COMDAT

; 2745 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2746 : 	if (item == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _item$[ebp], 0
  00008	75 04		 jne	 SHORT $LN1@cJSON_IsNu

; 2747 : 	{
; 2748 : 		return false;

  0000a	33 c0		 xor	 eax, eax
  0000c	eb 24		 jmp	 SHORT $LN2@cJSON_IsNu
$LN1@cJSON_IsNu:

; 2749 : 	}
; 2750 : 
; 2751 : 	return (item->type & 0xFF) == cJSON_Number;

  0000e	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00011	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00014	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0001a	83 f9 08	 cmp	 ecx, 8
  0001d	75 09		 jne	 SHORT $LN4@cJSON_IsNu
  0001f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00026	eb 07		 jmp	 SHORT $LN5@cJSON_IsNu
$LN4@cJSON_IsNu:
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN5@cJSON_IsNu:
  0002f	8b 45 fc	 mov	 eax, DWORD PTR tv68[ebp]
$LN2@cJSON_IsNu:

; 2752 : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
_cJSON_IsNumber@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_IsNull@4
_TEXT	SEGMENT
tv68 = -4						; size = 4
_item$ = 8						; size = 4
_cJSON_IsNull@4 PROC					; COMDAT

; 2735 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2736 : 	if (item == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _item$[ebp], 0
  00008	75 04		 jne	 SHORT $LN1@cJSON_IsNu

; 2737 : 	{
; 2738 : 		return false;

  0000a	33 c0		 xor	 eax, eax
  0000c	eb 24		 jmp	 SHORT $LN2@cJSON_IsNu
$LN1@cJSON_IsNu:

; 2739 : 	}
; 2740 : 
; 2741 : 	return (item->type & 0xFF) == cJSON_NULL;

  0000e	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00011	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00014	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0001a	83 f9 04	 cmp	 ecx, 4
  0001d	75 09		 jne	 SHORT $LN4@cJSON_IsNu
  0001f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00026	eb 07		 jmp	 SHORT $LN5@cJSON_IsNu
$LN4@cJSON_IsNu:
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN5@cJSON_IsNu:
  0002f	8b 45 fc	 mov	 eax, DWORD PTR tv68[ebp]
$LN2@cJSON_IsNu:

; 2742 : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
_cJSON_IsNull@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_IsBool@4
_TEXT	SEGMENT
tv68 = -4						; size = 4
_item$ = 8						; size = 4
_cJSON_IsBool@4 PROC					; COMDAT

; 2726 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2727 : 	if (item == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _item$[ebp], 0
  00008	75 04		 jne	 SHORT $LN1@cJSON_IsBo

; 2728 : 	{
; 2729 : 		return false;

  0000a	33 c0		 xor	 eax, eax
  0000c	eb 1e		 jmp	 SHORT $LN2@cJSON_IsBo
$LN1@cJSON_IsBo:

; 2730 : 	}
; 2731 : 
; 2732 : 	return (item->type & (cJSON_True | cJSON_False)) != 0;

  0000e	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00011	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00014	83 e1 03	 and	 ecx, 3
  00017	74 09		 je	 SHORT $LN4@cJSON_IsBo
  00019	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00020	eb 07		 jmp	 SHORT $LN5@cJSON_IsBo
$LN4@cJSON_IsBo:
  00022	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN5@cJSON_IsBo:
  00029	8b 45 fc	 mov	 eax, DWORD PTR tv68[ebp]
$LN2@cJSON_IsBo:

; 2733 : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
_cJSON_IsBool@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_IsTrue@4
_TEXT	SEGMENT
tv68 = -4						; size = 4
_item$ = 8						; size = 4
_cJSON_IsTrue@4 PROC					; COMDAT

; 2715 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2716 : 	if (item == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _item$[ebp], 0
  00008	75 04		 jne	 SHORT $LN1@cJSON_IsTr

; 2717 : 	{
; 2718 : 		return false;

  0000a	33 c0		 xor	 eax, eax
  0000c	eb 24		 jmp	 SHORT $LN2@cJSON_IsTr
$LN1@cJSON_IsTr:

; 2719 : 	}
; 2720 : 
; 2721 : 	return (item->type & 0xff) == cJSON_True;

  0000e	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00011	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00014	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0001a	83 f9 02	 cmp	 ecx, 2
  0001d	75 09		 jne	 SHORT $LN4@cJSON_IsTr
  0001f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00026	eb 07		 jmp	 SHORT $LN5@cJSON_IsTr
$LN4@cJSON_IsTr:
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN5@cJSON_IsTr:
  0002f	8b 45 fc	 mov	 eax, DWORD PTR tv68[ebp]
$LN2@cJSON_IsTr:

; 2722 : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
_cJSON_IsTrue@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_IsFalse@4
_TEXT	SEGMENT
tv68 = -4						; size = 4
_item$ = 8						; size = 4
_cJSON_IsFalse@4 PROC					; COMDAT

; 2705 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2706 : 	if (item == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _item$[ebp], 0
  00008	75 04		 jne	 SHORT $LN1@cJSON_IsFa

; 2707 : 	{
; 2708 : 		return false;

  0000a	33 c0		 xor	 eax, eax
  0000c	eb 24		 jmp	 SHORT $LN2@cJSON_IsFa
$LN1@cJSON_IsFa:

; 2709 : 	}
; 2710 : 
; 2711 : 	return (item->type & 0xFF) == cJSON_False;

  0000e	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00011	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00014	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0001a	83 f9 01	 cmp	 ecx, 1
  0001d	75 09		 jne	 SHORT $LN4@cJSON_IsFa
  0001f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00026	eb 07		 jmp	 SHORT $LN5@cJSON_IsFa
$LN4@cJSON_IsFa:
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN5@cJSON_IsFa:
  0002f	8b 45 fc	 mov	 eax, DWORD PTR tv68[ebp]
$LN2@cJSON_IsFa:

; 2712 : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
_cJSON_IsFalse@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_IsInvalid@4
_TEXT	SEGMENT
tv68 = -4						; size = 4
_item$ = 8						; size = 4
_cJSON_IsInvalid@4 PROC					; COMDAT

; 2695 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2696 : 	if (item == NULL)

  00004	83 7d 08 00	 cmp	 DWORD PTR _item$[ebp], 0
  00008	75 04		 jne	 SHORT $LN1@cJSON_IsIn

; 2697 : 	{
; 2698 : 		return false;

  0000a	33 c0		 xor	 eax, eax
  0000c	eb 21		 jmp	 SHORT $LN2@cJSON_IsIn
$LN1@cJSON_IsIn:

; 2699 : 	}
; 2700 : 
; 2701 : 	return (item->type & 0xFF) == cJSON_Invalid;

  0000e	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00011	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00014	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0001a	75 09		 jne	 SHORT $LN4@cJSON_IsIn
  0001c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00023	eb 07		 jmp	 SHORT $LN5@cJSON_IsIn
$LN4@cJSON_IsIn:
  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN5@cJSON_IsIn:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR tv68[ebp]
$LN2@cJSON_IsIn:

; 2702 : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
_cJSON_IsInvalid@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_GetStringValue@4
_TEXT	SEGMENT
_item$ = 8						; size = 4
_cJSON_GetStringValue@4 PROC				; COMDAT

; 72   : CJSON_PUBLIC(char *) cJSON_GetStringValue(cJSON *item) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   : 	if (!cJSON_IsString(item)) {

  00003	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _cJSON_IsString@4
  0000c	85 c0		 test	 eax, eax
  0000e	75 04		 jne	 SHORT $LN1@cJSON_GetS

; 74   : 		return NULL;

  00010	33 c0		 xor	 eax, eax
  00012	eb 06		 jmp	 SHORT $LN2@cJSON_GetS
$LN1@cJSON_GetS:

; 75   : 	}
; 76   : 
; 77   : 	return item->valuestring;

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00017	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
$LN2@cJSON_GetS:

; 78   : }

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
_cJSON_GetStringValue@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_GetErrorPtr@0
_TEXT	SEGMENT
_cJSON_GetErrorPtr@0 PROC				; COMDAT

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   : 	return (const char*)(global_error.json + global_error.position);

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR _global_error
  00008	03 05 04 00 00
	00		 add	 eax, DWORD PTR _global_error+4

; 70   : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_cJSON_GetErrorPtr@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_HasObjectItem@8
_TEXT	SEGMENT
tv68 = -4						; size = 4
_object$ = 8						; size = 4
_string$ = 12						; size = 4
_cJSON_HasObjectItem@8 PROC				; COMDAT

; 1806 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1807 : 	return cJSON_GetObjectItem(object, string) ? 1 : 0;

  00004	8b 45 0c	 mov	 eax, DWORD PTR _string$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _object$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 _cJSON_GetObjectItem@8
  00011	85 c0		 test	 eax, eax
  00013	74 09		 je	 SHORT $LN3@cJSON_HasO
  00015	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  0001c	eb 07		 jmp	 SHORT $LN4@cJSON_HasO
$LN3@cJSON_HasO:
  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN4@cJSON_HasO:
  00025	8b 45 fc	 mov	 eax, DWORD PTR tv68[ebp]

; 1808 : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
_cJSON_HasObjectItem@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_GetObjectItemCaseSensitive@8
_TEXT	SEGMENT
_object$ = 8						; size = 4
_string$ = 12						; size = 4
_cJSON_GetObjectItemCaseSensitive@8 PROC		; COMDAT

; 1801 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1802 : 	return get_object_item(object, string, true);

  00003	6a 01		 push	 1
  00005	8b 45 0c	 mov	 eax, DWORD PTR _string$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _object$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _get_object_item
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1803 : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
_cJSON_GetObjectItemCaseSensitive@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_GetObjectItem@8
_TEXT	SEGMENT
_object$ = 8						; size = 4
_string$ = 12						; size = 4
_cJSON_GetObjectItem@8 PROC				; COMDAT

; 1796 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1797 : 	return get_object_item(object, string, false);

  00003	6a 00		 push	 0
  00005	8b 45 0c	 mov	 eax, DWORD PTR _string$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _object$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _get_object_item
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1798 : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
_cJSON_GetObjectItem@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_GetArrayItem@8
_TEXT	SEGMENT
_array$ = 8						; size = 4
_index$ = 12						; size = 4
_cJSON_GetArrayItem@8 PROC				; COMDAT

; 1758 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1759 : 	if (index < 0)

  00003	83 7d 0c 00	 cmp	 DWORD PTR _index$[ebp], 0
  00007	7d 04		 jge	 SHORT $LN1@cJSON_GetA

; 1760 : 	{
; 1761 : 		return NULL;

  00009	33 c0		 xor	 eax, eax
  0000b	eb 10		 jmp	 SHORT $LN2@cJSON_GetA
$LN1@cJSON_GetA:

; 1762 : 	}
; 1763 : 
; 1764 : 	return get_array_item(array, (size_t)index);

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _index$[ebp]
  00010	50		 push	 eax
  00011	8b 4d 08	 mov	 ecx, DWORD PTR _array$[ebp]
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 _get_array_item
  0001a	83 c4 08	 add	 esp, 8
$LN2@cJSON_GetA:

; 1765 : }

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
_cJSON_GetArrayItem@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_GetArraySize@4
_TEXT	SEGMENT
_size$ = -8						; size = 4
_child$ = -4						; size = 4
_array$ = 8						; size = 4
_cJSON_GetArraySize@4 PROC				; COMDAT

; 1716 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1717 : 	cJSON *child = NULL;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _child$[ebp], 0

; 1718 : 	size_t size = 0;

  0000d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _size$[ebp], 0

; 1719 : 
; 1720 : 	if (array == NULL)

  00014	83 7d 08 00	 cmp	 DWORD PTR _array$[ebp], 0
  00018	75 04		 jne	 SHORT $LN3@cJSON_GetA

; 1721 : 	{
; 1722 : 		return 0;

  0001a	33 c0		 xor	 eax, eax
  0001c	eb 25		 jmp	 SHORT $LN4@cJSON_GetA
$LN3@cJSON_GetA:

; 1723 : 	}
; 1724 : 
; 1725 : 	child = array->child;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _array$[ebp]
  00021	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00024	89 4d fc	 mov	 DWORD PTR _child$[ebp], ecx
$LN2@cJSON_GetA:

; 1726 : 
; 1727 : 	while (child != NULL)

  00027	83 7d fc 00	 cmp	 DWORD PTR _child$[ebp], 0
  0002b	74 13		 je	 SHORT $LN1@cJSON_GetA

; 1728 : 	{
; 1729 : 		size++;

  0002d	8b 55 f8	 mov	 edx, DWORD PTR _size$[ebp]
  00030	83 c2 01	 add	 edx, 1
  00033	89 55 f8	 mov	 DWORD PTR _size$[ebp], edx

; 1730 : 		child = child->next;

  00036	8b 45 fc	 mov	 eax, DWORD PTR _child$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	89 4d fc	 mov	 DWORD PTR _child$[ebp], ecx

; 1731 : 	}

  0003e	eb e7		 jmp	 SHORT $LN2@cJSON_GetA
$LN1@cJSON_GetA:

; 1732 : 
; 1733 : 	/* FIXME: Can overflow here. Cannot be fixed without breaking the API */
; 1734 : 
; 1735 : 	return (int)size;

  00040	8b 45 f8	 mov	 eax, DWORD PTR _size$[ebp]
$LN4@cJSON_GetA:

; 1736 : }

  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
_cJSON_GetArraySize@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_Delete@4
_TEXT	SEGMENT
_next$ = -4						; size = 4
_item$ = 8						; size = 4
_cJSON_Delete@4 PROC					; COMDAT

; 212  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 213  : 	cJSON *next = NULL;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
$LN5@cJSON_Dele:

; 214  : 	while (item != NULL)

  0000b	83 7d 08 00	 cmp	 DWORD PTR _item$[ebp], 0
  0000f	0f 84 90 00 00
	00		 je	 $LN6@cJSON_Dele

; 215  : 	{
; 216  : 		next = item->next;

  00015	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d fc	 mov	 DWORD PTR _next$[ebp], ecx

; 217  : 		if (!(item->type & cJSON_IsReference) && (item->child != NULL))

  0001d	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00020	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00023	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00028	75 15		 jne	 SHORT $LN3@cJSON_Dele
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  0002d	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00031	74 0c		 je	 SHORT $LN3@cJSON_Dele

; 218  : 		{
; 219  : 			cJSON_Delete(item->child);

  00033	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00036	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _cJSON_Delete@4
$LN3@cJSON_Dele:

; 220  : 		}
; 221  : 		if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))

  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00042	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00045	81 e2 00 01 00
	00		 and	 edx, 256		; 00000100H
  0004b	75 19		 jne	 SHORT $LN2@cJSON_Dele
  0004d	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00050	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00054	74 10		 je	 SHORT $LN2@cJSON_Dele

; 222  : 		{
; 223  : 			global_hooks.deallocate(item->valuestring);

  00056	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00059	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0005c	52		 push	 edx
  0005d	ff 15 04 00 00
	00		 call	 DWORD PTR _global_hooks+4
  00063	83 c4 04	 add	 esp, 4
$LN2@cJSON_Dele:

; 224  : 		}
; 225  : 		if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))

  00066	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00069	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0006c	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00072	75 19		 jne	 SHORT $LN1@cJSON_Dele
  00074	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00077	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  0007b	74 10		 je	 SHORT $LN1@cJSON_Dele

; 226  : 		{
; 227  : 			global_hooks.deallocate(item->string);

  0007d	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00080	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00083	51		 push	 ecx
  00084	ff 15 04 00 00
	00		 call	 DWORD PTR _global_hooks+4
  0008a	83 c4 04	 add	 esp, 4
$LN1@cJSON_Dele:

; 228  : 		}
; 229  : 		global_hooks.deallocate(item);

  0008d	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00090	52		 push	 edx
  00091	ff 15 04 00 00
	00		 call	 DWORD PTR _global_hooks+4
  00097	83 c4 04	 add	 esp, 4

; 230  : 		item = next;

  0009a	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]
  0009d	89 45 08	 mov	 DWORD PTR _item$[ebp], eax

; 231  : 	}

  000a0	e9 66 ff ff ff	 jmp	 $LN5@cJSON_Dele
$LN6@cJSON_Dele:

; 232  : }

  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c2 04 00	 ret	 4
_cJSON_Delete@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_PrintPreallocated@16
_TEXT	SEGMENT
_p$ = -36						; size = 36
_item$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_fmt$ = 20						; size = 4
_cJSON_PrintPreallocated@16 PROC			; COMDAT

; 1190 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 1191 : 	printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };

  00006	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], 0
  0000d	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+4], 0
  00014	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+8], 0
  0001b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+12], 0
  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+16], 0
  00029	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+20], 0
  00030	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+24], 0
  00037	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+28], 0
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+32], 0

; 1192 : 
; 1193 : 	if ((len < 0) || (buf == NULL))

  00045	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  00049	7c 06		 jl	 SHORT $LN1@cJSON_Prin
  0004b	83 7d 0c 00	 cmp	 DWORD PTR _buf$[ebp], 0
  0004f	75 04		 jne	 SHORT $LN2@cJSON_Prin
$LN1@cJSON_Prin:

; 1194 : 	{
; 1195 : 		return false;

  00051	33 c0		 xor	 eax, eax
  00053	eb 4a		 jmp	 SHORT $LN3@cJSON_Prin
$LN2@cJSON_Prin:

; 1196 : 	}
; 1197 : 
; 1198 : 	p.buffer = (unsigned char*)buf;

  00055	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00058	89 45 dc	 mov	 DWORD PTR _p$[ebp], eax

; 1199 : 	p.length = (size_t)len;

  0005b	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  0005e	89 4d e0	 mov	 DWORD PTR _p$[ebp+4], ecx

; 1200 : 	p.offset = 0;

  00061	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+8], 0

; 1201 : 	p.noalloc = true;

  00068	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _p$[ebp+16], 1

; 1202 : 	p.format = fmt;

  0006f	8b 55 14	 mov	 edx, DWORD PTR _fmt$[ebp]
  00072	89 55 f0	 mov	 DWORD PTR _p$[ebp+20], edx

; 1203 : 	p.hooks = global_hooks;

  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _global_hooks
  0007a	89 45 f4	 mov	 DWORD PTR _p$[ebp+24], eax
  0007d	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _global_hooks+4
  00083	89 4d f8	 mov	 DWORD PTR _p$[ebp+28], ecx
  00086	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _global_hooks+8
  0008c	89 55 fc	 mov	 DWORD PTR _p$[ebp+32], edx

; 1204 : 
; 1205 : 	return print_value(item, &p);

  0008f	8d 45 dc	 lea	 eax, DWORD PTR _p$[ebp]
  00092	50		 push	 eax
  00093	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 _print_value
  0009c	83 c4 08	 add	 esp, 8
$LN3@cJSON_Prin:

; 1206 : }

  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c2 10 00	 ret	 16			; 00000010H
_cJSON_PrintPreallocated@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_PrintBuffered@12
_TEXT	SEGMENT
_p$ = -36						; size = 36
_item$ = 8						; size = 4
_prebuffer$ = 12					; size = 4
_fmt$ = 16						; size = 4
_cJSON_PrintBuffered@12 PROC				; COMDAT

; 1160 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 1161 : 	printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };

  00006	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], 0
  0000d	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+4], 0
  00014	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+8], 0
  0001b	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+12], 0
  00022	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+16], 0
  00029	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+20], 0
  00030	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+24], 0
  00037	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+28], 0
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+32], 0

; 1162 : 
; 1163 : 	if (prebuffer < 0)

  00045	83 7d 0c 00	 cmp	 DWORD PTR _prebuffer$[ebp], 0
  00049	7d 04		 jge	 SHORT $LN3@cJSON_Prin

; 1164 : 	{
; 1165 : 		return NULL;

  0004b	33 c0		 xor	 eax, eax
  0004d	eb 76		 jmp	 SHORT $LN4@cJSON_Prin
$LN3@cJSON_Prin:

; 1166 : 	}
; 1167 : 
; 1168 : 	p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer);

  0004f	8b 45 0c	 mov	 eax, DWORD PTR _prebuffer$[ebp]
  00052	50		 push	 eax
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR _global_hooks
  00059	83 c4 04	 add	 esp, 4
  0005c	89 45 dc	 mov	 DWORD PTR _p$[ebp], eax

; 1169 : 	if (!p.buffer)

  0005f	83 7d dc 00	 cmp	 DWORD PTR _p$[ebp], 0
  00063	75 04		 jne	 SHORT $LN2@cJSON_Prin

; 1170 : 	{
; 1171 : 		return NULL;

  00065	33 c0		 xor	 eax, eax
  00067	eb 5c		 jmp	 SHORT $LN4@cJSON_Prin
$LN2@cJSON_Prin:

; 1172 : 	}
; 1173 : 
; 1174 : 	p.length = (size_t)prebuffer;

  00069	8b 4d 0c	 mov	 ecx, DWORD PTR _prebuffer$[ebp]
  0006c	89 4d e0	 mov	 DWORD PTR _p$[ebp+4], ecx

; 1175 : 	p.offset = 0;

  0006f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+8], 0

; 1176 : 	p.noalloc = false;

  00076	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _p$[ebp+16], 0

; 1177 : 	p.format = fmt;

  0007d	8b 55 10	 mov	 edx, DWORD PTR _fmt$[ebp]
  00080	89 55 f0	 mov	 DWORD PTR _p$[ebp+20], edx

; 1178 : 	p.hooks = global_hooks;

  00083	a1 00 00 00 00	 mov	 eax, DWORD PTR _global_hooks
  00088	89 45 f4	 mov	 DWORD PTR _p$[ebp+24], eax
  0008b	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR _global_hooks+4
  00091	89 4d f8	 mov	 DWORD PTR _p$[ebp+28], ecx
  00094	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR _global_hooks+8
  0009a	89 55 fc	 mov	 DWORD PTR _p$[ebp+32], edx

; 1179 : 
; 1180 : 	if (!print_value(item, &p))

  0009d	8d 45 dc	 lea	 eax, DWORD PTR _p$[ebp]
  000a0	50		 push	 eax
  000a1	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  000a4	51		 push	 ecx
  000a5	e8 00 00 00 00	 call	 _print_value
  000aa	83 c4 08	 add	 esp, 8
  000ad	85 c0		 test	 eax, eax
  000af	75 11		 jne	 SHORT $LN1@cJSON_Prin

; 1181 : 	{
; 1182 : 		global_hooks.deallocate(p.buffer);

  000b1	8b 55 dc	 mov	 edx, DWORD PTR _p$[ebp]
  000b4	52		 push	 edx
  000b5	ff 15 04 00 00
	00		 call	 DWORD PTR _global_hooks+4
  000bb	83 c4 04	 add	 esp, 4

; 1183 : 		return NULL;

  000be	33 c0		 xor	 eax, eax
  000c0	eb 03		 jmp	 SHORT $LN4@cJSON_Prin
$LN1@cJSON_Prin:

; 1184 : 	}
; 1185 : 
; 1186 : 	return (char*)p.buffer;

  000c2	8b 45 dc	 mov	 eax, DWORD PTR _p$[ebp]
$LN4@cJSON_Prin:

; 1187 : }

  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c2 0c 00	 ret	 12			; 0000000cH
_cJSON_PrintBuffered@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_PrintUnformatted@4
_TEXT	SEGMENT
_item$ = 8						; size = 4
_cJSON_PrintUnformatted@4 PROC				; COMDAT

; 1155 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1156 : 	return (char*)print(item, false, &global_hooks);

  00003	68 00 00 00 00	 push	 OFFSET _global_hooks
  00008	6a 00		 push	 0
  0000a	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 _print
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1157 : }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
_cJSON_PrintUnformatted@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_Print@4
_TEXT	SEGMENT
_item$ = 8						; size = 4
_cJSON_Print@4 PROC					; COMDAT

; 1150 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1151 : 	return (char*)print(item, true, &global_hooks);

  00003	68 00 00 00 00	 push	 OFFSET _global_hooks
  00008	6a 01		 push	 1
  0000a	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 _print
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1152 : }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
_cJSON_Print@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_ParseWithOpts@12
_TEXT	SEGMENT
_buffer$ = -40						; size = 28
_local_error$1 = -12					; size = 8
_item$ = -4						; size = 4
_value$ = 8						; size = 4
_return_parse_end$ = 12					; size = 4
_require_null_terminated$ = 16				; size = 4
_cJSON_ParseWithOpts@12 PROC				; COMDAT

; 998  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 999  : 	parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };

  00006	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _buffer$[ebp], 0
  0000d	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _buffer$[ebp+4], 0
  00014	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _buffer$[ebp+8], 0
  0001b	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _buffer$[ebp+12], 0
  00022	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _buffer$[ebp+16], 0
  00029	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _buffer$[ebp+20], 0
  00030	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _buffer$[ebp+24], 0

; 1000 : 	cJSON *item = NULL;

  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _item$[ebp], 0

; 1001 : 
; 1002 : 	/* reset error position */
; 1003 : 	global_error.json = NULL;

  0003e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _global_error, 0

; 1004 : 	global_error.position = 0;

  00048	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _global_error+4, 0

; 1005 : 
; 1006 : 	if (value == NULL)

  00052	83 7d 08 00	 cmp	 DWORD PTR _value$[ebp], 0
  00056	75 05		 jne	 SHORT $LN13@cJSON_Pars

; 1007 : 	{
; 1008 : 		goto fail;

  00058	e9 c1 00 00 00	 jmp	 $fail$16
$LN13@cJSON_Pars:

; 1009 : 	}
; 1010 : 
; 1011 : 	buffer.content = (const unsigned char*)value;

  0005d	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  00060	89 45 d8	 mov	 DWORD PTR _buffer$[ebp], eax

; 1012 : 	buffer.length = strlen((const char*)value) + sizeof("");

  00063	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  00066	51		 push	 ecx
  00067	e8 00 00 00 00	 call	 _strlen
  0006c	83 c4 04	 add	 esp, 4
  0006f	83 c0 01	 add	 eax, 1
  00072	89 45 dc	 mov	 DWORD PTR _buffer$[ebp+4], eax

; 1013 : 	buffer.offset = 0;

  00075	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _buffer$[ebp+8], 0

; 1014 : 	buffer.hooks = global_hooks;

  0007c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _global_hooks
  00082	89 55 e8	 mov	 DWORD PTR _buffer$[ebp+16], edx
  00085	a1 04 00 00 00	 mov	 eax, DWORD PTR _global_hooks+4
  0008a	89 45 ec	 mov	 DWORD PTR _buffer$[ebp+20], eax
  0008d	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR _global_hooks+8
  00093	89 4d f0	 mov	 DWORD PTR _buffer$[ebp+24], ecx

; 1015 : 
; 1016 : 	item = cJSON_New_Item(&global_hooks);

  00096	68 00 00 00 00	 push	 OFFSET _global_hooks
  0009b	e8 00 00 00 00	 call	 _cJSON_New_Item
  000a0	83 c4 04	 add	 esp, 4
  000a3	89 45 fc	 mov	 DWORD PTR _item$[ebp], eax

; 1017 : 	if (item == NULL) /* memory fail */

  000a6	83 7d fc 00	 cmp	 DWORD PTR _item$[ebp], 0
  000aa	75 02		 jne	 SHORT $LN12@cJSON_Pars

; 1018 : 	{
; 1019 : 		goto fail;

  000ac	eb 70		 jmp	 SHORT $fail$16
$LN12@cJSON_Pars:

; 1020 : 	}
; 1021 : 
; 1022 : 	if (!parse_value(item, buffer_skip_whitespace(skip_utf8_bom(&buffer))))

  000ae	8d 55 d8	 lea	 edx, DWORD PTR _buffer$[ebp]
  000b1	52		 push	 edx
  000b2	e8 00 00 00 00	 call	 _skip_utf8_bom
  000b7	83 c4 04	 add	 esp, 4
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _buffer_skip_whitespace
  000c0	83 c4 04	 add	 esp, 4
  000c3	50		 push	 eax
  000c4	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 _parse_value
  000cd	83 c4 08	 add	 esp, 8
  000d0	85 c0		 test	 eax, eax
  000d2	75 02		 jne	 SHORT $LN11@cJSON_Pars

; 1023 : 	{
; 1024 : 		/* parse failure. ep is set. */
; 1025 : 		goto fail;

  000d4	eb 48		 jmp	 SHORT $fail$16
$LN11@cJSON_Pars:

; 1026 : 	}
; 1027 : 
; 1028 : 	/* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
; 1029 : 	if (require_null_terminated)

  000d6	83 7d 10 00	 cmp	 DWORD PTR _require_null_terminated$[ebp], 0
  000da	74 2c		 je	 SHORT $LN10@cJSON_Pars

; 1030 : 	{
; 1031 : 		buffer_skip_whitespace(&buffer);

  000dc	8d 4d d8	 lea	 ecx, DWORD PTR _buffer$[ebp]
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 _buffer_skip_whitespace
  000e5	83 c4 04	 add	 esp, 4

; 1032 : 		if ((buffer.offset >= buffer.length) || buffer_at_offset(&buffer)[0] != '\0')

  000e8	8b 55 e0	 mov	 edx, DWORD PTR _buffer$[ebp+8]
  000eb	3b 55 dc	 cmp	 edx, DWORD PTR _buffer$[ebp+4]
  000ee	73 16		 jae	 SHORT $LN8@cJSON_Pars
  000f0	8b 45 d8	 mov	 eax, DWORD PTR _buffer$[ebp]
  000f3	03 45 e0	 add	 eax, DWORD PTR _buffer$[ebp+8]
  000f6	b9 01 00 00 00	 mov	 ecx, 1
  000fb	6b d1 00	 imul	 edx, ecx, 0
  000fe	0f b6 04 10	 movzx	 eax, BYTE PTR [eax+edx]
  00102	85 c0		 test	 eax, eax
  00104	74 02		 je	 SHORT $LN10@cJSON_Pars
$LN8@cJSON_Pars:

; 1033 : 		{
; 1034 : 			goto fail;

  00106	eb 16		 jmp	 SHORT $fail$16
$LN10@cJSON_Pars:

; 1035 : 		}
; 1036 : 	}
; 1037 : 	if (return_parse_end)

  00108	83 7d 0c 00	 cmp	 DWORD PTR _return_parse_end$[ebp], 0
  0010c	74 0b		 je	 SHORT $LN7@cJSON_Pars

; 1038 : 	{
; 1039 : 		*return_parse_end = (const char*)buffer_at_offset(&buffer);

  0010e	8b 4d d8	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00111	03 4d e0	 add	 ecx, DWORD PTR _buffer$[ebp+8]
  00114	8b 55 0c	 mov	 edx, DWORD PTR _return_parse_end$[ebp]
  00117	89 0a		 mov	 DWORD PTR [edx], ecx
$LN7@cJSON_Pars:

; 1040 : 	}
; 1041 : 
; 1042 : 	return item;

  00119	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  0011c	eb 66		 jmp	 SHORT $LN14@cJSON_Pars
$fail$16:

; 1043 : 
; 1044 : fail:
; 1045 : 	if (item != NULL)

  0011e	83 7d fc 00	 cmp	 DWORD PTR _item$[ebp], 0
  00122	74 09		 je	 SHORT $LN6@cJSON_Pars

; 1046 : 	{
; 1047 : 		cJSON_Delete(item);

  00124	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  00127	50		 push	 eax
  00128	e8 00 00 00 00	 call	 _cJSON_Delete@4
$LN6@cJSON_Pars:

; 1048 : 	}
; 1049 : 
; 1050 : 	if (value != NULL)

  0012d	83 7d 08 00	 cmp	 DWORD PTR _value$[ebp], 0
  00131	74 4f		 je	 SHORT $LN5@cJSON_Pars

; 1051 : 	{
; 1052 : 		error local_error;
; 1053 : 		local_error.json = (const unsigned char*)value;

  00133	8b 4d 08	 mov	 ecx, DWORD PTR _value$[ebp]
  00136	89 4d f4	 mov	 DWORD PTR _local_error$1[ebp], ecx

; 1054 : 		local_error.position = 0;

  00139	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _local_error$1[ebp+4], 0

; 1055 : 
; 1056 : 		if (buffer.offset < buffer.length)

  00140	8b 55 e0	 mov	 edx, DWORD PTR _buffer$[ebp+8]
  00143	3b 55 dc	 cmp	 edx, DWORD PTR _buffer$[ebp+4]
  00146	73 08		 jae	 SHORT $LN4@cJSON_Pars

; 1057 : 		{
; 1058 : 			local_error.position = buffer.offset;

  00148	8b 45 e0	 mov	 eax, DWORD PTR _buffer$[ebp+8]
  0014b	89 45 f8	 mov	 DWORD PTR _local_error$1[ebp+4], eax
  0014e	eb 0f		 jmp	 SHORT $LN3@cJSON_Pars
$LN4@cJSON_Pars:

; 1059 : 		}
; 1060 : 		else if (buffer.length > 0)

  00150	83 7d dc 00	 cmp	 DWORD PTR _buffer$[ebp+4], 0
  00154	76 09		 jbe	 SHORT $LN3@cJSON_Pars

; 1061 : 		{
; 1062 : 			local_error.position = buffer.length - 1;

  00156	8b 4d dc	 mov	 ecx, DWORD PTR _buffer$[ebp+4]
  00159	83 e9 01	 sub	 ecx, 1
  0015c	89 4d f8	 mov	 DWORD PTR _local_error$1[ebp+4], ecx
$LN3@cJSON_Pars:

; 1063 : 		}
; 1064 : 
; 1065 : 		if (return_parse_end != NULL)

  0015f	83 7d 0c 00	 cmp	 DWORD PTR _return_parse_end$[ebp], 0
  00163	74 0b		 je	 SHORT $LN1@cJSON_Pars

; 1066 : 		{
; 1067 : 			*return_parse_end = (const char*)local_error.json + local_error.position;

  00165	8b 55 f4	 mov	 edx, DWORD PTR _local_error$1[ebp]
  00168	03 55 f8	 add	 edx, DWORD PTR _local_error$1[ebp+4]
  0016b	8b 45 0c	 mov	 eax, DWORD PTR _return_parse_end$[ebp]
  0016e	89 10		 mov	 DWORD PTR [eax], edx
$LN1@cJSON_Pars:

; 1068 : 		}
; 1069 : 
; 1070 : 		global_error = local_error;

  00170	8b 4d f4	 mov	 ecx, DWORD PTR _local_error$1[ebp]
  00173	89 0d 00 00 00
	00		 mov	 DWORD PTR _global_error, ecx
  00179	8b 55 f8	 mov	 edx, DWORD PTR _local_error$1[ebp+4]
  0017c	89 15 04 00 00
	00		 mov	 DWORD PTR _global_error+4, edx
$LN5@cJSON_Pars:

; 1071 : 	}
; 1072 : 
; 1073 : 	return NULL;

  00182	33 c0		 xor	 eax, eax
$LN14@cJSON_Pars:

; 1074 : }

  00184	8b e5		 mov	 esp, ebp
  00186	5d		 pop	 ebp
  00187	c2 0c 00	 ret	 12			; 0000000cH
_cJSON_ParseWithOpts@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_Parse@4
_TEXT	SEGMENT
_value$ = 8						; size = 4
_cJSON_Parse@4 PROC					; COMDAT

; 1078 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1079 : 	return cJSON_ParseWithOpts(value, 0, 0);

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _cJSON_ParseWithOpts@12

; 1080 : }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
_cJSON_Parse@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_InitHooks@4
_TEXT	SEGMENT
_hooks$ = 8						; size = 4
_cJSON_InitHooks@4 PROC					; COMDAT

; 168  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 169  : 	if (hooks == NULL)

  00003	83 7d 08 00	 cmp	 DWORD PTR _hooks$[ebp], 0
  00007	75 20		 jne	 SHORT $LN4@cJSON_Init

; 170  : 	{
; 171  : 		/* Reset hooks */
; 172  : 		global_hooks.allocate = _hx_malloc;

  00009	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _global_hooks, OFFSET __hx_malloc

; 173  : 		global_hooks.deallocate = _hx_free;

  00013	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _global_hooks+4, OFFSET __hx_free

; 174  : 		global_hooks.reallocate = _hx_realloc;

  0001d	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR _global_hooks+8, OFFSET __hx_realloc

; 175  : 		return;

  00027	eb 68		 jmp	 SHORT $LN5@cJSON_Init
$LN4@cJSON_Init:

; 176  : 	}
; 177  : 
; 178  : 	global_hooks.allocate = _hx_malloc;

  00029	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _global_hooks, OFFSET __hx_malloc

; 179  : 	if (hooks->malloc_fn != NULL)

  00033	8b 45 08	 mov	 eax, DWORD PTR _hooks$[ebp]
  00036	83 38 00	 cmp	 DWORD PTR [eax], 0
  00039	74 0b		 je	 SHORT $LN3@cJSON_Init

; 180  : 	{
; 181  : 		global_hooks.allocate = hooks->malloc_fn;

  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _hooks$[ebp]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	89 15 00 00 00
	00		 mov	 DWORD PTR _global_hooks, edx
$LN3@cJSON_Init:

; 182  : 	}
; 183  : 
; 184  : 	global_hooks.deallocate = _hx_free;

  00046	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _global_hooks+4, OFFSET __hx_free

; 185  : 	if (hooks->free_fn != NULL)

  00050	8b 45 08	 mov	 eax, DWORD PTR _hooks$[ebp]
  00053	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00057	74 0c		 je	 SHORT $LN2@cJSON_Init

; 186  : 	{
; 187  : 		global_hooks.deallocate = hooks->free_fn;

  00059	8b 4d 08	 mov	 ecx, DWORD PTR _hooks$[ebp]
  0005c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0005f	89 15 04 00 00
	00		 mov	 DWORD PTR _global_hooks+4, edx
$LN2@cJSON_Init:

; 188  : 	}
; 189  : 
; 190  : 	/* use realloc only if both free and malloc are used */
; 191  : 	global_hooks.reallocate = NULL;

  00065	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR _global_hooks+8, 0

; 192  : 	if ((global_hooks.allocate == _hx_malloc) && (global_hooks.deallocate == _hx_free))

  0006f	81 3d 00 00 00
	00 00 00 00 00	 cmp	 DWORD PTR _global_hooks, OFFSET __hx_malloc
  00079	75 16		 jne	 SHORT $LN5@cJSON_Init
  0007b	81 3d 04 00 00
	00 00 00 00 00	 cmp	 DWORD PTR _global_hooks+4, OFFSET __hx_free
  00085	75 0a		 jne	 SHORT $LN5@cJSON_Init

; 193  : 	{
; 194  : 		global_hooks.reallocate = _hx_realloc;

  00087	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR _global_hooks+8, OFFSET __hx_realloc
$LN5@cJSON_Init:

; 195  : 	}
; 196  : }

  00091	5d		 pop	 ebp
  00092	c2 04 00	 ret	 4
_cJSON_InitHooks@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_Version@0
_TEXT	SEGMENT
_cJSON_Version@0 PROC					; COMDAT

; 86   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	static char version[15];
; 88   : 	sprintf(version, "%i.%i.%i", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);

  00003	6a 04		 push	 4
  00005	6a 07		 push	 7
  00007	6a 01		 push	 1
  00009	68 00 00 00 00	 push	 OFFSET $SG2315
  0000e	68 00 00 00 00	 push	 OFFSET ?version@?1??cJSON_Version@@9@9
  00013	e8 00 00 00 00	 call	 __hx_sprintf
  00018	83 c4 14	 add	 esp, 20			; 00000014H

; 89   : 
; 90   : 	return version;

  0001b	b8 00 00 00 00	 mov	 eax, OFFSET ?version@?1??cJSON_Version@@9@9

; 91   : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
_cJSON_Version@0 ENDP
_TEXT	ENDS
END
