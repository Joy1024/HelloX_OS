; Listing generated by Microsoft (R) Optimizing Compiler Version 19.13.26128.0 

	TITLE	C:\HelloX\personal\HelloX_OS\app\yeelight\hxlib\cjson\cjson.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

EXTRN	__hx_malloc:PROC
EXTRN	__hx_free:PROC
_BSS	SEGMENT
$SG5181	DB	01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
_firstByteMark DB 00H
	DB	00H
	DB	0c0H
	DB	0e0H
	DB	0f0H
	DB	0f8H
	DB	0fcH
CONST	ENDS
_DATA	SEGMENT
_cJSON_malloc DD FLAT:__hx_malloc
_cJSON_free DD	FLAT:__hx_free
$SG5072	DB	'%d', 00H
	ORG $+1
$SG5076	DB	'%.0f', 00H
	ORG $+3
$SG5080	DB	'%e', 00H
	ORG $+1
$SG5081	DB	'%f', 00H
	ORG $+1
$SG5184	DB	'"\', 08H, 0cH, 0aH, 0dH, 09H, 00H
$SG5197	DB	'u%04x', 00H
	ORG $+2
$SG5275	DB	'null', 00H
	ORG $+3
$SG5277	DB	'false', 00H
	ORG $+2
$SG5279	DB	'true', 00H
	ORG $+3
$SG5297	DB	'null', 00H
	ORG $+3
$SG5299	DB	'false', 00H
	ORG $+2
$SG5301	DB	'true', 00H
	ORG $+3
$SG5355	DB	'[]', 00H
_DATA	ENDS
PUBLIC	_cJSON_InitHooks
PUBLIC	_cJSON_Parse
PUBLIC	_cJSON_Print
PUBLIC	_cJSON_PrintUnformatted
PUBLIC	_cJSON_Delete
PUBLIC	_cJSON_GetArraySize
PUBLIC	_cJSON_GetArrayItem
PUBLIC	_cJSON_GetObjectItem
PUBLIC	_cJSON_GetErrorPtr
PUBLIC	_cJSON_CreateNull
PUBLIC	_cJSON_CreateTrue
PUBLIC	_cJSON_CreateFalse
PUBLIC	_cJSON_CreateBool
PUBLIC	_cJSON_CreateNumber
PUBLIC	_cJSON_CreateString
PUBLIC	_cJSON_CreateArray
PUBLIC	_cJSON_CreateObject
PUBLIC	_cJSON_CreateIntArray
PUBLIC	_cJSON_CreateFloatArray
PUBLIC	_cJSON_CreateDoubleArray
PUBLIC	_cJSON_CreateStringArray
PUBLIC	_cJSON_AddItemToArray
PUBLIC	_cJSON_AddItemToObject
PUBLIC	_cJSON_AddItemReferenceToArray
PUBLIC	_cJSON_AddItemReferenceToObject
PUBLIC	_cJSON_DetachItemFromArray
PUBLIC	_cJSON_DeleteItemFromArray
PUBLIC	_cJSON_DetachItemFromObject
PUBLIC	_cJSON_DeleteItemFromObject
PUBLIC	_cJSON_ReplaceItemInArray
PUBLIC	_cJSON_ReplaceItemInObject
PUBLIC	_cJSON_Duplicate
PUBLIC	_cJSON_ParseWithOpts
PUBLIC	_cJSON_Minify
PUBLIC	__real@0000000000000000
PUBLIC	__real@3e80000000000000
PUBLIC	__real@3eb0c6f7a0b5ed8d
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@41cdcd6500000000
PUBLIC	__real@41dfffffffc00000
PUBLIC	__real@4c63e9e4e4c2f344
PUBLIC	__real@bff0000000000000
PUBLIC	__real@c1e0000000000000
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strchr:PROC
EXTRN	_strlen:PROC
EXTRN	_strncmp:PROC
EXTRN	__hx_sprintf:PROC
EXTRN	_pow:PROC
EXTRN	_floor:PROC
EXTRN	_fabs:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	__fltused:DWORD
_BSS	SEGMENT
	ALIGN	4

_ep	DD	01H DUP (?)
_BSS	ENDS
;	COMDAT __real@c1e0000000000000
CONST	SEGMENT
__real@c1e0000000000000 DQ 0c1e0000000000000r	; -2.14748e+09
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@4c63e9e4e4c2f344
CONST	SEGMENT
__real@4c63e9e4e4c2f344 DQ 04c63e9e4e4c2f344r	; 1e+60
CONST	ENDS
;	COMDAT __real@41dfffffffc00000
CONST	SEGMENT
__real@41dfffffffc00000 DQ 041dfffffffc00000r	; 2.14748e+09
CONST	ENDS
;	COMDAT __real@41cdcd6500000000
CONST	SEGMENT
__real@41cdcd6500000000 DQ 041cdcd6500000000r	; 1e+09
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3eb0c6f7a0b5ed8d
CONST	SEGMENT
__real@3eb0c6f7a0b5ed8d DQ 03eb0c6f7a0b5ed8dr	; 1e-06
CONST	ENDS
;	COMDAT __real@3e80000000000000
CONST	SEGMENT
__real@3e80000000000000 DQ 03e80000000000000r	; 1.19209e-07
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _create_reference
_TEXT	SEGMENT
_ref$ = -4						; size = 4
_item$ = 8						; size = 4
_create_reference PROC					; COMDAT

; 515  : static cJSON *create_reference(cJSON *item) { cJSON *ref = cJSON_New_Item(); if (!ref) return 0; memcpy(ref, item, sizeof(cJSON)); ref->string = 0; ref->type |= cJSON_IsReference; ref->next = ref->prev = 0; return ref; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	e8 00 00 00 00	 call	 _cJSON_New_Item
  00009	89 45 fc	 mov	 DWORD PTR _ref$[ebp], eax
  0000c	83 7d fc 00	 cmp	 DWORD PTR _ref$[ebp], 0
  00010	75 04		 jne	 SHORT $LN2@create_ref
  00012	33 c0		 xor	 eax, eax
  00014	eb 44		 jmp	 SHORT $LN1@create_ref
$LN2@create_ref:
  00016	6a 28		 push	 40			; 00000028H
  00018	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _ref$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 _memcpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
  00028	8b 55 fc	 mov	 edx, DWORD PTR _ref$[ebp]
  0002b	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0
  00032	8b 45 fc	 mov	 eax, DWORD PTR _ref$[ebp]
  00035	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00038	81 c9 00 01 00
	00		 or	 ecx, 256		; 00000100H
  0003e	8b 55 fc	 mov	 edx, DWORD PTR _ref$[ebp]
  00041	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00044	8b 45 fc	 mov	 eax, DWORD PTR _ref$[ebp]
  00047	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _ref$[ebp]
  00051	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00057	8b 45 fc	 mov	 eax, DWORD PTR _ref$[ebp]
$LN1@create_ref:
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_create_reference ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _suffix_object
_TEXT	SEGMENT
_prev$ = 8						; size = 4
_item$ = 12						; size = 4
_suffix_object PROC					; COMDAT

; 513  : static void suffix_object(cJSON *prev, cJSON *item) { prev->next = item; item->prev = prev; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _prev$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx
  0000b	8b 55 0c	 mov	 edx, DWORD PTR _item$[ebp]
  0000e	8b 45 08	 mov	 eax, DWORD PTR _prev$[ebp]
  00011	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
_suffix_object ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _skip
_TEXT	SEGMENT
_in$ = 8						; size = 4
_skip	PROC						; COMDAT

; 259  : static const char *skip(const char *in) { while (in && *in && (unsigned char)*in <= 32) in++; return in; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$LN2@skip:
  00003	83 7d 08 00	 cmp	 DWORD PTR _in$[ebp], 0
  00007	74 20		 je	 SHORT $LN3@skip
  00009	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  0000c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0000f	85 c9		 test	 ecx, ecx
  00011	74 16		 je	 SHORT $LN3@skip
  00013	8b 55 08	 mov	 edx, DWORD PTR _in$[ebp]
  00016	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00019	83 f8 20	 cmp	 eax, 32			; 00000020H
  0001c	7f 0b		 jg	 SHORT $LN3@skip
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _in$[ebp]
  00021	83 c1 01	 add	 ecx, 1
  00024	89 4d 08	 mov	 DWORD PTR _in$[ebp], ecx
  00027	eb da		 jmp	 SHORT $LN2@skip
$LN3@skip:
  00029	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_skip	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _print_object
_TEXT	SEGMENT
tv160 = -56						; size = 4
tv72 = -52						; size = 4
_j$ = -48						; size = 4
_str$ = -44						; size = 4
_ret$ = -40						; size = 4
_fail$ = -36						; size = 4
_len$ = -32						; size = 4
_out$ = -28						; size = 4
_child$ = -24						; size = 4
_numentries$ = -20					; size = 4
_names$ = -16						; size = 4
_entries$ = -12						; size = 4
_i$ = -8						; size = 4
_ptr$ = -4						; size = 4
_item$ = 8						; size = 4
_depth$ = 12						; size = 4
_fmt$ = 16						; size = 4
_print_object PROC					; COMDAT

; 441  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	56		 push	 esi

; 442  : 	char **entries = 0, **names = 0;

  00007	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _entries$[ebp], 0
  0000e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _names$[ebp], 0

; 443  : 	char *out = 0, *ptr, *ret, *str; int len = 7, i = 0, j;

  00015	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _out$[ebp], 0
  0001c	c7 45 e0 07 00
	00 00		 mov	 DWORD PTR _len$[ebp], 7
  00023	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 444  : 	cJSON *child = item->child;

  0002a	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  0002d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00030	89 4d e8	 mov	 DWORD PTR _child$[ebp], ecx

; 445  : 	int numentries = 0, fail = 0;

  00033	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _numentries$[ebp], 0
  0003a	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _fail$[ebp], 0
$LN2@print_obje:

; 446  : 	/* Count the number of entries. */
; 447  : 	while (child) numentries++, child = child->next;

  00041	83 7d e8 00	 cmp	 DWORD PTR _child$[ebp], 0
  00045	74 13		 je	 SHORT $LN3@print_obje
  00047	8b 55 ec	 mov	 edx, DWORD PTR _numentries$[ebp]
  0004a	83 c2 01	 add	 edx, 1
  0004d	89 55 ec	 mov	 DWORD PTR _numentries$[ebp], edx
  00050	8b 45 e8	 mov	 eax, DWORD PTR _child$[ebp]
  00053	8b 08		 mov	 ecx, DWORD PTR [eax]
  00055	89 4d e8	 mov	 DWORD PTR _child$[ebp], ecx
  00058	eb e7		 jmp	 SHORT $LN2@print_obje
$LN3@print_obje:

; 448  : 	/* Explicitly handle empty object case */
; 449  : 	if (!numentries)

  0005a	83 7d ec 00	 cmp	 DWORD PTR _numentries$[ebp], 0
  0005e	0f 85 b3 00 00
	00		 jne	 $LN21@print_obje

; 450  : 	{
; 451  : 		out = (char*)cJSON_malloc(fmt ? depth + 4 : 3);

  00064	83 7d 10 00	 cmp	 DWORD PTR _fmt$[ebp], 0
  00068	74 0b		 je	 SHORT $LN41@print_obje
  0006a	8b 55 0c	 mov	 edx, DWORD PTR _depth$[ebp]
  0006d	83 c2 04	 add	 edx, 4
  00070	89 55 cc	 mov	 DWORD PTR tv72[ebp], edx
  00073	eb 07		 jmp	 SHORT $LN42@print_obje
$LN41@print_obje:
  00075	c7 45 cc 03 00
	00 00		 mov	 DWORD PTR tv72[ebp], 3
$LN42@print_obje:
  0007c	8b 45 cc	 mov	 eax, DWORD PTR tv72[ebp]
  0007f	50		 push	 eax
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_malloc
  00086	83 c4 04	 add	 esp, 4
  00089	89 45 e4	 mov	 DWORD PTR _out$[ebp], eax

; 452  : 		if (!out)	return 0;

  0008c	83 7d e4 00	 cmp	 DWORD PTR _out$[ebp], 0
  00090	75 07		 jne	 SHORT $LN22@print_obje
  00092	33 c0		 xor	 eax, eax
  00094	e9 37 04 00 00	 jmp	 $LN1@print_obje
$LN22@print_obje:

; 453  : 		ptr = out; *ptr++ = '{';

  00099	8b 4d e4	 mov	 ecx, DWORD PTR _out$[ebp]
  0009c	89 4d fc	 mov	 DWORD PTR _ptr$[ebp], ecx
  0009f	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  000a2	c6 02 7b	 mov	 BYTE PTR [edx], 123	; 0000007bH
  000a5	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  000a8	83 c0 01	 add	 eax, 1
  000ab	89 45 fc	 mov	 DWORD PTR _ptr$[ebp], eax

; 454  : 		if (fmt) { *ptr++ = '\n'; for (i = 0; i<depth - 1; i++) *ptr++ = '\t'; }

  000ae	83 7d 10 00	 cmp	 DWORD PTR _fmt$[ebp], 0
  000b2	74 3d		 je	 SHORT $LN23@print_obje
  000b4	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  000b7	c6 01 0a	 mov	 BYTE PTR [ecx], 10	; 0000000aH
  000ba	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  000bd	83 c2 01	 add	 edx, 1
  000c0	89 55 fc	 mov	 DWORD PTR _ptr$[ebp], edx
  000c3	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ca	eb 09		 jmp	 SHORT $LN6@print_obje
$LN4@print_obje:
  000cc	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000cf	83 c0 01	 add	 eax, 1
  000d2	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN6@print_obje:
  000d5	8b 4d 0c	 mov	 ecx, DWORD PTR _depth$[ebp]
  000d8	83 e9 01	 sub	 ecx, 1
  000db	39 4d f8	 cmp	 DWORD PTR _i$[ebp], ecx
  000de	7d 11		 jge	 SHORT $LN23@print_obje
  000e0	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  000e3	c6 02 09	 mov	 BYTE PTR [edx], 9
  000e6	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  000e9	83 c0 01	 add	 eax, 1
  000ec	89 45 fc	 mov	 DWORD PTR _ptr$[ebp], eax
  000ef	eb db		 jmp	 SHORT $LN4@print_obje
$LN23@print_obje:

; 455  : 		*ptr++ = '}'; *ptr++ = 0;

  000f1	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  000f4	c6 01 7d	 mov	 BYTE PTR [ecx], 125	; 0000007dH
  000f7	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  000fa	83 c2 01	 add	 edx, 1
  000fd	89 55 fc	 mov	 DWORD PTR _ptr$[ebp], edx
  00100	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  00103	c6 00 00	 mov	 BYTE PTR [eax], 0
  00106	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00109	83 c1 01	 add	 ecx, 1
  0010c	89 4d fc	 mov	 DWORD PTR _ptr$[ebp], ecx

; 456  : 		return out;

  0010f	8b 45 e4	 mov	 eax, DWORD PTR _out$[ebp]
  00112	e9 b9 03 00 00	 jmp	 $LN1@print_obje
$LN21@print_obje:

; 457  : 	}
; 458  : 	/* Allocate space for the names and the objects */
; 459  : 	entries = (char**)cJSON_malloc(numentries * sizeof(char*));

  00117	8b 55 ec	 mov	 edx, DWORD PTR _numentries$[ebp]
  0011a	c1 e2 02	 shl	 edx, 2
  0011d	52		 push	 edx
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_malloc
  00124	83 c4 04	 add	 esp, 4
  00127	89 45 f4	 mov	 DWORD PTR _entries$[ebp], eax

; 460  : 	if (!entries) return 0;

  0012a	83 7d f4 00	 cmp	 DWORD PTR _entries$[ebp], 0
  0012e	75 07		 jne	 SHORT $LN24@print_obje
  00130	33 c0		 xor	 eax, eax
  00132	e9 99 03 00 00	 jmp	 $LN1@print_obje
$LN24@print_obje:

; 461  : 	names = (char**)cJSON_malloc(numentries * sizeof(char*));

  00137	8b 45 ec	 mov	 eax, DWORD PTR _numentries$[ebp]
  0013a	c1 e0 02	 shl	 eax, 2
  0013d	50		 push	 eax
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_malloc
  00144	83 c4 04	 add	 esp, 4
  00147	89 45 f0	 mov	 DWORD PTR _names$[ebp], eax

; 462  : 	if (!names) { cJSON_free(entries); return 0; }

  0014a	83 7d f0 00	 cmp	 DWORD PTR _names$[ebp], 0
  0014e	75 14		 jne	 SHORT $LN25@print_obje
  00150	8b 4d f4	 mov	 ecx, DWORD PTR _entries$[ebp]
  00153	51		 push	 ecx
  00154	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_free
  0015a	83 c4 04	 add	 esp, 4
  0015d	33 c0		 xor	 eax, eax
  0015f	e9 6c 03 00 00	 jmp	 $LN1@print_obje
$LN25@print_obje:

; 463  : 	memset(entries, 0, sizeof(char*)*numentries);

  00164	8b 55 ec	 mov	 edx, DWORD PTR _numentries$[ebp]
  00167	c1 e2 02	 shl	 edx, 2
  0016a	52		 push	 edx
  0016b	6a 00		 push	 0
  0016d	8b 45 f4	 mov	 eax, DWORD PTR _entries$[ebp]
  00170	50		 push	 eax
  00171	e8 00 00 00 00	 call	 _memset
  00176	83 c4 0c	 add	 esp, 12			; 0000000cH

; 464  : 	memset(names, 0, sizeof(char*)*numentries);

  00179	8b 4d ec	 mov	 ecx, DWORD PTR _numentries$[ebp]
  0017c	c1 e1 02	 shl	 ecx, 2
  0017f	51		 push	 ecx
  00180	6a 00		 push	 0
  00182	8b 55 f0	 mov	 edx, DWORD PTR _names$[ebp]
  00185	52		 push	 edx
  00186	e8 00 00 00 00	 call	 _memset
  0018b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 465  : 
; 466  : 	/* Collect all the results into our arrays: */
; 467  : 	child = item->child; depth++; if (fmt) len += depth;

  0018e	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00191	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00194	89 4d e8	 mov	 DWORD PTR _child$[ebp], ecx
  00197	8b 55 0c	 mov	 edx, DWORD PTR _depth$[ebp]
  0019a	83 c2 01	 add	 edx, 1
  0019d	89 55 0c	 mov	 DWORD PTR _depth$[ebp], edx
  001a0	83 7d 10 00	 cmp	 DWORD PTR _fmt$[ebp], 0
  001a4	74 09		 je	 SHORT $LN7@print_obje
  001a6	8b 45 e0	 mov	 eax, DWORD PTR _len$[ebp]
  001a9	03 45 0c	 add	 eax, DWORD PTR _depth$[ebp]
  001ac	89 45 e0	 mov	 DWORD PTR _len$[ebp], eax
$LN7@print_obje:

; 468  : 	while (child)

  001af	83 7d e8 00	 cmp	 DWORD PTR _child$[ebp], 0
  001b3	0f 84 ab 00 00
	00		 je	 $LN8@print_obje

; 469  : 	{
; 470  : 		names[i] = str = print_string_ptr(child->string);

  001b9	8b 4d e8	 mov	 ecx, DWORD PTR _child$[ebp]
  001bc	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  001bf	52		 push	 edx
  001c0	e8 00 00 00 00	 call	 _print_string_ptr
  001c5	83 c4 04	 add	 esp, 4
  001c8	89 45 d4	 mov	 DWORD PTR _str$[ebp], eax
  001cb	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  001ce	8b 4d f0	 mov	 ecx, DWORD PTR _names$[ebp]
  001d1	8b 55 d4	 mov	 edx, DWORD PTR _str$[ebp]
  001d4	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 471  : 		entries[i++] = ret = print_value(child, depth, fmt);

  001d7	8b 45 10	 mov	 eax, DWORD PTR _fmt$[ebp]
  001da	50		 push	 eax
  001db	8b 4d 0c	 mov	 ecx, DWORD PTR _depth$[ebp]
  001de	51		 push	 ecx
  001df	8b 55 e8	 mov	 edx, DWORD PTR _child$[ebp]
  001e2	52		 push	 edx
  001e3	e8 00 00 00 00	 call	 _print_value
  001e8	83 c4 0c	 add	 esp, 12			; 0000000cH
  001eb	89 45 d8	 mov	 DWORD PTR _ret$[ebp], eax
  001ee	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  001f1	8b 4d f4	 mov	 ecx, DWORD PTR _entries$[ebp]
  001f4	8b 55 d8	 mov	 edx, DWORD PTR _ret$[ebp]
  001f7	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
  001fa	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  001fd	83 c0 01	 add	 eax, 1
  00200	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax

; 472  : 		if (str && ret) len += strlen(ret) + strlen(str) + 2 + (fmt ? 2 + depth : 0); else fail = 1;

  00203	83 7d d4 00	 cmp	 DWORD PTR _str$[ebp], 0
  00207	74 47		 je	 SHORT $LN27@print_obje
  00209	83 7d d8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0020d	74 41		 je	 SHORT $LN27@print_obje
  0020f	83 7d 10 00	 cmp	 DWORD PTR _fmt$[ebp], 0
  00213	74 0b		 je	 SHORT $LN43@print_obje
  00215	8b 4d 0c	 mov	 ecx, DWORD PTR _depth$[ebp]
  00218	83 c1 02	 add	 ecx, 2
  0021b	89 4d c8	 mov	 DWORD PTR tv160[ebp], ecx
  0021e	eb 07		 jmp	 SHORT $LN44@print_obje
$LN43@print_obje:
  00220	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv160[ebp], 0
$LN44@print_obje:
  00227	8b 55 d8	 mov	 edx, DWORD PTR _ret$[ebp]
  0022a	52		 push	 edx
  0022b	e8 00 00 00 00	 call	 _strlen
  00230	83 c4 04	 add	 esp, 4
  00233	8b f0		 mov	 esi, eax
  00235	8b 45 d4	 mov	 eax, DWORD PTR _str$[ebp]
  00238	50		 push	 eax
  00239	e8 00 00 00 00	 call	 _strlen
  0023e	83 c4 04	 add	 esp, 4
  00241	03 75 c8	 add	 esi, DWORD PTR tv160[ebp]
  00244	8d 4c 30 02	 lea	 ecx, DWORD PTR [eax+esi+2]
  00248	03 4d e0	 add	 ecx, DWORD PTR _len$[ebp]
  0024b	89 4d e0	 mov	 DWORD PTR _len$[ebp], ecx
  0024e	eb 07		 jmp	 SHORT $LN28@print_obje
$LN27@print_obje:
  00250	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _fail$[ebp], 1
$LN28@print_obje:

; 473  : 		child = child->next;

  00257	8b 55 e8	 mov	 edx, DWORD PTR _child$[ebp]
  0025a	8b 02		 mov	 eax, DWORD PTR [edx]
  0025c	89 45 e8	 mov	 DWORD PTR _child$[ebp], eax

; 474  : 	}

  0025f	e9 4b ff ff ff	 jmp	 $LN7@print_obje
$LN8@print_obje:

; 475  : 
; 476  : 	/* Try to allocate the output string */
; 477  : 	if (!fail) out = (char*)cJSON_malloc(len);

  00264	83 7d dc 00	 cmp	 DWORD PTR _fail$[ebp], 0
  00268	75 10		 jne	 SHORT $LN29@print_obje
  0026a	8b 4d e0	 mov	 ecx, DWORD PTR _len$[ebp]
  0026d	51		 push	 ecx
  0026e	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_malloc
  00274	83 c4 04	 add	 esp, 4
  00277	89 45 e4	 mov	 DWORD PTR _out$[ebp], eax
$LN29@print_obje:

; 478  : 	if (!out) fail = 1;

  0027a	83 7d e4 00	 cmp	 DWORD PTR _out$[ebp], 0
  0027e	75 07		 jne	 SHORT $LN30@print_obje
  00280	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _fail$[ebp], 1
$LN30@print_obje:

; 479  : 
; 480  : 	/* Handle failure */
; 481  : 	if (fail)

  00287	83 7d dc 00	 cmp	 DWORD PTR _fail$[ebp], 0
  0028b	74 7b		 je	 SHORT $LN31@print_obje

; 482  : 	{
; 483  : 		for (i = 0; i<numentries; i++) { if (names[i]) cJSON_free(names[i]); if (entries[i]) cJSON_free(entries[i]); }

  0028d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00294	eb 09		 jmp	 SHORT $LN11@print_obje
$LN9@print_obje:
  00296	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00299	83 c2 01	 add	 edx, 1
  0029c	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN11@print_obje:
  0029f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  002a2	3b 45 ec	 cmp	 eax, DWORD PTR _numentries$[ebp]
  002a5	7d 40		 jge	 SHORT $LN10@print_obje
  002a7	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  002aa	8b 55 f0	 mov	 edx, DWORD PTR _names$[ebp]
  002ad	83 3c 8a 00	 cmp	 DWORD PTR [edx+ecx*4], 0
  002b1	74 13		 je	 SHORT $LN32@print_obje
  002b3	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  002b6	8b 4d f0	 mov	 ecx, DWORD PTR _names$[ebp]
  002b9	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  002bc	52		 push	 edx
  002bd	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_free
  002c3	83 c4 04	 add	 esp, 4
$LN32@print_obje:
  002c6	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  002c9	8b 4d f4	 mov	 ecx, DWORD PTR _entries$[ebp]
  002cc	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  002d0	74 13		 je	 SHORT $LN33@print_obje
  002d2	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  002d5	8b 45 f4	 mov	 eax, DWORD PTR _entries$[ebp]
  002d8	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  002db	51		 push	 ecx
  002dc	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_free
  002e2	83 c4 04	 add	 esp, 4
$LN33@print_obje:
  002e5	eb af		 jmp	 SHORT $LN9@print_obje
$LN10@print_obje:

; 484  : 		cJSON_free(names); cJSON_free(entries);

  002e7	8b 55 f0	 mov	 edx, DWORD PTR _names$[ebp]
  002ea	52		 push	 edx
  002eb	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_free
  002f1	83 c4 04	 add	 esp, 4
  002f4	8b 45 f4	 mov	 eax, DWORD PTR _entries$[ebp]
  002f7	50		 push	 eax
  002f8	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_free
  002fe	83 c4 04	 add	 esp, 4

; 485  : 		return 0;

  00301	33 c0		 xor	 eax, eax
  00303	e9 c8 01 00 00	 jmp	 $LN1@print_obje
$LN31@print_obje:

; 486  : 	}
; 487  : 
; 488  : 	/* Compose the output: */
; 489  : 	*out = '{'; ptr = out + 1; if (fmt)*ptr++ = '\n'; *ptr = 0;

  00308	8b 4d e4	 mov	 ecx, DWORD PTR _out$[ebp]
  0030b	c6 01 7b	 mov	 BYTE PTR [ecx], 123	; 0000007bH
  0030e	8b 55 e4	 mov	 edx, DWORD PTR _out$[ebp]
  00311	83 c2 01	 add	 edx, 1
  00314	89 55 fc	 mov	 DWORD PTR _ptr$[ebp], edx
  00317	83 7d 10 00	 cmp	 DWORD PTR _fmt$[ebp], 0
  0031b	74 0f		 je	 SHORT $LN34@print_obje
  0031d	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  00320	c6 00 0a	 mov	 BYTE PTR [eax], 10	; 0000000aH
  00323	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00326	83 c1 01	 add	 ecx, 1
  00329	89 4d fc	 mov	 DWORD PTR _ptr$[ebp], ecx
$LN34@print_obje:
  0032c	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  0032f	c6 02 00	 mov	 BYTE PTR [edx], 0

; 490  : 	for (i = 0; i<numentries; i++)

  00332	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00339	eb 09		 jmp	 SHORT $LN14@print_obje
$LN12@print_obje:
  0033b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0033e	83 c0 01	 add	 eax, 1
  00341	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN14@print_obje:
  00344	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  00347	3b 4d ec	 cmp	 ecx, DWORD PTR _numentries$[ebp]
  0034a	0f 8d 11 01 00
	00		 jge	 $LN13@print_obje

; 491  : 	{
; 492  : 		if (fmt) for (j = 0; j<depth; j++) *ptr++ = '\t';

  00350	83 7d 10 00	 cmp	 DWORD PTR _fmt$[ebp], 0
  00354	74 2b		 je	 SHORT $LN35@print_obje
  00356	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  0035d	eb 09		 jmp	 SHORT $LN17@print_obje
$LN15@print_obje:
  0035f	8b 55 d0	 mov	 edx, DWORD PTR _j$[ebp]
  00362	83 c2 01	 add	 edx, 1
  00365	89 55 d0	 mov	 DWORD PTR _j$[ebp], edx
$LN17@print_obje:
  00368	8b 45 d0	 mov	 eax, DWORD PTR _j$[ebp]
  0036b	3b 45 0c	 cmp	 eax, DWORD PTR _depth$[ebp]
  0036e	7d 11		 jge	 SHORT $LN35@print_obje
  00370	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00373	c6 01 09	 mov	 BYTE PTR [ecx], 9
  00376	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  00379	83 c2 01	 add	 edx, 1
  0037c	89 55 fc	 mov	 DWORD PTR _ptr$[ebp], edx
  0037f	eb de		 jmp	 SHORT $LN15@print_obje
$LN35@print_obje:

; 493  : 		strcpy(ptr, names[i]); ptr += strlen(names[i]);

  00381	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00384	8b 4d f0	 mov	 ecx, DWORD PTR _names$[ebp]
  00387	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0038a	52		 push	 edx
  0038b	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  0038e	50		 push	 eax
  0038f	e8 00 00 00 00	 call	 _strcpy
  00394	83 c4 08	 add	 esp, 8
  00397	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0039a	8b 55 f0	 mov	 edx, DWORD PTR _names$[ebp]
  0039d	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  003a0	50		 push	 eax
  003a1	e8 00 00 00 00	 call	 _strlen
  003a6	83 c4 04	 add	 esp, 4
  003a9	03 45 fc	 add	 eax, DWORD PTR _ptr$[ebp]
  003ac	89 45 fc	 mov	 DWORD PTR _ptr$[ebp], eax

; 494  : 		*ptr++ = ':'; if (fmt) *ptr++ = '\t';

  003af	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  003b2	c6 01 3a	 mov	 BYTE PTR [ecx], 58	; 0000003aH
  003b5	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  003b8	83 c2 01	 add	 edx, 1
  003bb	89 55 fc	 mov	 DWORD PTR _ptr$[ebp], edx
  003be	83 7d 10 00	 cmp	 DWORD PTR _fmt$[ebp], 0
  003c2	74 0f		 je	 SHORT $LN36@print_obje
  003c4	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  003c7	c6 00 09	 mov	 BYTE PTR [eax], 9
  003ca	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  003cd	83 c1 01	 add	 ecx, 1
  003d0	89 4d fc	 mov	 DWORD PTR _ptr$[ebp], ecx
$LN36@print_obje:

; 495  : 		strcpy(ptr, entries[i]); ptr += strlen(entries[i]);

  003d3	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  003d6	8b 45 f4	 mov	 eax, DWORD PTR _entries$[ebp]
  003d9	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  003dc	51		 push	 ecx
  003dd	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  003e0	52		 push	 edx
  003e1	e8 00 00 00 00	 call	 _strcpy
  003e6	83 c4 08	 add	 esp, 8
  003e9	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  003ec	8b 4d f4	 mov	 ecx, DWORD PTR _entries$[ebp]
  003ef	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  003f2	52		 push	 edx
  003f3	e8 00 00 00 00	 call	 _strlen
  003f8	83 c4 04	 add	 esp, 4
  003fb	03 45 fc	 add	 eax, DWORD PTR _ptr$[ebp]
  003fe	89 45 fc	 mov	 DWORD PTR _ptr$[ebp], eax

; 496  : 		if (i != numentries - 1) *ptr++ = ',';

  00401	8b 45 ec	 mov	 eax, DWORD PTR _numentries$[ebp]
  00404	83 e8 01	 sub	 eax, 1
  00407	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  0040a	74 0f		 je	 SHORT $LN37@print_obje
  0040c	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  0040f	c6 01 2c	 mov	 BYTE PTR [ecx], 44	; 0000002cH
  00412	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  00415	83 c2 01	 add	 edx, 1
  00418	89 55 fc	 mov	 DWORD PTR _ptr$[ebp], edx
$LN37@print_obje:

; 497  : 		if (fmt) *ptr++ = '\n'; *ptr = 0;

  0041b	83 7d 10 00	 cmp	 DWORD PTR _fmt$[ebp], 0
  0041f	74 0f		 je	 SHORT $LN38@print_obje
  00421	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  00424	c6 00 0a	 mov	 BYTE PTR [eax], 10	; 0000000aH
  00427	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  0042a	83 c1 01	 add	 ecx, 1
  0042d	89 4d fc	 mov	 DWORD PTR _ptr$[ebp], ecx
$LN38@print_obje:
  00430	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  00433	c6 02 00	 mov	 BYTE PTR [edx], 0

; 498  : 		cJSON_free(names[i]); cJSON_free(entries[i]);

  00436	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00439	8b 4d f0	 mov	 ecx, DWORD PTR _names$[ebp]
  0043c	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  0043f	52		 push	 edx
  00440	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_free
  00446	83 c4 04	 add	 esp, 4
  00449	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0044c	8b 4d f4	 mov	 ecx, DWORD PTR _entries$[ebp]
  0044f	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00452	52		 push	 edx
  00453	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_free
  00459	83 c4 04	 add	 esp, 4

; 499  : 	}

  0045c	e9 da fe ff ff	 jmp	 $LN12@print_obje
$LN13@print_obje:

; 500  : 
; 501  : 	cJSON_free(names); cJSON_free(entries);

  00461	8b 45 f0	 mov	 eax, DWORD PTR _names$[ebp]
  00464	50		 push	 eax
  00465	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_free
  0046b	83 c4 04	 add	 esp, 4
  0046e	8b 4d f4	 mov	 ecx, DWORD PTR _entries$[ebp]
  00471	51		 push	 ecx
  00472	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_free
  00478	83 c4 04	 add	 esp, 4

; 502  : 	if (fmt) for (i = 0; i<depth - 1; i++) *ptr++ = '\t';

  0047b	83 7d 10 00	 cmp	 DWORD PTR _fmt$[ebp], 0
  0047f	74 2e		 je	 SHORT $LN39@print_obje
  00481	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00488	eb 09		 jmp	 SHORT $LN20@print_obje
$LN18@print_obje:
  0048a	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0048d	83 c2 01	 add	 edx, 1
  00490	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
$LN20@print_obje:
  00493	8b 45 0c	 mov	 eax, DWORD PTR _depth$[ebp]
  00496	83 e8 01	 sub	 eax, 1
  00499	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  0049c	7d 11		 jge	 SHORT $LN39@print_obje
  0049e	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  004a1	c6 01 09	 mov	 BYTE PTR [ecx], 9
  004a4	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  004a7	83 c2 01	 add	 edx, 1
  004aa	89 55 fc	 mov	 DWORD PTR _ptr$[ebp], edx
  004ad	eb db		 jmp	 SHORT $LN18@print_obje
$LN39@print_obje:

; 503  : 	*ptr++ = '}'; *ptr++ = 0;

  004af	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  004b2	c6 00 7d	 mov	 BYTE PTR [eax], 125	; 0000007dH
  004b5	8b 4d fc	 mov	 ecx, DWORD PTR _ptr$[ebp]
  004b8	83 c1 01	 add	 ecx, 1
  004bb	89 4d fc	 mov	 DWORD PTR _ptr$[ebp], ecx
  004be	8b 55 fc	 mov	 edx, DWORD PTR _ptr$[ebp]
  004c1	c6 02 00	 mov	 BYTE PTR [edx], 0
  004c4	8b 45 fc	 mov	 eax, DWORD PTR _ptr$[ebp]
  004c7	83 c0 01	 add	 eax, 1
  004ca	89 45 fc	 mov	 DWORD PTR _ptr$[ebp], eax

; 504  : 	return out;

  004cd	8b 45 e4	 mov	 eax, DWORD PTR _out$[ebp]
$LN1@print_obje:

; 505  : }

  004d0	5e		 pop	 esi
  004d1	8b e5		 mov	 esp, ebp
  004d3	5d		 pop	 ebp
  004d4	c3		 ret	 0
_print_object ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _parse_object
_TEXT	SEGMENT
_new_item$1 = -8					; size = 4
_child$ = -4						; size = 4
_item$ = 8						; size = 4
_value$ = 12						; size = 4
_parse_object PROC					; COMDAT

; 405  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 406  : 	cJSON *child;
; 407  : 	if (*value != '{') { ep = value; return 0; }	/* not an object! */

  00006	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  00009	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0000c	83 f9 7b	 cmp	 ecx, 123		; 0000007bH
  0000f	74 10		 je	 SHORT $LN4@parse_obje
  00011	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp]
  00014	89 15 00 00 00
	00		 mov	 DWORD PTR _ep, edx
  0001a	33 c0		 xor	 eax, eax
  0001c	e9 dc 01 00 00	 jmp	 $LN1@parse_obje
$LN4@parse_obje:

; 408  : 
; 409  : 	item->type = cJSON_Object;

  00021	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00024	c7 40 0c 06 00
	00 00		 mov	 DWORD PTR [eax+12], 6

; 410  : 	value = skip(value + 1);

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  0002e	83 c1 01	 add	 ecx, 1
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _skip
  00037	83 c4 04	 add	 esp, 4
  0003a	89 45 0c	 mov	 DWORD PTR _value$[ebp], eax

; 411  : 	if (*value == '}') return value + 1;	/* empty array. */

  0003d	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp]
  00040	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00043	83 f8 7d	 cmp	 eax, 125		; 0000007dH
  00046	75 0b		 jne	 SHORT $LN5@parse_obje
  00048	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  0004b	83 c0 01	 add	 eax, 1
  0004e	e9 aa 01 00 00	 jmp	 $LN1@parse_obje
$LN5@parse_obje:

; 412  : 
; 413  : 	item->child = child = cJSON_New_Item();

  00053	e8 00 00 00 00	 call	 _cJSON_New_Item
  00058	89 45 fc	 mov	 DWORD PTR _child$[ebp], eax
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _child$[ebp]
  00061	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 414  : 	if (!item->child) return 0;

  00064	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00067	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0006b	75 07		 jne	 SHORT $LN6@parse_obje
  0006d	33 c0		 xor	 eax, eax
  0006f	e9 89 01 00 00	 jmp	 $LN1@parse_obje
$LN6@parse_obje:

; 415  : 	value = skip(parse_string(child, skip(value)));

  00074	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 _skip
  0007d	83 c4 04	 add	 esp, 4
  00080	50		 push	 eax
  00081	8b 55 fc	 mov	 edx, DWORD PTR _child$[ebp]
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 _parse_string
  0008a	83 c4 08	 add	 esp, 8
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _skip
  00093	83 c4 04	 add	 esp, 4
  00096	89 45 0c	 mov	 DWORD PTR _value$[ebp], eax

; 416  : 	if (!value) return 0;

  00099	83 7d 0c 00	 cmp	 DWORD PTR _value$[ebp], 0
  0009d	75 07		 jne	 SHORT $LN7@parse_obje
  0009f	33 c0		 xor	 eax, eax
  000a1	e9 57 01 00 00	 jmp	 $LN1@parse_obje
$LN7@parse_obje:

; 417  : 	child->string = child->valuestring; child->valuestring = 0;

  000a6	8b 45 fc	 mov	 eax, DWORD PTR _child$[ebp]
  000a9	8b 4d fc	 mov	 ecx, DWORD PTR _child$[ebp]
  000ac	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000af	89 50 20	 mov	 DWORD PTR [eax+32], edx
  000b2	8b 45 fc	 mov	 eax, DWORD PTR _child$[ebp]
  000b5	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 418  : 	if (*value != ':') { ep = value; return 0; }	/* fail! */

  000bc	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  000bf	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000c2	83 fa 3a	 cmp	 edx, 58			; 0000003aH
  000c5	74 0f		 je	 SHORT $LN8@parse_obje
  000c7	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  000ca	a3 00 00 00 00	 mov	 DWORD PTR _ep, eax
  000cf	33 c0		 xor	 eax, eax
  000d1	e9 27 01 00 00	 jmp	 $LN1@parse_obje
$LN8@parse_obje:

; 419  : 	value = skip(parse_value(child, skip(value + 1)));	/* skip any spacing, get the value. */

  000d6	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  000d9	83 c1 01	 add	 ecx, 1
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 _skip
  000e2	83 c4 04	 add	 esp, 4
  000e5	50		 push	 eax
  000e6	8b 55 fc	 mov	 edx, DWORD PTR _child$[ebp]
  000e9	52		 push	 edx
  000ea	e8 00 00 00 00	 call	 _parse_value
  000ef	83 c4 08	 add	 esp, 8
  000f2	50		 push	 eax
  000f3	e8 00 00 00 00	 call	 _skip
  000f8	83 c4 04	 add	 esp, 4
  000fb	89 45 0c	 mov	 DWORD PTR _value$[ebp], eax

; 420  : 	if (!value) return 0;

  000fe	83 7d 0c 00	 cmp	 DWORD PTR _value$[ebp], 0
  00102	75 07		 jne	 SHORT $LN2@parse_obje
  00104	33 c0		 xor	 eax, eax
  00106	e9 f2 00 00 00	 jmp	 $LN1@parse_obje
$LN2@parse_obje:

; 421  : 
; 422  : 	while (*value == ',')

  0010b	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  0010e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00111	83 f9 2c	 cmp	 ecx, 44			; 0000002cH
  00114	0f 85 c5 00 00
	00		 jne	 $LN3@parse_obje

; 423  : 	{
; 424  : 		cJSON *new_item;
; 425  : 		if (!(new_item = cJSON_New_Item()))	return 0; /* memory fail */

  0011a	e8 00 00 00 00	 call	 _cJSON_New_Item
  0011f	89 45 f8	 mov	 DWORD PTR _new_item$1[ebp], eax
  00122	83 7d f8 00	 cmp	 DWORD PTR _new_item$1[ebp], 0
  00126	75 07		 jne	 SHORT $LN10@parse_obje
  00128	33 c0		 xor	 eax, eax
  0012a	e9 ce 00 00 00	 jmp	 $LN1@parse_obje
$LN10@parse_obje:

; 426  : 		child->next = new_item; new_item->prev = child; child = new_item;

  0012f	8b 55 fc	 mov	 edx, DWORD PTR _child$[ebp]
  00132	8b 45 f8	 mov	 eax, DWORD PTR _new_item$1[ebp]
  00135	89 02		 mov	 DWORD PTR [edx], eax
  00137	8b 4d f8	 mov	 ecx, DWORD PTR _new_item$1[ebp]
  0013a	8b 55 fc	 mov	 edx, DWORD PTR _child$[ebp]
  0013d	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00140	8b 45 f8	 mov	 eax, DWORD PTR _new_item$1[ebp]
  00143	89 45 fc	 mov	 DWORD PTR _child$[ebp], eax

; 427  : 		value = skip(parse_string(child, skip(value + 1)));

  00146	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  00149	83 c1 01	 add	 ecx, 1
  0014c	51		 push	 ecx
  0014d	e8 00 00 00 00	 call	 _skip
  00152	83 c4 04	 add	 esp, 4
  00155	50		 push	 eax
  00156	8b 55 fc	 mov	 edx, DWORD PTR _child$[ebp]
  00159	52		 push	 edx
  0015a	e8 00 00 00 00	 call	 _parse_string
  0015f	83 c4 08	 add	 esp, 8
  00162	50		 push	 eax
  00163	e8 00 00 00 00	 call	 _skip
  00168	83 c4 04	 add	 esp, 4
  0016b	89 45 0c	 mov	 DWORD PTR _value$[ebp], eax

; 428  : 		if (!value) return 0;

  0016e	83 7d 0c 00	 cmp	 DWORD PTR _value$[ebp], 0
  00172	75 07		 jne	 SHORT $LN11@parse_obje
  00174	33 c0		 xor	 eax, eax
  00176	e9 82 00 00 00	 jmp	 $LN1@parse_obje
$LN11@parse_obje:

; 429  : 		child->string = child->valuestring; child->valuestring = 0;

  0017b	8b 45 fc	 mov	 eax, DWORD PTR _child$[ebp]
  0017e	8b 4d fc	 mov	 ecx, DWORD PTR _child$[ebp]
  00181	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00184	89 50 20	 mov	 DWORD PTR [eax+32], edx
  00187	8b 45 fc	 mov	 eax, DWORD PTR _child$[ebp]
  0018a	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 430  : 		if (*value != ':') { ep = value; return 0; }	/* fail! */

  00191	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  00194	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00197	83 fa 3a	 cmp	 edx, 58			; 0000003aH
  0019a	74 0c		 je	 SHORT $LN12@parse_obje
  0019c	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  0019f	a3 00 00 00 00	 mov	 DWORD PTR _ep, eax
  001a4	33 c0		 xor	 eax, eax
  001a6	eb 55		 jmp	 SHORT $LN1@parse_obje
$LN12@parse_obje:

; 431  : 		value = skip(parse_value(child, skip(value + 1)));	/* skip any spacing, get the value. */

  001a8	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  001ab	83 c1 01	 add	 ecx, 1
  001ae	51		 push	 ecx
  001af	e8 00 00 00 00	 call	 _skip
  001b4	83 c4 04	 add	 esp, 4
  001b7	50		 push	 eax
  001b8	8b 55 fc	 mov	 edx, DWORD PTR _child$[ebp]
  001bb	52		 push	 edx
  001bc	e8 00 00 00 00	 call	 _parse_value
  001c1	83 c4 08	 add	 esp, 8
  001c4	50		 push	 eax
  001c5	e8 00 00 00 00	 call	 _skip
  001ca	83 c4 04	 add	 esp, 4
  001cd	89 45 0c	 mov	 DWORD PTR _value$[ebp], eax

; 432  : 		if (!value) return 0;

  001d0	83 7d 0c 00	 cmp	 DWORD PTR _value$[ebp], 0
  001d4	75 04		 jne	 SHORT $LN13@parse_obje
  001d6	33 c0		 xor	 eax, eax
  001d8	eb 23		 jmp	 SHORT $LN1@parse_obje
$LN13@parse_obje:

; 433  : 	}

  001da	e9 2c ff ff ff	 jmp	 $LN2@parse_obje
$LN3@parse_obje:

; 434  : 
; 435  : 	if (*value == '}') return value + 1;	/* end of array */

  001df	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  001e2	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001e5	83 f9 7d	 cmp	 ecx, 125		; 0000007dH
  001e8	75 08		 jne	 SHORT $LN14@parse_obje
  001ea	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  001ed	83 c0 01	 add	 eax, 1
  001f0	eb 0b		 jmp	 SHORT $LN1@parse_obje
$LN14@parse_obje:

; 436  : 	ep = value; return 0;	/* malformed. */

  001f2	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp]
  001f5	89 15 00 00 00
	00		 mov	 DWORD PTR _ep, edx
  001fb	33 c0		 xor	 eax, eax
$LN1@parse_obje:

; 437  : }

  001fd	8b e5		 mov	 esp, ebp
  001ff	5d		 pop	 ebp
  00200	c3		 ret	 0
_parse_object ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _print_array
_TEXT	SEGMENT
tv130 = -40						; size = 4
_len$ = -36						; size = 4
_ret$ = -32						; size = 4
_fail$ = -28						; size = 4
_numentries$ = -24					; size = 4
_child$ = -20						; size = 4
_out$ = -16						; size = 4
_entries$ = -12						; size = 4
_ptr$ = -8						; size = 4
_i$ = -4						; size = 4
_item$ = 8						; size = 4
_depth$ = 12						; size = 4
_fmt$ = 16						; size = 4
_print_array PROC					; COMDAT

; 347  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 348  : 	char **entries;
; 349  : 	char *out = 0, *ptr, *ret; int len = 5;

  00006	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _out$[ebp], 0
  0000d	c7 45 dc 05 00
	00 00		 mov	 DWORD PTR _len$[ebp], 5

; 350  : 	cJSON *child = item->child;

  00014	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00017	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001a	89 4d ec	 mov	 DWORD PTR _child$[ebp], ecx

; 351  : 	int numentries = 0, i = 0, fail = 0;

  0001d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _numentries$[ebp], 0
  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002b	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _fail$[ebp], 0
$LN2@print_arra:

; 352  : 
; 353  : 	/* How many entries in the array? */
; 354  : 	while (child) numentries++, child = child->next;

  00032	83 7d ec 00	 cmp	 DWORD PTR _child$[ebp], 0
  00036	74 13		 je	 SHORT $LN3@print_arra
  00038	8b 55 e8	 mov	 edx, DWORD PTR _numentries$[ebp]
  0003b	83 c2 01	 add	 edx, 1
  0003e	89 55 e8	 mov	 DWORD PTR _numentries$[ebp], edx
  00041	8b 45 ec	 mov	 eax, DWORD PTR _child$[ebp]
  00044	8b 08		 mov	 ecx, DWORD PTR [eax]
  00046	89 4d ec	 mov	 DWORD PTR _child$[ebp], ecx
  00049	eb e7		 jmp	 SHORT $LN2@print_arra
$LN3@print_arra:

; 355  : 	/* Explicitly handle numentries==0 */
; 356  : 	if (!numentries)

  0004b	83 7d e8 00	 cmp	 DWORD PTR _numentries$[ebp], 0
  0004f	75 2d		 jne	 SHORT $LN12@print_arra

; 357  : 	{
; 358  : 		out = (char*)cJSON_malloc(3);

  00051	6a 03		 push	 3
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_malloc
  00059	83 c4 04	 add	 esp, 4
  0005c	89 45 f0	 mov	 DWORD PTR _out$[ebp], eax

; 359  : 		if (out) strcpy(out, "[]");

  0005f	83 7d f0 00	 cmp	 DWORD PTR _out$[ebp], 0
  00063	74 11		 je	 SHORT $LN13@print_arra
  00065	68 00 00 00 00	 push	 OFFSET $SG5355
  0006a	8b 55 f0	 mov	 edx, DWORD PTR _out$[ebp]
  0006d	52		 push	 edx
  0006e	e8 00 00 00 00	 call	 _strcpy
  00073	83 c4 08	 add	 esp, 8
$LN13@print_arra:

; 360  : 		return out;

  00076	8b 45 f0	 mov	 eax, DWORD PTR _out$[ebp]
  00079	e9 18 02 00 00	 jmp	 $LN1@print_arra
$LN12@print_arra:

; 361  : 	}
; 362  : 	/* Allocate an array to hold the values for each */
; 363  : 	entries = (char**)cJSON_malloc(numentries * sizeof(char*));

  0007e	8b 45 e8	 mov	 eax, DWORD PTR _numentries$[ebp]
  00081	c1 e0 02	 shl	 eax, 2
  00084	50		 push	 eax
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_malloc
  0008b	83 c4 04	 add	 esp, 4
  0008e	89 45 f4	 mov	 DWORD PTR _entries$[ebp], eax

; 364  : 	if (!entries) return 0;

  00091	83 7d f4 00	 cmp	 DWORD PTR _entries$[ebp], 0
  00095	75 07		 jne	 SHORT $LN14@print_arra
  00097	33 c0		 xor	 eax, eax
  00099	e9 f8 01 00 00	 jmp	 $LN1@print_arra
$LN14@print_arra:

; 365  : 	memset(entries, 0, numentries * sizeof(char*));

  0009e	8b 4d e8	 mov	 ecx, DWORD PTR _numentries$[ebp]
  000a1	c1 e1 02	 shl	 ecx, 2
  000a4	51		 push	 ecx
  000a5	6a 00		 push	 0
  000a7	8b 55 f4	 mov	 edx, DWORD PTR _entries$[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 _memset
  000b0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 366  : 	/* Retrieve all the results: */
; 367  : 	child = item->child;

  000b3	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  000b6	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000b9	89 4d ec	 mov	 DWORD PTR _child$[ebp], ecx
$LN4@print_arra:

; 368  : 	while (child && !fail)

  000bc	83 7d ec 00	 cmp	 DWORD PTR _child$[ebp], 0
  000c0	0f 84 80 00 00
	00		 je	 $LN5@print_arra
  000c6	83 7d e4 00	 cmp	 DWORD PTR _fail$[ebp], 0
  000ca	75 7a		 jne	 SHORT $LN5@print_arra

; 369  : 	{
; 370  : 		ret = print_value(child, depth + 1, fmt);

  000cc	8b 55 10	 mov	 edx, DWORD PTR _fmt$[ebp]
  000cf	52		 push	 edx
  000d0	8b 45 0c	 mov	 eax, DWORD PTR _depth$[ebp]
  000d3	83 c0 01	 add	 eax, 1
  000d6	50		 push	 eax
  000d7	8b 4d ec	 mov	 ecx, DWORD PTR _child$[ebp]
  000da	51		 push	 ecx
  000db	e8 00 00 00 00	 call	 _print_value
  000e0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e3	89 45 e0	 mov	 DWORD PTR _ret$[ebp], eax

; 371  : 		entries[i++] = ret;

  000e6	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000e9	8b 45 f4	 mov	 eax, DWORD PTR _entries$[ebp]
  000ec	8b 4d e0	 mov	 ecx, DWORD PTR _ret$[ebp]
  000ef	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx
  000f2	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000f5	83 c2 01	 add	 edx, 1
  000f8	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx

; 372  : 		if (ret) len += strlen(ret) + 2 + (fmt ? 1 : 0); else fail = 1;

  000fb	83 7d e0 00	 cmp	 DWORD PTR _ret$[ebp], 0
  000ff	74 31		 je	 SHORT $LN15@print_arra
  00101	83 7d 10 00	 cmp	 DWORD PTR _fmt$[ebp], 0
  00105	74 09		 je	 SHORT $LN24@print_arra
  00107	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  0010e	eb 07		 jmp	 SHORT $LN25@print_arra
$LN24@print_arra:
  00110	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv130[ebp], 0
$LN25@print_arra:
  00117	8b 45 e0	 mov	 eax, DWORD PTR _ret$[ebp]
  0011a	50		 push	 eax
  0011b	e8 00 00 00 00	 call	 _strlen
  00120	83 c4 04	 add	 esp, 4
  00123	8b 4d d8	 mov	 ecx, DWORD PTR tv130[ebp]
  00126	8d 54 08 02	 lea	 edx, DWORD PTR [eax+ecx+2]
  0012a	03 55 dc	 add	 edx, DWORD PTR _len$[ebp]
  0012d	89 55 dc	 mov	 DWORD PTR _len$[ebp], edx
  00130	eb 07		 jmp	 SHORT $LN16@print_arra
$LN15@print_arra:
  00132	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _fail$[ebp], 1
$LN16@print_arra:

; 373  : 		child = child->next;

  00139	8b 45 ec	 mov	 eax, DWORD PTR _child$[ebp]
  0013c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013e	89 4d ec	 mov	 DWORD PTR _child$[ebp], ecx

; 374  : 	}

  00141	e9 76 ff ff ff	 jmp	 $LN4@print_arra
$LN5@print_arra:

; 375  : 
; 376  : 	/* If we didn't fail, try to malloc the output string */
; 377  : 	if (!fail) out = (char*)cJSON_malloc(len);

  00146	83 7d e4 00	 cmp	 DWORD PTR _fail$[ebp], 0
  0014a	75 10		 jne	 SHORT $LN17@print_arra
  0014c	8b 55 dc	 mov	 edx, DWORD PTR _len$[ebp]
  0014f	52		 push	 edx
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_malloc
  00156	83 c4 04	 add	 esp, 4
  00159	89 45 f0	 mov	 DWORD PTR _out$[ebp], eax
$LN17@print_arra:

; 378  : 	/* If that fails, we fail. */
; 379  : 	if (!out) fail = 1;

  0015c	83 7d f0 00	 cmp	 DWORD PTR _out$[ebp], 0
  00160	75 07		 jne	 SHORT $LN18@print_arra
  00162	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _fail$[ebp], 1
$LN18@print_arra:

; 380  : 
; 381  : 	/* Handle failure. */
; 382  : 	if (fail)

  00169	83 7d e4 00	 cmp	 DWORD PTR _fail$[ebp], 0
  0016d	74 4f		 je	 SHORT $LN19@print_arra

; 383  : 	{
; 384  : 		for (i = 0; i<numentries; i++) if (entries[i]) cJSON_free(entries[i]);

  0016f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00176	eb 09		 jmp	 SHORT $LN8@print_arra
$LN6@print_arra:
  00178	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0017b	83 c0 01	 add	 eax, 1
  0017e	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN8@print_arra:
  00181	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00184	3b 4d e8	 cmp	 ecx, DWORD PTR _numentries$[ebp]
  00187	7d 21		 jge	 SHORT $LN7@print_arra
  00189	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0018c	8b 45 f4	 mov	 eax, DWORD PTR _entries$[ebp]
  0018f	83 3c 90 00	 cmp	 DWORD PTR [eax+edx*4], 0
  00193	74 13		 je	 SHORT $LN20@print_arra
  00195	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00198	8b 55 f4	 mov	 edx, DWORD PTR _entries$[ebp]
  0019b	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  0019e	50		 push	 eax
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_free
  001a5	83 c4 04	 add	 esp, 4
$LN20@print_arra:
  001a8	eb ce		 jmp	 SHORT $LN6@print_arra
$LN7@print_arra:

; 385  : 		cJSON_free(entries);

  001aa	8b 4d f4	 mov	 ecx, DWORD PTR _entries$[ebp]
  001ad	51		 push	 ecx
  001ae	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_free
  001b4	83 c4 04	 add	 esp, 4

; 386  : 		return 0;

  001b7	33 c0		 xor	 eax, eax
  001b9	e9 d8 00 00 00	 jmp	 $LN1@print_arra
$LN19@print_arra:

; 387  : 	}
; 388  : 
; 389  : 	/* Compose the output array. */
; 390  : 	*out = '[';

  001be	8b 55 f0	 mov	 edx, DWORD PTR _out$[ebp]
  001c1	c6 02 5b	 mov	 BYTE PTR [edx], 91	; 0000005bH

; 391  : 	ptr = out + 1; *ptr = 0;

  001c4	8b 45 f0	 mov	 eax, DWORD PTR _out$[ebp]
  001c7	83 c0 01	 add	 eax, 1
  001ca	89 45 f8	 mov	 DWORD PTR _ptr$[ebp], eax
  001cd	8b 4d f8	 mov	 ecx, DWORD PTR _ptr$[ebp]
  001d0	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 392  : 	for (i = 0; i<numentries; i++)

  001d3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001da	eb 09		 jmp	 SHORT $LN11@print_arra
$LN9@print_arra:
  001dc	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  001df	83 c2 01	 add	 edx, 1
  001e2	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN11@print_arra:
  001e5	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001e8	3b 45 e8	 cmp	 eax, DWORD PTR _numentries$[ebp]
  001eb	7d 7b		 jge	 SHORT $LN10@print_arra

; 393  : 	{
; 394  : 		strcpy(ptr, entries[i]); ptr += strlen(entries[i]);

  001ed	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  001f0	8b 55 f4	 mov	 edx, DWORD PTR _entries$[ebp]
  001f3	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  001f6	50		 push	 eax
  001f7	8b 4d f8	 mov	 ecx, DWORD PTR _ptr$[ebp]
  001fa	51		 push	 ecx
  001fb	e8 00 00 00 00	 call	 _strcpy
  00200	83 c4 08	 add	 esp, 8
  00203	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00206	8b 45 f4	 mov	 eax, DWORD PTR _entries$[ebp]
  00209	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  0020c	51		 push	 ecx
  0020d	e8 00 00 00 00	 call	 _strlen
  00212	83 c4 04	 add	 esp, 4
  00215	03 45 f8	 add	 eax, DWORD PTR _ptr$[ebp]
  00218	89 45 f8	 mov	 DWORD PTR _ptr$[ebp], eax

; 395  : 		if (i != numentries - 1) { *ptr++ = ','; if (fmt)*ptr++ = ' '; *ptr = 0; }

  0021b	8b 55 e8	 mov	 edx, DWORD PTR _numentries$[ebp]
  0021e	83 ea 01	 sub	 edx, 1
  00221	39 55 fc	 cmp	 DWORD PTR _i$[ebp], edx
  00224	74 2a		 je	 SHORT $LN21@print_arra
  00226	8b 45 f8	 mov	 eax, DWORD PTR _ptr$[ebp]
  00229	c6 00 2c	 mov	 BYTE PTR [eax], 44	; 0000002cH
  0022c	8b 4d f8	 mov	 ecx, DWORD PTR _ptr$[ebp]
  0022f	83 c1 01	 add	 ecx, 1
  00232	89 4d f8	 mov	 DWORD PTR _ptr$[ebp], ecx
  00235	83 7d 10 00	 cmp	 DWORD PTR _fmt$[ebp], 0
  00239	74 0f		 je	 SHORT $LN22@print_arra
  0023b	8b 55 f8	 mov	 edx, DWORD PTR _ptr$[ebp]
  0023e	c6 02 20	 mov	 BYTE PTR [edx], 32	; 00000020H
  00241	8b 45 f8	 mov	 eax, DWORD PTR _ptr$[ebp]
  00244	83 c0 01	 add	 eax, 1
  00247	89 45 f8	 mov	 DWORD PTR _ptr$[ebp], eax
$LN22@print_arra:
  0024a	8b 4d f8	 mov	 ecx, DWORD PTR _ptr$[ebp]
  0024d	c6 01 00	 mov	 BYTE PTR [ecx], 0
$LN21@print_arra:

; 396  : 		cJSON_free(entries[i]);

  00250	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00253	8b 45 f4	 mov	 eax, DWORD PTR _entries$[ebp]
  00256	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00259	51		 push	 ecx
  0025a	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_free
  00260	83 c4 04	 add	 esp, 4

; 397  : 	}

  00263	e9 74 ff ff ff	 jmp	 $LN9@print_arra
$LN10@print_arra:

; 398  : 	cJSON_free(entries);

  00268	8b 55 f4	 mov	 edx, DWORD PTR _entries$[ebp]
  0026b	52		 push	 edx
  0026c	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_free
  00272	83 c4 04	 add	 esp, 4

; 399  : 	*ptr++ = ']'; *ptr++ = 0;

  00275	8b 45 f8	 mov	 eax, DWORD PTR _ptr$[ebp]
  00278	c6 00 5d	 mov	 BYTE PTR [eax], 93	; 0000005dH
  0027b	8b 4d f8	 mov	 ecx, DWORD PTR _ptr$[ebp]
  0027e	83 c1 01	 add	 ecx, 1
  00281	89 4d f8	 mov	 DWORD PTR _ptr$[ebp], ecx
  00284	8b 55 f8	 mov	 edx, DWORD PTR _ptr$[ebp]
  00287	c6 02 00	 mov	 BYTE PTR [edx], 0
  0028a	8b 45 f8	 mov	 eax, DWORD PTR _ptr$[ebp]
  0028d	83 c0 01	 add	 eax, 1
  00290	89 45 f8	 mov	 DWORD PTR _ptr$[ebp], eax

; 400  : 	return out;

  00293	8b 45 f0	 mov	 eax, DWORD PTR _out$[ebp]
$LN1@print_arra:

; 401  : }

  00296	8b e5		 mov	 esp, ebp
  00298	5d		 pop	 ebp
  00299	c3		 ret	 0
_print_array ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _parse_array
_TEXT	SEGMENT
_new_item$1 = -8					; size = 4
_child$ = -4						; size = 4
_item$ = 8						; size = 4
_value$ = 12						; size = 4
_parse_array PROC					; COMDAT

; 319  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 320  : 	cJSON *child;
; 321  : 	if (*value != '[') { ep = value; return 0; }	/* not an array! */

  00006	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  00009	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0000c	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  0000f	74 10		 je	 SHORT $LN4@parse_arra
  00011	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp]
  00014	89 15 00 00 00
	00		 mov	 DWORD PTR _ep, edx
  0001a	33 c0		 xor	 eax, eax
  0001c	e9 0b 01 00 00	 jmp	 $LN1@parse_arra
$LN4@parse_arra:

; 322  : 
; 323  : 	item->type = cJSON_Array;

  00021	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00024	c7 40 0c 05 00
	00 00		 mov	 DWORD PTR [eax+12], 5

; 324  : 	value = skip(value + 1);

  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  0002e	83 c1 01	 add	 ecx, 1
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _skip
  00037	83 c4 04	 add	 esp, 4
  0003a	89 45 0c	 mov	 DWORD PTR _value$[ebp], eax

; 325  : 	if (*value == ']') return value + 1;	/* empty array. */

  0003d	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp]
  00040	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00043	83 f8 5d	 cmp	 eax, 93			; 0000005dH
  00046	75 0b		 jne	 SHORT $LN5@parse_arra
  00048	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  0004b	83 c0 01	 add	 eax, 1
  0004e	e9 d9 00 00 00	 jmp	 $LN1@parse_arra
$LN5@parse_arra:

; 326  : 
; 327  : 	item->child = child = cJSON_New_Item();

  00053	e8 00 00 00 00	 call	 _cJSON_New_Item
  00058	89 45 fc	 mov	 DWORD PTR _child$[ebp], eax
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  0005e	8b 55 fc	 mov	 edx, DWORD PTR _child$[ebp]
  00061	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 328  : 	if (!item->child) return 0;		 /* memory fail */

  00064	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00067	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0006b	75 07		 jne	 SHORT $LN6@parse_arra
  0006d	33 c0		 xor	 eax, eax
  0006f	e9 b8 00 00 00	 jmp	 $LN1@parse_arra
$LN6@parse_arra:

; 329  : 	value = skip(parse_value(child, skip(value)));	/* skip any spacing, get the value. */

  00074	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 _skip
  0007d	83 c4 04	 add	 esp, 4
  00080	50		 push	 eax
  00081	8b 55 fc	 mov	 edx, DWORD PTR _child$[ebp]
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 _parse_value
  0008a	83 c4 08	 add	 esp, 8
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _skip
  00093	83 c4 04	 add	 esp, 4
  00096	89 45 0c	 mov	 DWORD PTR _value$[ebp], eax

; 330  : 	if (!value) return 0;

  00099	83 7d 0c 00	 cmp	 DWORD PTR _value$[ebp], 0
  0009d	75 07		 jne	 SHORT $LN2@parse_arra
  0009f	33 c0		 xor	 eax, eax
  000a1	e9 86 00 00 00	 jmp	 $LN1@parse_arra
$LN2@parse_arra:

; 331  : 
; 332  : 	while (*value == ',')

  000a6	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  000a9	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000ac	83 f9 2c	 cmp	 ecx, 44			; 0000002cH
  000af	75 5d		 jne	 SHORT $LN3@parse_arra

; 333  : 	{
; 334  : 		cJSON *new_item;
; 335  : 		if (!(new_item = cJSON_New_Item())) return 0; 	/* memory fail */

  000b1	e8 00 00 00 00	 call	 _cJSON_New_Item
  000b6	89 45 f8	 mov	 DWORD PTR _new_item$1[ebp], eax
  000b9	83 7d f8 00	 cmp	 DWORD PTR _new_item$1[ebp], 0
  000bd	75 04		 jne	 SHORT $LN8@parse_arra
  000bf	33 c0		 xor	 eax, eax
  000c1	eb 69		 jmp	 SHORT $LN1@parse_arra
$LN8@parse_arra:

; 336  : 		child->next = new_item; new_item->prev = child; child = new_item;

  000c3	8b 55 fc	 mov	 edx, DWORD PTR _child$[ebp]
  000c6	8b 45 f8	 mov	 eax, DWORD PTR _new_item$1[ebp]
  000c9	89 02		 mov	 DWORD PTR [edx], eax
  000cb	8b 4d f8	 mov	 ecx, DWORD PTR _new_item$1[ebp]
  000ce	8b 55 fc	 mov	 edx, DWORD PTR _child$[ebp]
  000d1	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  000d4	8b 45 f8	 mov	 eax, DWORD PTR _new_item$1[ebp]
  000d7	89 45 fc	 mov	 DWORD PTR _child$[ebp], eax

; 337  : 		value = skip(parse_value(child, skip(value + 1)));

  000da	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  000dd	83 c1 01	 add	 ecx, 1
  000e0	51		 push	 ecx
  000e1	e8 00 00 00 00	 call	 _skip
  000e6	83 c4 04	 add	 esp, 4
  000e9	50		 push	 eax
  000ea	8b 55 fc	 mov	 edx, DWORD PTR _child$[ebp]
  000ed	52		 push	 edx
  000ee	e8 00 00 00 00	 call	 _parse_value
  000f3	83 c4 08	 add	 esp, 8
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 _skip
  000fc	83 c4 04	 add	 esp, 4
  000ff	89 45 0c	 mov	 DWORD PTR _value$[ebp], eax

; 338  : 		if (!value) return 0;	/* memory fail */

  00102	83 7d 0c 00	 cmp	 DWORD PTR _value$[ebp], 0
  00106	75 04		 jne	 SHORT $LN9@parse_arra
  00108	33 c0		 xor	 eax, eax
  0010a	eb 20		 jmp	 SHORT $LN1@parse_arra
$LN9@parse_arra:

; 339  : 	}

  0010c	eb 98		 jmp	 SHORT $LN2@parse_arra
$LN3@parse_arra:

; 340  : 
; 341  : 	if (*value == ']') return value + 1;	/* end of array */

  0010e	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  00111	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00114	83 f9 5d	 cmp	 ecx, 93			; 0000005dH
  00117	75 08		 jne	 SHORT $LN10@parse_arra
  00119	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  0011c	83 c0 01	 add	 eax, 1
  0011f	eb 0b		 jmp	 SHORT $LN1@parse_arra
$LN10@parse_arra:

; 342  : 	ep = value; return 0;	/* malformed. */

  00121	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp]
  00124	89 15 00 00 00
	00		 mov	 DWORD PTR _ep, edx
  0012a	33 c0		 xor	 eax, eax
$LN1@parse_arra:

; 343  : }

  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c3		 ret	 0
_parse_array ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _print_value
_TEXT	SEGMENT
tv67 = -8						; size = 4
_out$ = -4						; size = 4
_item$ = 8						; size = 4
_depth$ = 12						; size = 4
_fmt$ = 16						; size = 4
_print_value PROC					; COMDAT

; 301  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 302  : 	char *out = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _out$[ebp], 0

; 303  : 	if (!item) return 0;

  0000d	83 7d 08 00	 cmp	 DWORD PTR _item$[ebp], 0
  00011	75 07		 jne	 SHORT $LN4@print_valu
  00013	33 c0		 xor	 eax, eax
  00015	e9 ae 00 00 00	 jmp	 $LN1@print_valu
$LN4@print_valu:

; 304  : 	switch ((item->type) & 255)

  0001a	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  0001d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00020	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00026	89 4d f8	 mov	 DWORD PTR tv67[ebp], ecx
  00029	83 7d f8 06	 cmp	 DWORD PTR tv67[ebp], 6
  0002d	0f 87 92 00 00
	00		 ja	 $LN2@print_valu
  00033	8b 55 f8	 mov	 edx, DWORD PTR tv67[ebp]
  00036	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN13@print_valu[edx*4]
$LN5@print_valu:

; 305  : 	{
; 306  : 	case cJSON_NULL:	out = cJSON_strdup("null");	break;

  0003d	68 00 00 00 00	 push	 OFFSET $SG5297
  00042	e8 00 00 00 00	 call	 _cJSON_strdup
  00047	83 c4 04	 add	 esp, 4
  0004a	89 45 fc	 mov	 DWORD PTR _out$[ebp], eax
  0004d	eb 76		 jmp	 SHORT $LN2@print_valu
$LN6@print_valu:

; 307  : 	case cJSON_False:	out = cJSON_strdup("false"); break;

  0004f	68 00 00 00 00	 push	 OFFSET $SG5299
  00054	e8 00 00 00 00	 call	 _cJSON_strdup
  00059	83 c4 04	 add	 esp, 4
  0005c	89 45 fc	 mov	 DWORD PTR _out$[ebp], eax
  0005f	eb 64		 jmp	 SHORT $LN2@print_valu
$LN7@print_valu:

; 308  : 	case cJSON_True:	out = cJSON_strdup("true"); break;

  00061	68 00 00 00 00	 push	 OFFSET $SG5301
  00066	e8 00 00 00 00	 call	 _cJSON_strdup
  0006b	83 c4 04	 add	 esp, 4
  0006e	89 45 fc	 mov	 DWORD PTR _out$[ebp], eax
  00071	eb 52		 jmp	 SHORT $LN2@print_valu
$LN8@print_valu:

; 309  : 	case cJSON_Number:	out = print_number(item); break;

  00073	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _print_number
  0007c	83 c4 04	 add	 esp, 4
  0007f	89 45 fc	 mov	 DWORD PTR _out$[ebp], eax
  00082	eb 41		 jmp	 SHORT $LN2@print_valu
$LN9@print_valu:

; 310  : 	case cJSON_String:	out = print_string(item); break;

  00084	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 _print_string
  0008d	83 c4 04	 add	 esp, 4
  00090	89 45 fc	 mov	 DWORD PTR _out$[ebp], eax
  00093	eb 30		 jmp	 SHORT $LN2@print_valu
$LN10@print_valu:

; 311  : 	case cJSON_Array:	out = print_array(item, depth, fmt); break;

  00095	8b 55 10	 mov	 edx, DWORD PTR _fmt$[ebp]
  00098	52		 push	 edx
  00099	8b 45 0c	 mov	 eax, DWORD PTR _depth$[ebp]
  0009c	50		 push	 eax
  0009d	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  000a0	51		 push	 ecx
  000a1	e8 00 00 00 00	 call	 _print_array
  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a9	89 45 fc	 mov	 DWORD PTR _out$[ebp], eax
  000ac	eb 17		 jmp	 SHORT $LN2@print_valu
$LN11@print_valu:

; 312  : 	case cJSON_Object:	out = print_object(item, depth, fmt); break;

  000ae	8b 55 10	 mov	 edx, DWORD PTR _fmt$[ebp]
  000b1	52		 push	 edx
  000b2	8b 45 0c	 mov	 eax, DWORD PTR _depth$[ebp]
  000b5	50		 push	 eax
  000b6	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  000b9	51		 push	 ecx
  000ba	e8 00 00 00 00	 call	 _print_object
  000bf	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c2	89 45 fc	 mov	 DWORD PTR _out$[ebp], eax
$LN2@print_valu:

; 313  : 	}
; 314  : 	return out;

  000c5	8b 45 fc	 mov	 eax, DWORD PTR _out$[ebp]
$LN1@print_valu:

; 315  : }

  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
$LN13@print_valu:
  000cc	00 00 00 00	 DD	 $LN6@print_valu
  000d0	00 00 00 00	 DD	 $LN7@print_valu
  000d4	00 00 00 00	 DD	 $LN5@print_valu
  000d8	00 00 00 00	 DD	 $LN8@print_valu
  000dc	00 00 00 00	 DD	 $LN9@print_valu
  000e0	00 00 00 00	 DD	 $LN10@print_valu
  000e4	00 00 00 00	 DD	 $LN11@print_valu
_print_value ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _parse_value
_TEXT	SEGMENT
_item$ = 8						; size = 4
_value$ = 12						; size = 4
_parse_value PROC					; COMDAT

; 286  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 287  : 	if (!value)						return 0;	/* Fail on null. */

  00003	83 7d 0c 00	 cmp	 DWORD PTR _value$[ebp], 0
  00007	75 07		 jne	 SHORT $LN2@parse_valu
  00009	33 c0		 xor	 eax, eax
  0000b	e9 22 01 00 00	 jmp	 $LN1@parse_valu
$LN2@parse_valu:

; 288  : 	if (!strncmp(value, "null", 4)) { item->type = cJSON_NULL;  return value + 4; }

  00010	6a 04		 push	 4
  00012	68 00 00 00 00	 push	 OFFSET $SG5275
  00017	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 _strncmp
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	85 c0		 test	 eax, eax
  00025	75 15		 jne	 SHORT $LN3@parse_valu
  00027	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  0002a	c7 41 0c 02 00
	00 00		 mov	 DWORD PTR [ecx+12], 2
  00031	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  00034	83 c0 04	 add	 eax, 4
  00037	e9 f6 00 00 00	 jmp	 $LN1@parse_valu
$LN3@parse_valu:

; 289  : 	if (!strncmp(value, "false", 5)) { item->type = cJSON_False; return value + 5; }

  0003c	6a 05		 push	 5
  0003e	68 00 00 00 00	 push	 OFFSET $SG5277
  00043	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp]
  00046	52		 push	 edx
  00047	e8 00 00 00 00	 call	 _strncmp
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004f	85 c0		 test	 eax, eax
  00051	75 15		 jne	 SHORT $LN4@parse_valu
  00053	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00056	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
  0005d	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  00060	83 c0 05	 add	 eax, 5
  00063	e9 ca 00 00 00	 jmp	 $LN1@parse_valu
$LN4@parse_valu:

; 290  : 	if (!strncmp(value, "true", 4)) { item->type = cJSON_True; item->valueint = 1;	return value + 4; }

  00068	6a 04		 push	 4
  0006a	68 00 00 00 00	 push	 OFFSET $SG5279
  0006f	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 _strncmp
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007b	85 c0		 test	 eax, eax
  0007d	75 1f		 jne	 SHORT $LN5@parse_valu
  0007f	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00082	c7 42 0c 01 00
	00 00		 mov	 DWORD PTR [edx+12], 1
  00089	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  0008c	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [eax+20], 1
  00093	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  00096	83 c0 04	 add	 eax, 4
  00099	e9 94 00 00 00	 jmp	 $LN1@parse_valu
$LN5@parse_valu:

; 291  : 	if (*value == '\"') { return parse_string(item, value); }

  0009e	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  000a1	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000a4	83 fa 22	 cmp	 edx, 34			; 00000022H
  000a7	75 12		 jne	 SHORT $LN6@parse_valu
  000a9	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  000b0	51		 push	 ecx
  000b1	e8 00 00 00 00	 call	 _parse_string
  000b6	83 c4 08	 add	 esp, 8
  000b9	eb 77		 jmp	 SHORT $LN1@parse_valu
$LN6@parse_valu:

; 292  : 	if (*value == '-' || (*value >= '0' && *value <= '9')) { return parse_number(item, value); }

  000bb	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp]
  000be	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000c1	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  000c4	74 16		 je	 SHORT $LN8@parse_valu
  000c6	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  000c9	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000cc	83 fa 30	 cmp	 edx, 48			; 00000030H
  000cf	7c 1d		 jl	 SHORT $LN7@parse_valu
  000d1	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  000d4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000d7	83 f9 39	 cmp	 ecx, 57			; 00000039H
  000da	7f 12		 jg	 SHORT $LN7@parse_valu
$LN8@parse_valu:
  000dc	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp]
  000df	52		 push	 edx
  000e0	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 _parse_number
  000e9	83 c4 08	 add	 esp, 8
  000ec	eb 44		 jmp	 SHORT $LN1@parse_valu
$LN7@parse_valu:

; 293  : 	if (*value == '[') { return parse_array(item, value); }

  000ee	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  000f1	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000f4	83 fa 5b	 cmp	 edx, 91			; 0000005bH
  000f7	75 12		 jne	 SHORT $LN9@parse_valu
  000f9	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  000fc	50		 push	 eax
  000fd	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00100	51		 push	 ecx
  00101	e8 00 00 00 00	 call	 _parse_array
  00106	83 c4 08	 add	 esp, 8
  00109	eb 27		 jmp	 SHORT $LN1@parse_valu
$LN9@parse_valu:

; 294  : 	if (*value == '{') { return parse_object(item, value); }

  0010b	8b 55 0c	 mov	 edx, DWORD PTR _value$[ebp]
  0010e	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00111	83 f8 7b	 cmp	 eax, 123		; 0000007bH
  00114	75 12		 jne	 SHORT $LN10@parse_valu
  00116	8b 4d 0c	 mov	 ecx, DWORD PTR _value$[ebp]
  00119	51		 push	 ecx
  0011a	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  0011d	52		 push	 edx
  0011e	e8 00 00 00 00	 call	 _parse_object
  00123	83 c4 08	 add	 esp, 8
  00126	eb 0a		 jmp	 SHORT $LN1@parse_valu
$LN10@parse_valu:

; 295  : 
; 296  : 	ep = value; return 0;	/* failure. */

  00128	8b 45 0c	 mov	 eax, DWORD PTR _value$[ebp]
  0012b	a3 00 00 00 00	 mov	 DWORD PTR _ep, eax
  00130	33 c0		 xor	 eax, eax
$LN1@parse_valu:

; 297  : }

  00132	5d		 pop	 ebp
  00133	c3		 ret	 0
_parse_value ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _print_string
_TEXT	SEGMENT
_item$ = 8						; size = 4
_print_string PROC					; COMDAT

; 248  : static char *print_string(cJSON *item) { return print_string_ptr(item->valuestring); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00006	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00009	51		 push	 ecx
  0000a	e8 00 00 00 00	 call	 _print_string_ptr
  0000f	83 c4 04	 add	 esp, 4
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
_print_string ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _print_string_ptr
_TEXT	SEGMENT
tv131 = -28						; size = 4
_out$ = -24						; size = 4
tv132 = -20						; size = 4
_len$ = -16						; size = 4
_ptr$ = -12						; size = 4
_ptr2$ = -8						; size = 4
_token$ = -1						; size = 1
_str$ = 8						; size = 4
_print_string_ptr PROC					; COMDAT

; 214  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 215  : 	const char *ptr; char *ptr2, *out; int len = 0; unsigned char token;

  00006	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 216  : 
; 217  : 	if (!str) return cJSON_strdup("");

  0000d	83 7d 08 00	 cmp	 DWORD PTR _str$[ebp], 0
  00011	75 12		 jne	 SHORT $LN8@print_stri
  00013	68 00 00 00 00	 push	 OFFSET $SG5181
  00018	e8 00 00 00 00	 call	 _cJSON_strdup
  0001d	83 c4 04	 add	 esp, 4
  00020	e9 fa 01 00 00	 jmp	 $LN1@print_stri
$LN8@print_stri:

; 218  : 	ptr = str; while ((token = *ptr) && ++len) { if (strchr("\"\\\b\f\n\r\t", token)) len++; else if (token<32) len += 5; ptr++; }

  00025	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00028	89 45 f4	 mov	 DWORD PTR _ptr$[ebp], eax
$LN2@print_stri:
  0002b	8b 4d f4	 mov	 ecx, DWORD PTR _ptr$[ebp]
  0002e	8a 11		 mov	 dl, BYTE PTR [ecx]
  00030	88 55 ff	 mov	 BYTE PTR _token$[ebp], dl
  00033	0f b6 45 ff	 movzx	 eax, BYTE PTR _token$[ebp]
  00037	85 c0		 test	 eax, eax
  00039	74 49		 je	 SHORT $LN3@print_stri
  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _len$[ebp]
  0003e	83 c1 01	 add	 ecx, 1
  00041	89 4d f0	 mov	 DWORD PTR _len$[ebp], ecx
  00044	74 3e		 je	 SHORT $LN3@print_stri
  00046	0f b6 55 ff	 movzx	 edx, BYTE PTR _token$[ebp]
  0004a	52		 push	 edx
  0004b	68 00 00 00 00	 push	 OFFSET $SG5184
  00050	e8 00 00 00 00	 call	 _strchr
  00055	83 c4 08	 add	 esp, 8
  00058	85 c0		 test	 eax, eax
  0005a	74 0b		 je	 SHORT $LN9@print_stri
  0005c	8b 45 f0	 mov	 eax, DWORD PTR _len$[ebp]
  0005f	83 c0 01	 add	 eax, 1
  00062	89 45 f0	 mov	 DWORD PTR _len$[ebp], eax
  00065	eb 12		 jmp	 SHORT $LN10@print_stri
$LN9@print_stri:
  00067	0f b6 4d ff	 movzx	 ecx, BYTE PTR _token$[ebp]
  0006b	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0006e	7d 09		 jge	 SHORT $LN10@print_stri
  00070	8b 55 f0	 mov	 edx, DWORD PTR _len$[ebp]
  00073	83 c2 05	 add	 edx, 5
  00076	89 55 f0	 mov	 DWORD PTR _len$[ebp], edx
$LN10@print_stri:
  00079	8b 45 f4	 mov	 eax, DWORD PTR _ptr$[ebp]
  0007c	83 c0 01	 add	 eax, 1
  0007f	89 45 f4	 mov	 DWORD PTR _ptr$[ebp], eax
  00082	eb a7		 jmp	 SHORT $LN2@print_stri
$LN3@print_stri:

; 219  : 
; 220  : 	out = (char*)cJSON_malloc(len + 3);

  00084	8b 4d f0	 mov	 ecx, DWORD PTR _len$[ebp]
  00087	83 c1 03	 add	 ecx, 3
  0008a	51		 push	 ecx
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_malloc
  00091	83 c4 04	 add	 esp, 4
  00094	89 45 e8	 mov	 DWORD PTR _out$[ebp], eax

; 221  : 	if (!out) return 0;

  00097	83 7d e8 00	 cmp	 DWORD PTR _out$[ebp], 0
  0009b	75 07		 jne	 SHORT $LN12@print_stri
  0009d	33 c0		 xor	 eax, eax
  0009f	e9 7b 01 00 00	 jmp	 $LN1@print_stri
$LN12@print_stri:

; 222  : 
; 223  : 	ptr2 = out; ptr = str;

  000a4	8b 55 e8	 mov	 edx, DWORD PTR _out$[ebp]
  000a7	89 55 f8	 mov	 DWORD PTR _ptr2$[ebp], edx
  000aa	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  000ad	89 45 f4	 mov	 DWORD PTR _ptr$[ebp], eax

; 224  : 	*ptr2++ = '\"';

  000b0	8b 4d f8	 mov	 ecx, DWORD PTR _ptr2$[ebp]
  000b3	c6 01 22	 mov	 BYTE PTR [ecx], 34	; 00000022H
  000b6	8b 55 f8	 mov	 edx, DWORD PTR _ptr2$[ebp]
  000b9	83 c2 01	 add	 edx, 1
  000bc	89 55 f8	 mov	 DWORD PTR _ptr2$[ebp], edx
$LN4@print_stri:

; 225  : 	while (*ptr)

  000bf	8b 45 f4	 mov	 eax, DWORD PTR _ptr$[ebp]
  000c2	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000c5	85 c9		 test	 ecx, ecx
  000c7	0f 84 31 01 00
	00		 je	 $LN5@print_stri

; 226  : 	{
; 227  : 		if ((unsigned char)*ptr>31 && *ptr != '\"' && *ptr != '\\') *ptr2++ = *ptr++;

  000cd	8b 55 f4	 mov	 edx, DWORD PTR _ptr$[ebp]
  000d0	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000d3	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000d6	7e 37		 jle	 SHORT $LN13@print_stri
  000d8	8b 4d f4	 mov	 ecx, DWORD PTR _ptr$[ebp]
  000db	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000de	83 fa 22	 cmp	 edx, 34			; 00000022H
  000e1	74 2c		 je	 SHORT $LN13@print_stri
  000e3	8b 45 f4	 mov	 eax, DWORD PTR _ptr$[ebp]
  000e6	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000e9	83 f9 5c	 cmp	 ecx, 92			; 0000005cH
  000ec	74 21		 je	 SHORT $LN13@print_stri
  000ee	8b 55 f8	 mov	 edx, DWORD PTR _ptr2$[ebp]
  000f1	8b 45 f4	 mov	 eax, DWORD PTR _ptr$[ebp]
  000f4	8a 08		 mov	 cl, BYTE PTR [eax]
  000f6	88 0a		 mov	 BYTE PTR [edx], cl
  000f8	8b 55 f8	 mov	 edx, DWORD PTR _ptr2$[ebp]
  000fb	83 c2 01	 add	 edx, 1
  000fe	89 55 f8	 mov	 DWORD PTR _ptr2$[ebp], edx
  00101	8b 45 f4	 mov	 eax, DWORD PTR _ptr$[ebp]
  00104	83 c0 01	 add	 eax, 1
  00107	89 45 f4	 mov	 DWORD PTR _ptr$[ebp], eax
  0010a	e9 ea 00 00 00	 jmp	 $LN14@print_stri
$LN13@print_stri:

; 228  : 		else
; 229  : 		{
; 230  : 			*ptr2++ = '\\';

  0010f	8b 4d f8	 mov	 ecx, DWORD PTR _ptr2$[ebp]
  00112	c6 01 5c	 mov	 BYTE PTR [ecx], 92	; 0000005cH
  00115	8b 55 f8	 mov	 edx, DWORD PTR _ptr2$[ebp]
  00118	83 c2 01	 add	 edx, 1
  0011b	89 55 f8	 mov	 DWORD PTR _ptr2$[ebp], edx

; 231  : 			switch (token = *ptr++)

  0011e	8b 45 f4	 mov	 eax, DWORD PTR _ptr$[ebp]
  00121	8a 08		 mov	 cl, BYTE PTR [eax]
  00123	88 4d ff	 mov	 BYTE PTR _token$[ebp], cl
  00126	0f b6 55 ff	 movzx	 edx, BYTE PTR _token$[ebp]
  0012a	89 55 e4	 mov	 DWORD PTR tv131[ebp], edx
  0012d	8b 45 f4	 mov	 eax, DWORD PTR _ptr$[ebp]
  00130	83 c0 01	 add	 eax, 1
  00133	89 45 f4	 mov	 DWORD PTR _ptr$[ebp], eax
  00136	8b 4d e4	 mov	 ecx, DWORD PTR tv131[ebp]
  00139	89 4d ec	 mov	 DWORD PTR tv132[ebp], ecx
  0013c	8b 55 ec	 mov	 edx, DWORD PTR tv132[ebp]
  0013f	83 ea 08	 sub	 edx, 8
  00142	89 55 ec	 mov	 DWORD PTR tv132[ebp], edx
  00145	83 7d ec 54	 cmp	 DWORD PTR tv132[ebp], 84 ; 00000054H
  00149	0f 87 8b 00 00
	00		 ja	 $LN22@print_stri
  0014f	8b 45 ec	 mov	 eax, DWORD PTR tv132[ebp]
  00152	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN24@print_stri[eax]
  00159	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN25@print_stri[ecx*4]
$LN15@print_stri:

; 232  : 			{
; 233  : 			case '\\':	*ptr2++ = '\\';	break;

  00160	8b 55 f8	 mov	 edx, DWORD PTR _ptr2$[ebp]
  00163	c6 02 5c	 mov	 BYTE PTR [edx], 92	; 0000005cH
  00166	8b 45 f8	 mov	 eax, DWORD PTR _ptr2$[ebp]
  00169	83 c0 01	 add	 eax, 1
  0016c	89 45 f8	 mov	 DWORD PTR _ptr2$[ebp], eax
  0016f	e9 85 00 00 00	 jmp	 $LN14@print_stri
$LN16@print_stri:

; 234  : 			case '\"':	*ptr2++ = '\"';	break;

  00174	8b 4d f8	 mov	 ecx, DWORD PTR _ptr2$[ebp]
  00177	c6 01 22	 mov	 BYTE PTR [ecx], 34	; 00000022H
  0017a	8b 55 f8	 mov	 edx, DWORD PTR _ptr2$[ebp]
  0017d	83 c2 01	 add	 edx, 1
  00180	89 55 f8	 mov	 DWORD PTR _ptr2$[ebp], edx
  00183	eb 74		 jmp	 SHORT $LN14@print_stri
$LN17@print_stri:

; 235  : 			case '\b':	*ptr2++ = 'b';	break;

  00185	8b 45 f8	 mov	 eax, DWORD PTR _ptr2$[ebp]
  00188	c6 00 62	 mov	 BYTE PTR [eax], 98	; 00000062H
  0018b	8b 4d f8	 mov	 ecx, DWORD PTR _ptr2$[ebp]
  0018e	83 c1 01	 add	 ecx, 1
  00191	89 4d f8	 mov	 DWORD PTR _ptr2$[ebp], ecx
  00194	eb 63		 jmp	 SHORT $LN14@print_stri
$LN18@print_stri:

; 236  : 			case '\f':	*ptr2++ = 'f';	break;

  00196	8b 55 f8	 mov	 edx, DWORD PTR _ptr2$[ebp]
  00199	c6 02 66	 mov	 BYTE PTR [edx], 102	; 00000066H
  0019c	8b 45 f8	 mov	 eax, DWORD PTR _ptr2$[ebp]
  0019f	83 c0 01	 add	 eax, 1
  001a2	89 45 f8	 mov	 DWORD PTR _ptr2$[ebp], eax
  001a5	eb 52		 jmp	 SHORT $LN14@print_stri
$LN19@print_stri:

; 237  : 			case '\n':	*ptr2++ = 'n';	break;

  001a7	8b 4d f8	 mov	 ecx, DWORD PTR _ptr2$[ebp]
  001aa	c6 01 6e	 mov	 BYTE PTR [ecx], 110	; 0000006eH
  001ad	8b 55 f8	 mov	 edx, DWORD PTR _ptr2$[ebp]
  001b0	83 c2 01	 add	 edx, 1
  001b3	89 55 f8	 mov	 DWORD PTR _ptr2$[ebp], edx
  001b6	eb 41		 jmp	 SHORT $LN14@print_stri
$LN20@print_stri:

; 238  : 			case '\r':	*ptr2++ = 'r';	break;

  001b8	8b 45 f8	 mov	 eax, DWORD PTR _ptr2$[ebp]
  001bb	c6 00 72	 mov	 BYTE PTR [eax], 114	; 00000072H
  001be	8b 4d f8	 mov	 ecx, DWORD PTR _ptr2$[ebp]
  001c1	83 c1 01	 add	 ecx, 1
  001c4	89 4d f8	 mov	 DWORD PTR _ptr2$[ebp], ecx
  001c7	eb 30		 jmp	 SHORT $LN14@print_stri
$LN21@print_stri:

; 239  : 			case '\t':	*ptr2++ = 't';	break;

  001c9	8b 55 f8	 mov	 edx, DWORD PTR _ptr2$[ebp]
  001cc	c6 02 74	 mov	 BYTE PTR [edx], 116	; 00000074H
  001cf	8b 45 f8	 mov	 eax, DWORD PTR _ptr2$[ebp]
  001d2	83 c0 01	 add	 eax, 1
  001d5	89 45 f8	 mov	 DWORD PTR _ptr2$[ebp], eax
  001d8	eb 1f		 jmp	 SHORT $LN14@print_stri
$LN22@print_stri:

; 240  : 			default: sprintf(ptr2, "u%04x", token); ptr2 += 5;	break;	/* escape and print */

  001da	0f b6 4d ff	 movzx	 ecx, BYTE PTR _token$[ebp]
  001de	51		 push	 ecx
  001df	68 00 00 00 00	 push	 OFFSET $SG5197
  001e4	8b 55 f8	 mov	 edx, DWORD PTR _ptr2$[ebp]
  001e7	52		 push	 edx
  001e8	e8 00 00 00 00	 call	 __hx_sprintf
  001ed	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f0	8b 45 f8	 mov	 eax, DWORD PTR _ptr2$[ebp]
  001f3	83 c0 05	 add	 eax, 5
  001f6	89 45 f8	 mov	 DWORD PTR _ptr2$[ebp], eax
$LN14@print_stri:

; 241  : 			}
; 242  : 		}
; 243  : 	}

  001f9	e9 c1 fe ff ff	 jmp	 $LN4@print_stri
$LN5@print_stri:

; 244  : 	*ptr2++ = '\"'; *ptr2++ = 0;

  001fe	8b 4d f8	 mov	 ecx, DWORD PTR _ptr2$[ebp]
  00201	c6 01 22	 mov	 BYTE PTR [ecx], 34	; 00000022H
  00204	8b 55 f8	 mov	 edx, DWORD PTR _ptr2$[ebp]
  00207	83 c2 01	 add	 edx, 1
  0020a	89 55 f8	 mov	 DWORD PTR _ptr2$[ebp], edx
  0020d	8b 45 f8	 mov	 eax, DWORD PTR _ptr2$[ebp]
  00210	c6 00 00	 mov	 BYTE PTR [eax], 0
  00213	8b 4d f8	 mov	 ecx, DWORD PTR _ptr2$[ebp]
  00216	83 c1 01	 add	 ecx, 1
  00219	89 4d f8	 mov	 DWORD PTR _ptr2$[ebp], ecx

; 245  : 	return out;

  0021c	8b 45 e8	 mov	 eax, DWORD PTR _out$[ebp]
$LN1@print_stri:

; 246  : }

  0021f	8b e5		 mov	 esp, ebp
  00221	5d		 pop	 ebp
  00222	c3		 ret	 0
  00223	90		 npad	 1
$LN25@print_stri:
  00224	00 00 00 00	 DD	 $LN17@print_stri
  00228	00 00 00 00	 DD	 $LN21@print_stri
  0022c	00 00 00 00	 DD	 $LN19@print_stri
  00230	00 00 00 00	 DD	 $LN18@print_stri
  00234	00 00 00 00	 DD	 $LN20@print_stri
  00238	00 00 00 00	 DD	 $LN16@print_stri
  0023c	00 00 00 00	 DD	 $LN15@print_stri
  00240	00 00 00 00	 DD	 $LN22@print_stri
$LN24@print_stri:
  00244	00		 DB	 0
  00245	01		 DB	 1
  00246	02		 DB	 2
  00247	07		 DB	 7
  00248	03		 DB	 3
  00249	04		 DB	 4
  0024a	07		 DB	 7
  0024b	07		 DB	 7
  0024c	07		 DB	 7
  0024d	07		 DB	 7
  0024e	07		 DB	 7
  0024f	07		 DB	 7
  00250	07		 DB	 7
  00251	07		 DB	 7
  00252	07		 DB	 7
  00253	07		 DB	 7
  00254	07		 DB	 7
  00255	07		 DB	 7
  00256	07		 DB	 7
  00257	07		 DB	 7
  00258	07		 DB	 7
  00259	07		 DB	 7
  0025a	07		 DB	 7
  0025b	07		 DB	 7
  0025c	07		 DB	 7
  0025d	07		 DB	 7
  0025e	05		 DB	 5
  0025f	07		 DB	 7
  00260	07		 DB	 7
  00261	07		 DB	 7
  00262	07		 DB	 7
  00263	07		 DB	 7
  00264	07		 DB	 7
  00265	07		 DB	 7
  00266	07		 DB	 7
  00267	07		 DB	 7
  00268	07		 DB	 7
  00269	07		 DB	 7
  0026a	07		 DB	 7
  0026b	07		 DB	 7
  0026c	07		 DB	 7
  0026d	07		 DB	 7
  0026e	07		 DB	 7
  0026f	07		 DB	 7
  00270	07		 DB	 7
  00271	07		 DB	 7
  00272	07		 DB	 7
  00273	07		 DB	 7
  00274	07		 DB	 7
  00275	07		 DB	 7
  00276	07		 DB	 7
  00277	07		 DB	 7
  00278	07		 DB	 7
  00279	07		 DB	 7
  0027a	07		 DB	 7
  0027b	07		 DB	 7
  0027c	07		 DB	 7
  0027d	07		 DB	 7
  0027e	07		 DB	 7
  0027f	07		 DB	 7
  00280	07		 DB	 7
  00281	07		 DB	 7
  00282	07		 DB	 7
  00283	07		 DB	 7
  00284	07		 DB	 7
  00285	07		 DB	 7
  00286	07		 DB	 7
  00287	07		 DB	 7
  00288	07		 DB	 7
  00289	07		 DB	 7
  0028a	07		 DB	 7
  0028b	07		 DB	 7
  0028c	07		 DB	 7
  0028d	07		 DB	 7
  0028e	07		 DB	 7
  0028f	07		 DB	 7
  00290	07		 DB	 7
  00291	07		 DB	 7
  00292	07		 DB	 7
  00293	07		 DB	 7
  00294	07		 DB	 7
  00295	07		 DB	 7
  00296	07		 DB	 7
  00297	07		 DB	 7
  00298	06		 DB	 6
_print_string_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _parse_string
_TEXT	SEGMENT
tv76 = -36						; size = 4
_out$ = -32						; size = 4
_uc2$ = -28						; size = 4
tv163 = -24						; size = 4
tv93 = -20						; size = 4
_len$ = -16						; size = 4
_uc$ = -12						; size = 4
_ptr$ = -8						; size = 4
_ptr2$ = -4						; size = 4
_item$ = 8						; size = 4
_str$ = 12						; size = 4
_parse_string PROC					; COMDAT

; 154  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 155  : 	const char *ptr = str + 1; char *ptr2; char *out; int len = 0; unsigned uc, uc2;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]
  00009	83 c0 01	 add	 eax, 1
  0000c	89 45 f8	 mov	 DWORD PTR _ptr$[ebp], eax
  0000f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 156  : 	if (*str != '\"') { ep = str; return 0; }	/* not a string! */

  00016	8b 4d 0c	 mov	 ecx, DWORD PTR _str$[ebp]
  00019	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0001c	83 fa 22	 cmp	 edx, 34			; 00000022H
  0001f	74 0f		 je	 SHORT $LN2@parse_stri
  00021	8b 45 0c	 mov	 eax, DWORD PTR _str$[ebp]
  00024	a3 00 00 00 00	 mov	 DWORD PTR _ep, eax
  00029	33 c0		 xor	 eax, eax
  0002b	e9 6e 03 00 00	 jmp	 $LN1@parse_stri
$LN2@parse_stri:

; 157  : 
; 158  : 	while (*ptr != '\"' && *ptr && ++len) if (*ptr++ == '\\') ptr++;	/* Skip escaped quotes. */

  00030	8b 4d f8	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00033	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00036	83 fa 22	 cmp	 edx, 34			; 00000022H
  00039	74 38		 je	 SHORT $LN3@parse_stri
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _ptr$[ebp]
  0003e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00041	85 c9		 test	 ecx, ecx
  00043	74 2e		 je	 SHORT $LN3@parse_stri
  00045	8b 55 f0	 mov	 edx, DWORD PTR _len$[ebp]
  00048	83 c2 01	 add	 edx, 1
  0004b	89 55 f0	 mov	 DWORD PTR _len$[ebp], edx
  0004e	74 23		 je	 SHORT $LN3@parse_stri
  00050	8b 45 f8	 mov	 eax, DWORD PTR _ptr$[ebp]
  00053	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00056	89 4d dc	 mov	 DWORD PTR tv76[ebp], ecx
  00059	8b 55 f8	 mov	 edx, DWORD PTR _ptr$[ebp]
  0005c	83 c2 01	 add	 edx, 1
  0005f	89 55 f8	 mov	 DWORD PTR _ptr$[ebp], edx
  00062	83 7d dc 5c	 cmp	 DWORD PTR tv76[ebp], 92	; 0000005cH
  00066	75 09		 jne	 SHORT $LN11@parse_stri
  00068	8b 45 f8	 mov	 eax, DWORD PTR _ptr$[ebp]
  0006b	83 c0 01	 add	 eax, 1
  0006e	89 45 f8	 mov	 DWORD PTR _ptr$[ebp], eax
$LN11@parse_stri:
  00071	eb bd		 jmp	 SHORT $LN2@parse_stri
$LN3@parse_stri:

; 159  : 
; 160  : 	out = (char*)cJSON_malloc(len + 1);	/* This is how long we need for the string, roughly. */

  00073	8b 4d f0	 mov	 ecx, DWORD PTR _len$[ebp]
  00076	83 c1 01	 add	 ecx, 1
  00079	51		 push	 ecx
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_malloc
  00080	83 c4 04	 add	 esp, 4
  00083	89 45 e0	 mov	 DWORD PTR _out$[ebp], eax

; 161  : 	if (!out) return 0;

  00086	83 7d e0 00	 cmp	 DWORD PTR _out$[ebp], 0
  0008a	75 07		 jne	 SHORT $LN12@parse_stri
  0008c	33 c0		 xor	 eax, eax
  0008e	e9 0b 03 00 00	 jmp	 $LN1@parse_stri
$LN12@parse_stri:

; 162  : 
; 163  : 	ptr = str + 1; ptr2 = out;

  00093	8b 55 0c	 mov	 edx, DWORD PTR _str$[ebp]
  00096	83 c2 01	 add	 edx, 1
  00099	89 55 f8	 mov	 DWORD PTR _ptr$[ebp], edx
  0009c	8b 45 e0	 mov	 eax, DWORD PTR _out$[ebp]
  0009f	89 45 fc	 mov	 DWORD PTR _ptr2$[ebp], eax
$LN4@parse_stri:

; 164  : 	while (*ptr != '\"' && *ptr)

  000a2	8b 4d f8	 mov	 ecx, DWORD PTR _ptr$[ebp]
  000a5	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000a8	83 fa 22	 cmp	 edx, 34			; 00000022H
  000ab	0f 84 bd 02 00
	00		 je	 $LN5@parse_stri
  000b1	8b 45 f8	 mov	 eax, DWORD PTR _ptr$[ebp]
  000b4	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000b7	85 c9		 test	 ecx, ecx
  000b9	0f 84 af 02 00
	00		 je	 $LN5@parse_stri

; 165  : 	{
; 166  : 		if (*ptr != '\\') *ptr2++ = *ptr++;

  000bf	8b 55 f8	 mov	 edx, DWORD PTR _ptr$[ebp]
  000c2	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000c5	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  000c8	74 21		 je	 SHORT $LN13@parse_stri
  000ca	8b 4d fc	 mov	 ecx, DWORD PTR _ptr2$[ebp]
  000cd	8b 55 f8	 mov	 edx, DWORD PTR _ptr$[ebp]
  000d0	8a 02		 mov	 al, BYTE PTR [edx]
  000d2	88 01		 mov	 BYTE PTR [ecx], al
  000d4	8b 4d fc	 mov	 ecx, DWORD PTR _ptr2$[ebp]
  000d7	83 c1 01	 add	 ecx, 1
  000da	89 4d fc	 mov	 DWORD PTR _ptr2$[ebp], ecx
  000dd	8b 55 f8	 mov	 edx, DWORD PTR _ptr$[ebp]
  000e0	83 c2 01	 add	 edx, 1
  000e3	89 55 f8	 mov	 DWORD PTR _ptr$[ebp], edx
  000e6	e9 7e 02 00 00	 jmp	 $LN14@parse_stri
$LN13@parse_stri:

; 167  : 		else
; 168  : 		{
; 169  : 			ptr++;

  000eb	8b 45 f8	 mov	 eax, DWORD PTR _ptr$[ebp]
  000ee	83 c0 01	 add	 eax, 1
  000f1	89 45 f8	 mov	 DWORD PTR _ptr$[ebp], eax

; 170  : 			switch (*ptr)

  000f4	8b 4d f8	 mov	 ecx, DWORD PTR _ptr$[ebp]
  000f7	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000fa	89 55 ec	 mov	 DWORD PTR tv93[ebp], edx
  000fd	8b 45 ec	 mov	 eax, DWORD PTR tv93[ebp]
  00100	83 e8 62	 sub	 eax, 98			; 00000062H
  00103	89 45 ec	 mov	 DWORD PTR tv93[ebp], eax
  00106	83 7d ec 13	 cmp	 DWORD PTR tv93[ebp], 19	; 00000013H
  0010a	0f 87 3d 02 00
	00		 ja	 $LN38@parse_stri
  00110	8b 4d ec	 mov	 ecx, DWORD PTR tv93[ebp]
  00113	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN41@parse_stri[ecx]
  0011a	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN42@parse_stri[edx*4]
$LN15@parse_stri:

; 171  : 			{
; 172  : 			case 'b': *ptr2++ = '\b';	break;

  00121	8b 45 fc	 mov	 eax, DWORD PTR _ptr2$[ebp]
  00124	c6 00 08	 mov	 BYTE PTR [eax], 8
  00127	8b 4d fc	 mov	 ecx, DWORD PTR _ptr2$[ebp]
  0012a	83 c1 01	 add	 ecx, 1
  0012d	89 4d fc	 mov	 DWORD PTR _ptr2$[ebp], ecx
  00130	e9 2b 02 00 00	 jmp	 $LN6@parse_stri
$LN16@parse_stri:

; 173  : 			case 'f': *ptr2++ = '\f';	break;

  00135	8b 55 fc	 mov	 edx, DWORD PTR _ptr2$[ebp]
  00138	c6 02 0c	 mov	 BYTE PTR [edx], 12	; 0000000cH
  0013b	8b 45 fc	 mov	 eax, DWORD PTR _ptr2$[ebp]
  0013e	83 c0 01	 add	 eax, 1
  00141	89 45 fc	 mov	 DWORD PTR _ptr2$[ebp], eax
  00144	e9 17 02 00 00	 jmp	 $LN6@parse_stri
$LN17@parse_stri:

; 174  : 			case 'n': *ptr2++ = '\n';	break;

  00149	8b 4d fc	 mov	 ecx, DWORD PTR _ptr2$[ebp]
  0014c	c6 01 0a	 mov	 BYTE PTR [ecx], 10	; 0000000aH
  0014f	8b 55 fc	 mov	 edx, DWORD PTR _ptr2$[ebp]
  00152	83 c2 01	 add	 edx, 1
  00155	89 55 fc	 mov	 DWORD PTR _ptr2$[ebp], edx
  00158	e9 03 02 00 00	 jmp	 $LN6@parse_stri
$LN18@parse_stri:

; 175  : 			case 'r': *ptr2++ = '\r';	break;

  0015d	8b 45 fc	 mov	 eax, DWORD PTR _ptr2$[ebp]
  00160	c6 00 0d	 mov	 BYTE PTR [eax], 13	; 0000000dH
  00163	8b 4d fc	 mov	 ecx, DWORD PTR _ptr2$[ebp]
  00166	83 c1 01	 add	 ecx, 1
  00169	89 4d fc	 mov	 DWORD PTR _ptr2$[ebp], ecx
  0016c	e9 ef 01 00 00	 jmp	 $LN6@parse_stri
$LN19@parse_stri:

; 176  : 			case 't': *ptr2++ = '\t';	break;

  00171	8b 55 fc	 mov	 edx, DWORD PTR _ptr2$[ebp]
  00174	c6 02 09	 mov	 BYTE PTR [edx], 9
  00177	8b 45 fc	 mov	 eax, DWORD PTR _ptr2$[ebp]
  0017a	83 c0 01	 add	 eax, 1
  0017d	89 45 fc	 mov	 DWORD PTR _ptr2$[ebp], eax
  00180	e9 db 01 00 00	 jmp	 $LN6@parse_stri
$LN20@parse_stri:

; 177  : 			case 'u':	 /* transcode utf16 to utf8. */
; 178  : 				uc = parse_hex4(ptr + 1); ptr += 4;	/* get the unicode char. */

  00185	8b 4d f8	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00188	83 c1 01	 add	 ecx, 1
  0018b	51		 push	 ecx
  0018c	e8 00 00 00 00	 call	 _parse_hex4
  00191	83 c4 04	 add	 esp, 4
  00194	89 45 f4	 mov	 DWORD PTR _uc$[ebp], eax
  00197	8b 55 f8	 mov	 edx, DWORD PTR _ptr$[ebp]
  0019a	83 c2 04	 add	 edx, 4
  0019d	89 55 f8	 mov	 DWORD PTR _ptr$[ebp], edx

; 179  : 
; 180  : 				if ((uc >= 0xDC00 && uc <= 0xDFFF) || uc == 0)	break;	/* check for invalid.	*/

  001a0	81 7d f4 00 dc
	00 00		 cmp	 DWORD PTR _uc$[ebp], 56320 ; 0000dc00H
  001a7	72 09		 jb	 SHORT $LN23@parse_stri
  001a9	81 7d f4 ff df
	00 00		 cmp	 DWORD PTR _uc$[ebp], 57343 ; 0000dfffH
  001b0	76 06		 jbe	 SHORT $LN22@parse_stri
$LN23@parse_stri:
  001b2	83 7d f4 00	 cmp	 DWORD PTR _uc$[ebp], 0
  001b6	75 05		 jne	 SHORT $LN21@parse_stri
$LN22@parse_stri:
  001b8	e9 a3 01 00 00	 jmp	 $LN6@parse_stri
$LN21@parse_stri:

; 181  : 
; 182  : 				if (uc >= 0xD800 && uc <= 0xDBFF)	/* UTF16 surrogate pairs.	*/

  001bd	81 7d f4 00 d8
	00 00		 cmp	 DWORD PTR _uc$[ebp], 55296 ; 0000d800H
  001c4	0f 82 86 00 00
	00		 jb	 $LN24@parse_stri
  001ca	81 7d f4 ff db
	00 00		 cmp	 DWORD PTR _uc$[ebp], 56319 ; 0000dbffH
  001d1	77 7d		 ja	 SHORT $LN24@parse_stri

; 183  : 				{
; 184  : 					if (ptr[1] != '\\' || ptr[2] != 'u')	break;	/* missing second-half of surrogate.	*/

  001d3	b8 01 00 00 00	 mov	 eax, 1
  001d8	c1 e0 00	 shl	 eax, 0
  001db	8b 4d f8	 mov	 ecx, DWORD PTR _ptr$[ebp]
  001de	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  001e2	83 fa 5c	 cmp	 edx, 92			; 0000005cH
  001e5	75 13		 jne	 SHORT $LN26@parse_stri
  001e7	b8 01 00 00 00	 mov	 eax, 1
  001ec	d1 e0		 shl	 eax, 1
  001ee	8b 4d f8	 mov	 ecx, DWORD PTR _ptr$[ebp]
  001f1	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  001f5	83 fa 75	 cmp	 edx, 117		; 00000075H
  001f8	74 05		 je	 SHORT $LN25@parse_stri
$LN26@parse_stri:
  001fa	e9 61 01 00 00	 jmp	 $LN6@parse_stri
$LN25@parse_stri:

; 185  : 					uc2 = parse_hex4(ptr + 3); ptr += 6;

  001ff	8b 45 f8	 mov	 eax, DWORD PTR _ptr$[ebp]
  00202	83 c0 03	 add	 eax, 3
  00205	50		 push	 eax
  00206	e8 00 00 00 00	 call	 _parse_hex4
  0020b	83 c4 04	 add	 esp, 4
  0020e	89 45 e4	 mov	 DWORD PTR _uc2$[ebp], eax
  00211	8b 4d f8	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00214	83 c1 06	 add	 ecx, 6
  00217	89 4d f8	 mov	 DWORD PTR _ptr$[ebp], ecx

; 186  : 					if (uc2<0xDC00 || uc2>0xDFFF)		break;	/* invalid second-half of surrogate.	*/

  0021a	81 7d e4 00 dc
	00 00		 cmp	 DWORD PTR _uc2$[ebp], 56320 ; 0000dc00H
  00221	72 09		 jb	 SHORT $LN28@parse_stri
  00223	81 7d e4 ff df
	00 00		 cmp	 DWORD PTR _uc2$[ebp], 57343 ; 0000dfffH
  0022a	76 05		 jbe	 SHORT $LN27@parse_stri
$LN28@parse_stri:
  0022c	e9 2f 01 00 00	 jmp	 $LN6@parse_stri
$LN27@parse_stri:

; 187  : 					uc = 0x10000 + (((uc & 0x3FF) << 10) | (uc2 & 0x3FF));

  00231	8b 55 f4	 mov	 edx, DWORD PTR _uc$[ebp]
  00234	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  0023a	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  0023d	8b 45 e4	 mov	 eax, DWORD PTR _uc2$[ebp]
  00240	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00245	0b d0		 or	 edx, eax
  00247	81 c2 00 00 01
	00		 add	 edx, 65536		; 00010000H
  0024d	89 55 f4	 mov	 DWORD PTR _uc$[ebp], edx
$LN24@parse_stri:

; 188  : 				}
; 189  : 
; 190  : 				len = 4; if (uc<0x80) len = 1; else if (uc<0x800) len = 2; else if (uc<0x10000) len = 3; ptr2 += len;

  00250	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR _len$[ebp], 4
  00257	81 7d f4 80 00
	00 00		 cmp	 DWORD PTR _uc$[ebp], 128 ; 00000080H
  0025e	73 09		 jae	 SHORT $LN29@parse_stri
  00260	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _len$[ebp], 1
  00267	eb 22		 jmp	 SHORT $LN30@parse_stri
$LN29@parse_stri:
  00269	81 7d f4 00 08
	00 00		 cmp	 DWORD PTR _uc$[ebp], 2048 ; 00000800H
  00270	73 09		 jae	 SHORT $LN31@parse_stri
  00272	c7 45 f0 02 00
	00 00		 mov	 DWORD PTR _len$[ebp], 2
  00279	eb 10		 jmp	 SHORT $LN30@parse_stri
$LN31@parse_stri:
  0027b	81 7d f4 00 00
	01 00		 cmp	 DWORD PTR _uc$[ebp], 65536 ; 00010000H
  00282	73 07		 jae	 SHORT $LN30@parse_stri
  00284	c7 45 f0 03 00
	00 00		 mov	 DWORD PTR _len$[ebp], 3
$LN30@parse_stri:
  0028b	8b 4d fc	 mov	 ecx, DWORD PTR _ptr2$[ebp]
  0028e	03 4d f0	 add	 ecx, DWORD PTR _len$[ebp]
  00291	89 4d fc	 mov	 DWORD PTR _ptr2$[ebp], ecx

; 191  : 
; 192  : 				switch (len) {

  00294	8b 55 f0	 mov	 edx, DWORD PTR _len$[ebp]
  00297	89 55 e8	 mov	 DWORD PTR tv163[ebp], edx
  0029a	8b 45 e8	 mov	 eax, DWORD PTR tv163[ebp]
  0029d	83 e8 01	 sub	 eax, 1
  002a0	89 45 e8	 mov	 DWORD PTR tv163[ebp], eax
  002a3	83 7d e8 03	 cmp	 DWORD PTR tv163[ebp], 3
  002a7	0f 87 95 00 00
	00		 ja	 $LN8@parse_stri
  002ad	8b 4d e8	 mov	 ecx, DWORD PTR tv163[ebp]
  002b0	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN43@parse_stri[ecx*4]
$LN34@parse_stri:

; 193  : 				case 4: *--ptr2 = ((uc | 0x80) & 0xBF); uc >>= 6;

  002b7	8b 55 fc	 mov	 edx, DWORD PTR _ptr2$[ebp]
  002ba	83 ea 01	 sub	 edx, 1
  002bd	89 55 fc	 mov	 DWORD PTR _ptr2$[ebp], edx
  002c0	8b 45 f4	 mov	 eax, DWORD PTR _uc$[ebp]
  002c3	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  002c8	25 bf 00 00 00	 and	 eax, 191		; 000000bfH
  002cd	8b 4d fc	 mov	 ecx, DWORD PTR _ptr2$[ebp]
  002d0	88 01		 mov	 BYTE PTR [ecx], al
  002d2	8b 55 f4	 mov	 edx, DWORD PTR _uc$[ebp]
  002d5	c1 ea 06	 shr	 edx, 6
  002d8	89 55 f4	 mov	 DWORD PTR _uc$[ebp], edx
$LN35@parse_stri:

; 194  : 				case 3: *--ptr2 = ((uc | 0x80) & 0xBF); uc >>= 6;

  002db	8b 45 fc	 mov	 eax, DWORD PTR _ptr2$[ebp]
  002de	83 e8 01	 sub	 eax, 1
  002e1	89 45 fc	 mov	 DWORD PTR _ptr2$[ebp], eax
  002e4	8b 4d f4	 mov	 ecx, DWORD PTR _uc$[ebp]
  002e7	81 c9 80 00 00
	00		 or	 ecx, 128		; 00000080H
  002ed	81 e1 bf 00 00
	00		 and	 ecx, 191		; 000000bfH
  002f3	8b 55 fc	 mov	 edx, DWORD PTR _ptr2$[ebp]
  002f6	88 0a		 mov	 BYTE PTR [edx], cl
  002f8	8b 45 f4	 mov	 eax, DWORD PTR _uc$[ebp]
  002fb	c1 e8 06	 shr	 eax, 6
  002fe	89 45 f4	 mov	 DWORD PTR _uc$[ebp], eax
$LN36@parse_stri:

; 195  : 				case 2: *--ptr2 = ((uc | 0x80) & 0xBF); uc >>= 6;

  00301	8b 4d fc	 mov	 ecx, DWORD PTR _ptr2$[ebp]
  00304	83 e9 01	 sub	 ecx, 1
  00307	89 4d fc	 mov	 DWORD PTR _ptr2$[ebp], ecx
  0030a	8b 55 f4	 mov	 edx, DWORD PTR _uc$[ebp]
  0030d	81 ca 80 00 00
	00		 or	 edx, 128		; 00000080H
  00313	81 e2 bf 00 00
	00		 and	 edx, 191		; 000000bfH
  00319	8b 45 fc	 mov	 eax, DWORD PTR _ptr2$[ebp]
  0031c	88 10		 mov	 BYTE PTR [eax], dl
  0031e	8b 4d f4	 mov	 ecx, DWORD PTR _uc$[ebp]
  00321	c1 e9 06	 shr	 ecx, 6
  00324	89 4d f4	 mov	 DWORD PTR _uc$[ebp], ecx
$LN37@parse_stri:

; 196  : 				case 1: *--ptr2 = (uc | firstByteMark[len]);

  00327	8b 55 fc	 mov	 edx, DWORD PTR _ptr2$[ebp]
  0032a	83 ea 01	 sub	 edx, 1
  0032d	89 55 fc	 mov	 DWORD PTR _ptr2$[ebp], edx
  00330	8b 45 f0	 mov	 eax, DWORD PTR _len$[ebp]
  00333	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _firstByteMark[eax]
  0033a	0b 4d f4	 or	 ecx, DWORD PTR _uc$[ebp]
  0033d	8b 55 fc	 mov	 edx, DWORD PTR _ptr2$[ebp]
  00340	88 0a		 mov	 BYTE PTR [edx], cl
$LN8@parse_stri:

; 197  : 				}
; 198  : 				ptr2 += len;

  00342	8b 45 fc	 mov	 eax, DWORD PTR _ptr2$[ebp]
  00345	03 45 f0	 add	 eax, DWORD PTR _len$[ebp]
  00348	89 45 fc	 mov	 DWORD PTR _ptr2$[ebp], eax

; 199  : 				break;

  0034b	eb 13		 jmp	 SHORT $LN6@parse_stri
$LN38@parse_stri:

; 200  : 			default:  *ptr2++ = *ptr; break;

  0034d	8b 4d fc	 mov	 ecx, DWORD PTR _ptr2$[ebp]
  00350	8b 55 f8	 mov	 edx, DWORD PTR _ptr$[ebp]
  00353	8a 02		 mov	 al, BYTE PTR [edx]
  00355	88 01		 mov	 BYTE PTR [ecx], al
  00357	8b 4d fc	 mov	 ecx, DWORD PTR _ptr2$[ebp]
  0035a	83 c1 01	 add	 ecx, 1
  0035d	89 4d fc	 mov	 DWORD PTR _ptr2$[ebp], ecx
$LN6@parse_stri:

; 201  : 			}
; 202  : 			ptr++;

  00360	8b 55 f8	 mov	 edx, DWORD PTR _ptr$[ebp]
  00363	83 c2 01	 add	 edx, 1
  00366	89 55 f8	 mov	 DWORD PTR _ptr$[ebp], edx
$LN14@parse_stri:

; 203  : 		}
; 204  : 	}

  00369	e9 34 fd ff ff	 jmp	 $LN4@parse_stri
$LN5@parse_stri:

; 205  : 	*ptr2 = 0;

  0036e	8b 45 fc	 mov	 eax, DWORD PTR _ptr2$[ebp]
  00371	c6 00 00	 mov	 BYTE PTR [eax], 0

; 206  : 	if (*ptr == '\"') ptr++;

  00374	8b 4d f8	 mov	 ecx, DWORD PTR _ptr$[ebp]
  00377	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0037a	83 fa 22	 cmp	 edx, 34			; 00000022H
  0037d	75 09		 jne	 SHORT $LN39@parse_stri
  0037f	8b 45 f8	 mov	 eax, DWORD PTR _ptr$[ebp]
  00382	83 c0 01	 add	 eax, 1
  00385	89 45 f8	 mov	 DWORD PTR _ptr$[ebp], eax
$LN39@parse_stri:

; 207  : 	item->valuestring = out;

  00388	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  0038b	8b 55 e0	 mov	 edx, DWORD PTR _out$[ebp]
  0038e	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 208  : 	item->type = cJSON_String;

  00391	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00394	c7 40 0c 04 00
	00 00		 mov	 DWORD PTR [eax+12], 4

; 209  : 	return ptr;

  0039b	8b 45 f8	 mov	 eax, DWORD PTR _ptr$[ebp]
$LN1@parse_stri:

; 210  : }

  0039e	8b e5		 mov	 esp, ebp
  003a0	5d		 pop	 ebp
  003a1	c3		 ret	 0
  003a2	8b ff		 npad	 2
$LN42@parse_stri:
  003a4	00 00 00 00	 DD	 $LN15@parse_stri
  003a8	00 00 00 00	 DD	 $LN16@parse_stri
  003ac	00 00 00 00	 DD	 $LN17@parse_stri
  003b0	00 00 00 00	 DD	 $LN18@parse_stri
  003b4	00 00 00 00	 DD	 $LN19@parse_stri
  003b8	00 00 00 00	 DD	 $LN20@parse_stri
  003bc	00 00 00 00	 DD	 $LN38@parse_stri
$LN41@parse_stri:
  003c0	00		 DB	 0
  003c1	06		 DB	 6
  003c2	06		 DB	 6
  003c3	06		 DB	 6
  003c4	01		 DB	 1
  003c5	06		 DB	 6
  003c6	06		 DB	 6
  003c7	06		 DB	 6
  003c8	06		 DB	 6
  003c9	06		 DB	 6
  003ca	06		 DB	 6
  003cb	06		 DB	 6
  003cc	02		 DB	 2
  003cd	06		 DB	 6
  003ce	06		 DB	 6
  003cf	06		 DB	 6
  003d0	03		 DB	 3
  003d1	06		 DB	 6
  003d2	04		 DB	 4
  003d3	05		 DB	 5
$LN43@parse_stri:
  003d4	00 00 00 00	 DD	 $LN37@parse_stri
  003d8	00 00 00 00	 DD	 $LN36@parse_stri
  003dc	00 00 00 00	 DD	 $LN35@parse_stri
  003e0	00 00 00 00	 DD	 $LN34@parse_stri
_parse_string ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _parse_hex4
_TEXT	SEGMENT
_h$ = -4						; size = 4
_str$ = 8						; size = 4
_parse_hex4 PROC					; COMDAT

; 139  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 140  : 	unsigned h = 0;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _h$[ebp], 0

; 141  : 	if (*str >= '0' && *str <= '9') h += (*str) - '0'; else if (*str >= 'A' && *str <= 'F') h += 10 + (*str) - 'A'; else if (*str >= 'a' && *str <= 'f') h += 10 + (*str) - 'a'; else return 0;

  0000b	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  0000e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00011	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00014	7c 1d		 jl	 SHORT $LN2@parse_hex4
  00016	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00019	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0001c	83 f8 39	 cmp	 eax, 57			; 00000039H
  0001f	7f 12		 jg	 SHORT $LN2@parse_hex4
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00024	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00027	8b 45 fc	 mov	 eax, DWORD PTR _h$[ebp]
  0002a	8d 4c 10 d0	 lea	 ecx, DWORD PTR [eax+edx-48]
  0002e	89 4d fc	 mov	 DWORD PTR _h$[ebp], ecx
  00031	eb 57		 jmp	 SHORT $LN3@parse_hex4
$LN2@parse_hex4:
  00033	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00036	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00039	83 f8 41	 cmp	 eax, 65			; 00000041H
  0003c	7c 1d		 jl	 SHORT $LN4@parse_hex4
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00041	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00044	83 fa 46	 cmp	 edx, 70			; 00000046H
  00047	7f 12		 jg	 SHORT $LN4@parse_hex4
  00049	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  0004c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0004f	8b 55 fc	 mov	 edx, DWORD PTR _h$[ebp]
  00052	8d 44 0a c9	 lea	 eax, DWORD PTR [edx+ecx-55]
  00056	89 45 fc	 mov	 DWORD PTR _h$[ebp], eax
  00059	eb 2f		 jmp	 SHORT $LN3@parse_hex4
$LN4@parse_hex4:
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0005e	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00061	83 fa 61	 cmp	 edx, 97			; 00000061H
  00064	7c 1d		 jl	 SHORT $LN6@parse_hex4
  00066	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00069	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0006c	83 f9 66	 cmp	 ecx, 102		; 00000066H
  0006f	7f 12		 jg	 SHORT $LN6@parse_hex4
  00071	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00074	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00077	8b 4d fc	 mov	 ecx, DWORD PTR _h$[ebp]
  0007a	8d 54 01 a9	 lea	 edx, DWORD PTR [ecx+eax-87]
  0007e	89 55 fc	 mov	 DWORD PTR _h$[ebp], edx
  00081	eb 07		 jmp	 SHORT $LN3@parse_hex4
$LN6@parse_hex4:
  00083	33 c0		 xor	 eax, eax
  00085	e9 b3 01 00 00	 jmp	 $LN1@parse_hex4
$LN3@parse_hex4:

; 142  : 	h = h << 4; str++;

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _h$[ebp]
  0008d	c1 e0 04	 shl	 eax, 4
  00090	89 45 fc	 mov	 DWORD PTR _h$[ebp], eax
  00093	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00096	83 c1 01	 add	 ecx, 1
  00099	89 4d 08	 mov	 DWORD PTR _str$[ebp], ecx

; 143  : 	if (*str >= '0' && *str <= '9') h += (*str) - '0'; else if (*str >= 'A' && *str <= 'F') h += 10 + (*str) - 'A'; else if (*str >= 'a' && *str <= 'f') h += 10 + (*str) - 'a'; else return 0;

  0009c	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  0009f	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000a2	83 f8 30	 cmp	 eax, 48			; 00000030H
  000a5	7c 1d		 jl	 SHORT $LN8@parse_hex4
  000a7	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  000aa	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000ad	83 fa 39	 cmp	 edx, 57			; 00000039H
  000b0	7f 12		 jg	 SHORT $LN8@parse_hex4
  000b2	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  000b5	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000b8	8b 55 fc	 mov	 edx, DWORD PTR _h$[ebp]
  000bb	8d 44 0a d0	 lea	 eax, DWORD PTR [edx+ecx-48]
  000bf	89 45 fc	 mov	 DWORD PTR _h$[ebp], eax
  000c2	eb 57		 jmp	 SHORT $LN9@parse_hex4
$LN8@parse_hex4:
  000c4	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  000c7	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000ca	83 fa 41	 cmp	 edx, 65			; 00000041H
  000cd	7c 1d		 jl	 SHORT $LN10@parse_hex4
  000cf	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  000d2	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000d5	83 f9 46	 cmp	 ecx, 70			; 00000046H
  000d8	7f 12		 jg	 SHORT $LN10@parse_hex4
  000da	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  000dd	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000e0	8b 4d fc	 mov	 ecx, DWORD PTR _h$[ebp]
  000e3	8d 54 01 c9	 lea	 edx, DWORD PTR [ecx+eax-55]
  000e7	89 55 fc	 mov	 DWORD PTR _h$[ebp], edx
  000ea	eb 2f		 jmp	 SHORT $LN9@parse_hex4
$LN10@parse_hex4:
  000ec	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  000ef	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000f2	83 f9 61	 cmp	 ecx, 97			; 00000061H
  000f5	7c 1d		 jl	 SHORT $LN12@parse_hex4
  000f7	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  000fa	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000fd	83 f8 66	 cmp	 eax, 102		; 00000066H
  00100	7f 12		 jg	 SHORT $LN12@parse_hex4
  00102	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00105	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00108	8b 45 fc	 mov	 eax, DWORD PTR _h$[ebp]
  0010b	8d 4c 10 a9	 lea	 ecx, DWORD PTR [eax+edx-87]
  0010f	89 4d fc	 mov	 DWORD PTR _h$[ebp], ecx
  00112	eb 07		 jmp	 SHORT $LN9@parse_hex4
$LN12@parse_hex4:
  00114	33 c0		 xor	 eax, eax
  00116	e9 22 01 00 00	 jmp	 $LN1@parse_hex4
$LN9@parse_hex4:

; 144  : 	h = h << 4; str++;

  0011b	8b 55 fc	 mov	 edx, DWORD PTR _h$[ebp]
  0011e	c1 e2 04	 shl	 edx, 4
  00121	89 55 fc	 mov	 DWORD PTR _h$[ebp], edx
  00124	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00127	83 c0 01	 add	 eax, 1
  0012a	89 45 08	 mov	 DWORD PTR _str$[ebp], eax

; 145  : 	if (*str >= '0' && *str <= '9') h += (*str) - '0'; else if (*str >= 'A' && *str <= 'F') h += 10 + (*str) - 'A'; else if (*str >= 'a' && *str <= 'f') h += 10 + (*str) - 'a'; else return 0;

  0012d	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00130	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00133	83 fa 30	 cmp	 edx, 48			; 00000030H
  00136	7c 1d		 jl	 SHORT $LN14@parse_hex4
  00138	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  0013b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0013e	83 f9 39	 cmp	 ecx, 57			; 00000039H
  00141	7f 12		 jg	 SHORT $LN14@parse_hex4
  00143	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00146	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00149	8b 4d fc	 mov	 ecx, DWORD PTR _h$[ebp]
  0014c	8d 54 01 d0	 lea	 edx, DWORD PTR [ecx+eax-48]
  00150	89 55 fc	 mov	 DWORD PTR _h$[ebp], edx
  00153	eb 57		 jmp	 SHORT $LN15@parse_hex4
$LN14@parse_hex4:
  00155	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00158	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0015b	83 f9 41	 cmp	 ecx, 65			; 00000041H
  0015e	7c 1d		 jl	 SHORT $LN16@parse_hex4
  00160	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00163	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00166	83 f8 46	 cmp	 eax, 70			; 00000046H
  00169	7f 12		 jg	 SHORT $LN16@parse_hex4
  0016b	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0016e	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00171	8b 45 fc	 mov	 eax, DWORD PTR _h$[ebp]
  00174	8d 4c 10 c9	 lea	 ecx, DWORD PTR [eax+edx-55]
  00178	89 4d fc	 mov	 DWORD PTR _h$[ebp], ecx
  0017b	eb 2f		 jmp	 SHORT $LN15@parse_hex4
$LN16@parse_hex4:
  0017d	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00180	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00183	83 f8 61	 cmp	 eax, 97			; 00000061H
  00186	7c 1d		 jl	 SHORT $LN18@parse_hex4
  00188	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0018b	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0018e	83 fa 66	 cmp	 edx, 102		; 00000066H
  00191	7f 12		 jg	 SHORT $LN18@parse_hex4
  00193	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00196	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00199	8b 55 fc	 mov	 edx, DWORD PTR _h$[ebp]
  0019c	8d 44 0a a9	 lea	 eax, DWORD PTR [edx+ecx-87]
  001a0	89 45 fc	 mov	 DWORD PTR _h$[ebp], eax
  001a3	eb 07		 jmp	 SHORT $LN15@parse_hex4
$LN18@parse_hex4:
  001a5	33 c0		 xor	 eax, eax
  001a7	e9 91 00 00 00	 jmp	 $LN1@parse_hex4
$LN15@parse_hex4:

; 146  : 	h = h << 4; str++;

  001ac	8b 4d fc	 mov	 ecx, DWORD PTR _h$[ebp]
  001af	c1 e1 04	 shl	 ecx, 4
  001b2	89 4d fc	 mov	 DWORD PTR _h$[ebp], ecx
  001b5	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  001b8	83 c2 01	 add	 edx, 1
  001bb	89 55 08	 mov	 DWORD PTR _str$[ebp], edx

; 147  : 	if (*str >= '0' && *str <= '9') h += (*str) - '0'; else if (*str >= 'A' && *str <= 'F') h += 10 + (*str) - 'A'; else if (*str >= 'a' && *str <= 'f') h += 10 + (*str) - 'a'; else return 0;

  001be	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  001c1	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001c4	83 f9 30	 cmp	 ecx, 48			; 00000030H
  001c7	7c 1d		 jl	 SHORT $LN20@parse_hex4
  001c9	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  001cc	0f be 02	 movsx	 eax, BYTE PTR [edx]
  001cf	83 f8 39	 cmp	 eax, 57			; 00000039H
  001d2	7f 12		 jg	 SHORT $LN20@parse_hex4
  001d4	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  001d7	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  001da	8b 45 fc	 mov	 eax, DWORD PTR _h$[ebp]
  001dd	8d 4c 10 d0	 lea	 ecx, DWORD PTR [eax+edx-48]
  001e1	89 4d fc	 mov	 DWORD PTR _h$[ebp], ecx
  001e4	eb 54		 jmp	 SHORT $LN21@parse_hex4
$LN20@parse_hex4:
  001e6	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  001e9	0f be 02	 movsx	 eax, BYTE PTR [edx]
  001ec	83 f8 41	 cmp	 eax, 65			; 00000041H
  001ef	7c 1d		 jl	 SHORT $LN22@parse_hex4
  001f1	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  001f4	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  001f7	83 fa 46	 cmp	 edx, 70			; 00000046H
  001fa	7f 12		 jg	 SHORT $LN22@parse_hex4
  001fc	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  001ff	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00202	8b 55 fc	 mov	 edx, DWORD PTR _h$[ebp]
  00205	8d 44 0a c9	 lea	 eax, DWORD PTR [edx+ecx-55]
  00209	89 45 fc	 mov	 DWORD PTR _h$[ebp], eax
  0020c	eb 2c		 jmp	 SHORT $LN21@parse_hex4
$LN22@parse_hex4:
  0020e	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00211	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00214	83 fa 61	 cmp	 edx, 97			; 00000061H
  00217	7c 1d		 jl	 SHORT $LN24@parse_hex4
  00219	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  0021c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0021f	83 f9 66	 cmp	 ecx, 102		; 00000066H
  00222	7f 12		 jg	 SHORT $LN24@parse_hex4
  00224	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00227	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0022a	8b 4d fc	 mov	 ecx, DWORD PTR _h$[ebp]
  0022d	8d 54 01 a9	 lea	 edx, DWORD PTR [ecx+eax-87]
  00231	89 55 fc	 mov	 DWORD PTR _h$[ebp], edx
  00234	eb 04		 jmp	 SHORT $LN21@parse_hex4
$LN24@parse_hex4:
  00236	33 c0		 xor	 eax, eax
  00238	eb 03		 jmp	 SHORT $LN1@parse_hex4
$LN21@parse_hex4:

; 148  : 	return h;

  0023a	8b 45 fc	 mov	 eax, DWORD PTR _h$[ebp]
$LN1@parse_hex4:

; 149  : }

  0023d	8b e5		 mov	 esp, ebp
  0023f	5d		 pop	 ebp
  00240	c3		 ret	 0
_parse_hex4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _print_number
_TEXT	SEGMENT
tv143 = -20						; size = 8
_d$ = -12						; size = 8
_str$ = -4						; size = 4
_item$ = 8						; size = 4
_print_number PROC					; COMDAT

; 117  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 118  : 	char *str;
; 119  : 	double d = item->valuedouble;

  00006	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00009	dd 40 18	 fld	 QWORD PTR [eax+24]
  0000c	dd 5d f4	 fstp	 QWORD PTR _d$[ebp]

; 120  : 	if (fabs(((double)item->valueint) - d) <= DBL_EPSILON && d <= INT_MAX && d >= INT_MIN)

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00012	db 41 14	 fild	 DWORD PTR [ecx+20]
  00015	dd 5d ec	 fstp	 QWORD PTR tv143[ebp]
  00018	dd 45 ec	 fld	 QWORD PTR tv143[ebp]
  0001b	dc 65 f4	 fsub	 QWORD PTR _d$[ebp]
  0001e	83 ec 08	 sub	 esp, 8
  00021	dd 1c 24	 fstp	 QWORD PTR [esp]
  00024	e8 00 00 00 00	 call	 _fabs
  00029	83 c4 08	 add	 esp, 8
  0002c	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@3e80000000000000
  00032	df e0		 fnstsw	 ax
  00034	f6 c4 41	 test	 ah, 65			; 00000041H
  00037	7a 51		 jp	 SHORT $LN2@print_numb
  00039	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@41dfffffffc00000
  0003f	dc 5d f4	 fcomp	 QWORD PTR _d$[ebp]
  00042	df e0		 fnstsw	 ax
  00044	f6 c4 01	 test	 ah, 1
  00047	75 41		 jne	 SHORT $LN2@print_numb
  00049	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@c1e0000000000000
  0004f	dc 5d f4	 fcomp	 QWORD PTR _d$[ebp]
  00052	df e0		 fnstsw	 ax
  00054	f6 c4 41	 test	 ah, 65			; 00000041H
  00057	7a 31		 jp	 SHORT $LN2@print_numb

; 121  : 	{
; 122  : 		str = (char*)cJSON_malloc(21);	/* 2^64+1 can be represented in 21 chars. */

  00059	6a 15		 push	 21			; 00000015H
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_malloc
  00061	83 c4 04	 add	 esp, 4
  00064	89 45 fc	 mov	 DWORD PTR _str$[ebp], eax

; 123  : 		if (str) sprintf(str, "%d", item->valueint);

  00067	83 7d fc 00	 cmp	 DWORD PTR _str$[ebp], 0
  0006b	74 18		 je	 SHORT $LN4@print_numb
  0006d	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00070	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00073	50		 push	 eax
  00074	68 00 00 00 00	 push	 OFFSET $SG5072
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _str$[ebp]
  0007c	51		 push	 ecx
  0007d	e8 00 00 00 00	 call	 __hx_sprintf
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@print_numb:

; 124  : 	}

  00085	e9 f3 00 00 00	 jmp	 $LN9@print_numb
$LN2@print_numb:

; 125  : 	else
; 126  : 	{
; 127  : 		str = (char*)cJSON_malloc(64);	/* This is a nice tradeoff. */

  0008a	6a 40		 push	 64			; 00000040H
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_malloc
  00092	83 c4 04	 add	 esp, 4
  00095	89 45 fc	 mov	 DWORD PTR _str$[ebp], eax

; 128  : 		if (str)

  00098	83 7d fc 00	 cmp	 DWORD PTR _str$[ebp], 0
  0009c	0f 84 db 00 00
	00		 je	 $LN9@print_numb

; 129  : 		{
; 130  : 			if (fabs(floor(d) - d) <= DBL_EPSILON && fabs(d)<1.0e60)sprintf(str, "%.0f", d);

  000a2	83 ec 08	 sub	 esp, 8
  000a5	dd 45 f4	 fld	 QWORD PTR _d$[ebp]
  000a8	dd 1c 24	 fstp	 QWORD PTR [esp]
  000ab	e8 00 00 00 00	 call	 _floor
  000b0	83 c4 08	 add	 esp, 8
  000b3	dc 65 f4	 fsub	 QWORD PTR _d$[ebp]
  000b6	83 ec 08	 sub	 esp, 8
  000b9	dd 1c 24	 fstp	 QWORD PTR [esp]
  000bc	e8 00 00 00 00	 call	 _fabs
  000c1	83 c4 08	 add	 esp, 8
  000c4	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@3e80000000000000
  000ca	df e0		 fnstsw	 ax
  000cc	f6 c4 41	 test	 ah, 65			; 00000041H
  000cf	7a 3a		 jp	 SHORT $LN6@print_numb
  000d1	83 ec 08	 sub	 esp, 8
  000d4	dd 45 f4	 fld	 QWORD PTR _d$[ebp]
  000d7	dd 1c 24	 fstp	 QWORD PTR [esp]
  000da	e8 00 00 00 00	 call	 _fabs
  000df	83 c4 08	 add	 esp, 8
  000e2	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@4c63e9e4e4c2f344
  000e8	df e0		 fnstsw	 ax
  000ea	f6 c4 05	 test	 ah, 5
  000ed	7a 1c		 jp	 SHORT $LN6@print_numb
  000ef	83 ec 08	 sub	 esp, 8
  000f2	dd 45 f4	 fld	 QWORD PTR _d$[ebp]
  000f5	dd 1c 24	 fstp	 QWORD PTR [esp]
  000f8	68 00 00 00 00	 push	 OFFSET $SG5076
  000fd	8b 55 fc	 mov	 edx, DWORD PTR _str$[ebp]
  00100	52		 push	 edx
  00101	e8 00 00 00 00	 call	 __hx_sprintf
  00106	83 c4 10	 add	 esp, 16			; 00000010H
  00109	eb 72		 jmp	 SHORT $LN9@print_numb
$LN6@print_numb:

; 131  : 			else if (fabs(d)<1.0e-6 || fabs(d)>1.0e9)			sprintf(str, "%e", d);

  0010b	83 ec 08	 sub	 esp, 8
  0010e	dd 45 f4	 fld	 QWORD PTR _d$[ebp]
  00111	dd 1c 24	 fstp	 QWORD PTR [esp]
  00114	e8 00 00 00 00	 call	 _fabs
  00119	83 c4 08	 add	 esp, 8
  0011c	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@3eb0c6f7a0b5ed8d
  00122	df e0		 fnstsw	 ax
  00124	f6 c4 05	 test	 ah, 5
  00127	7b 1e		 jnp	 SHORT $LN10@print_numb
  00129	83 ec 08	 sub	 esp, 8
  0012c	dd 45 f4	 fld	 QWORD PTR _d$[ebp]
  0012f	dd 1c 24	 fstp	 QWORD PTR [esp]
  00132	e8 00 00 00 00	 call	 _fabs
  00137	83 c4 08	 add	 esp, 8
  0013a	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@41cdcd6500000000
  00140	df e0		 fnstsw	 ax
  00142	f6 c4 41	 test	 ah, 65			; 00000041H
  00145	75 1c		 jne	 SHORT $LN8@print_numb
$LN10@print_numb:
  00147	83 ec 08	 sub	 esp, 8
  0014a	dd 45 f4	 fld	 QWORD PTR _d$[ebp]
  0014d	dd 1c 24	 fstp	 QWORD PTR [esp]
  00150	68 00 00 00 00	 push	 OFFSET $SG5080
  00155	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  00158	50		 push	 eax
  00159	e8 00 00 00 00	 call	 __hx_sprintf
  0015e	83 c4 10	 add	 esp, 16			; 00000010H
  00161	eb 1a		 jmp	 SHORT $LN9@print_numb
$LN8@print_numb:

; 132  : 			else												sprintf(str, "%f", d);

  00163	83 ec 08	 sub	 esp, 8
  00166	dd 45 f4	 fld	 QWORD PTR _d$[ebp]
  00169	dd 1c 24	 fstp	 QWORD PTR [esp]
  0016c	68 00 00 00 00	 push	 OFFSET $SG5081
  00171	8b 4d fc	 mov	 ecx, DWORD PTR _str$[ebp]
  00174	51		 push	 ecx
  00175	e8 00 00 00 00	 call	 __hx_sprintf
  0017a	83 c4 10	 add	 esp, 16			; 00000010H
$LN9@print_numb:

; 133  : 		}
; 134  : 	}
; 135  : 	return str;

  0017d	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]

; 136  : }

  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c3		 ret	 0
_print_number ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _parse_number
_TEXT	SEGMENT
tv244 = -76						; size = 8
tv224 = -68						; size = 8
tv203 = -60						; size = 8
tv187 = -52						; size = 8
_sign$ = -44						; size = 8
_scale$ = -36						; size = 8
_n$ = -28						; size = 8
tv223 = -20						; size = 4
tv202 = -16						; size = 4
tv186 = -12						; size = 4
_signsubscale$ = -8					; size = 4
_subscale$ = -4						; size = 4
_item$ = 8						; size = 4
_num$ = 12						; size = 4
_parse_number PROC					; COMDAT

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH

; 95   : 	double n = 0, sign = 1, scale = 0; int subscale = 0, signsubscale = 1;

  00006	d9 ee		 fldz
  00008	dd 5d e4	 fstp	 QWORD PTR _n$[ebp]
  0000b	d9 e8		 fld1
  0000d	dd 5d d4	 fstp	 QWORD PTR _sign$[ebp]
  00010	d9 ee		 fldz
  00012	dd 5d dc	 fstp	 QWORD PTR _scale$[ebp]
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _subscale$[ebp], 0
  0001c	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _signsubscale$[ebp], 1

; 96   : 
; 97   : 	if (*num == '-') sign = -1, num++;	/* Has sign? */

  00023	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00026	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00029	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  0002c	75 12		 jne	 SHORT $LN10@parse_numb
  0002e	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@bff0000000000000
  00034	dd 5d d4	 fstp	 QWORD PTR _sign$[ebp]
  00037	8b 55 0c	 mov	 edx, DWORD PTR _num$[ebp]
  0003a	83 c2 01	 add	 edx, 1
  0003d	89 55 0c	 mov	 DWORD PTR _num$[ebp], edx
$LN10@parse_numb:

; 98   : 	if (*num == '0') num++;			/* is zero */

  00040	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00043	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00046	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00049	75 09		 jne	 SHORT $LN11@parse_numb
  0004b	8b 55 0c	 mov	 edx, DWORD PTR _num$[ebp]
  0004e	83 c2 01	 add	 edx, 1
  00051	89 55 0c	 mov	 DWORD PTR _num$[ebp], edx
$LN11@parse_numb:

; 99   : 	if (*num >= '1' && *num <= '9')	do	n = (n*10.0) + (*num++ - '0');	while (*num >= '0' && *num <= '9');	/* Number? */

  00054	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00057	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0005a	83 f9 31	 cmp	 ecx, 49			; 00000031H
  0005d	7c 4b		 jl	 SHORT $LN13@parse_numb
  0005f	8b 55 0c	 mov	 edx, DWORD PTR _num$[ebp]
  00062	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00065	83 f8 39	 cmp	 eax, 57			; 00000039H
  00068	7f 40		 jg	 SHORT $LN13@parse_numb
$LN4@parse_numb:
  0006a	dd 45 e4	 fld	 QWORD PTR _n$[ebp]
  0006d	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4024000000000000
  00073	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  00076	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00079	83 ea 30	 sub	 edx, 48			; 00000030H
  0007c	89 55 f4	 mov	 DWORD PTR tv186[ebp], edx
  0007f	db 45 f4	 fild	 DWORD PTR tv186[ebp]
  00082	dd 5d cc	 fstp	 QWORD PTR tv187[ebp]
  00085	dc 45 cc	 fadd	 QWORD PTR tv187[ebp]
  00088	dd 5d e4	 fstp	 QWORD PTR _n$[ebp]
  0008b	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  0008e	83 c0 01	 add	 eax, 1
  00091	89 45 0c	 mov	 DWORD PTR _num$[ebp], eax
  00094	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  00097	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0009a	83 fa 30	 cmp	 edx, 48			; 00000030H
  0009d	7c 0b		 jl	 SHORT $LN13@parse_numb
  0009f	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  000a2	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000a5	83 f9 39	 cmp	 ecx, 57			; 00000039H
  000a8	7e c0		 jle	 SHORT $LN4@parse_numb
$LN13@parse_numb:

; 100  : 	if (*num == '.' && num[1] >= '0' && num[1] <= '9') { num++;		do	n = (n*10.0) + (*num++ - '0'), scale--; while (*num >= '0' && *num <= '9'); }	/* Fractional part? */

  000aa	8b 55 0c	 mov	 edx, DWORD PTR _num$[ebp]
  000ad	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000b0	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  000b3	75 7d		 jne	 SHORT $LN15@parse_numb
  000b5	b9 01 00 00 00	 mov	 ecx, 1
  000ba	c1 e1 00	 shl	 ecx, 0
  000bd	8b 55 0c	 mov	 edx, DWORD PTR _num$[ebp]
  000c0	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  000c4	83 f8 30	 cmp	 eax, 48			; 00000030H
  000c7	7c 69		 jl	 SHORT $LN15@parse_numb
  000c9	b9 01 00 00 00	 mov	 ecx, 1
  000ce	c1 e1 00	 shl	 ecx, 0
  000d1	8b 55 0c	 mov	 edx, DWORD PTR _num$[ebp]
  000d4	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  000d8	83 f8 39	 cmp	 eax, 57			; 00000039H
  000db	7f 55		 jg	 SHORT $LN15@parse_numb
  000dd	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  000e0	83 c1 01	 add	 ecx, 1
  000e3	89 4d 0c	 mov	 DWORD PTR _num$[ebp], ecx
$LN7@parse_numb:
  000e6	dd 45 e4	 fld	 QWORD PTR _n$[ebp]
  000e9	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4024000000000000
  000ef	8b 55 0c	 mov	 edx, DWORD PTR _num$[ebp]
  000f2	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000f5	83 e8 30	 sub	 eax, 48			; 00000030H
  000f8	89 45 f0	 mov	 DWORD PTR tv202[ebp], eax
  000fb	db 45 f0	 fild	 DWORD PTR tv202[ebp]
  000fe	dd 5d c4	 fstp	 QWORD PTR tv203[ebp]
  00101	dc 45 c4	 fadd	 QWORD PTR tv203[ebp]
  00104	dd 5d e4	 fstp	 QWORD PTR _n$[ebp]
  00107	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  0010a	83 c1 01	 add	 ecx, 1
  0010d	89 4d 0c	 mov	 DWORD PTR _num$[ebp], ecx
  00110	dd 45 dc	 fld	 QWORD PTR _scale$[ebp]
  00113	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3ff0000000000000
  00119	dd 5d dc	 fstp	 QWORD PTR _scale$[ebp]
  0011c	8b 55 0c	 mov	 edx, DWORD PTR _num$[ebp]
  0011f	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00122	83 f8 30	 cmp	 eax, 48			; 00000030H
  00125	7c 0b		 jl	 SHORT $LN15@parse_numb
  00127	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  0012a	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0012d	83 fa 39	 cmp	 edx, 57			; 00000039H
  00130	7e b4		 jle	 SHORT $LN7@parse_numb
$LN15@parse_numb:

; 101  : 	if (*num == 'e' || *num == 'E')		/* Exponent? */

  00132	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]
  00135	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00138	83 f9 65	 cmp	 ecx, 101		; 00000065H
  0013b	74 0b		 je	 SHORT $LN17@parse_numb
  0013d	8b 55 0c	 mov	 edx, DWORD PTR _num$[ebp]
  00140	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00143	83 f8 45	 cmp	 eax, 69			; 00000045H
  00146	75 6c		 jne	 SHORT $LN9@parse_numb
$LN17@parse_numb:

; 102  : 	{
; 103  : 		num++; if (*num == '+') num++;	else if (*num == '-') signsubscale = -1, num++;		/* With sign? */

  00148	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  0014b	83 c1 01	 add	 ecx, 1
  0014e	89 4d 0c	 mov	 DWORD PTR _num$[ebp], ecx
  00151	8b 55 0c	 mov	 edx, DWORD PTR _num$[ebp]
  00154	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00157	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  0015a	75 0b		 jne	 SHORT $LN18@parse_numb
  0015c	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  0015f	83 c1 01	 add	 ecx, 1
  00162	89 4d 0c	 mov	 DWORD PTR _num$[ebp], ecx
  00165	eb 1b		 jmp	 SHORT $LN20@parse_numb
$LN18@parse_numb:
  00167	8b 55 0c	 mov	 edx, DWORD PTR _num$[ebp]
  0016a	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0016d	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00170	75 10		 jne	 SHORT $LN20@parse_numb
  00172	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _signsubscale$[ebp], -1
  00179	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  0017c	83 c1 01	 add	 ecx, 1
  0017f	89 4d 0c	 mov	 DWORD PTR _num$[ebp], ecx
$LN20@parse_numb:

; 104  : 		while (*num >= '0' && *num <= '9') subscale = (subscale * 10) + (*num++ - '0');	/* Number? */

  00182	8b 55 0c	 mov	 edx, DWORD PTR _num$[ebp]
  00185	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00188	83 f8 30	 cmp	 eax, 48			; 00000030H
  0018b	7c 27		 jl	 SHORT $LN9@parse_numb
  0018d	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  00190	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00193	83 fa 39	 cmp	 edx, 57			; 00000039H
  00196	7f 1c		 jg	 SHORT $LN9@parse_numb
  00198	6b 45 fc 0a	 imul	 eax, DWORD PTR _subscale$[ebp], 10
  0019c	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  0019f	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  001a2	8d 44 10 d0	 lea	 eax, DWORD PTR [eax+edx-48]
  001a6	89 45 fc	 mov	 DWORD PTR _subscale$[ebp], eax
  001a9	8b 4d 0c	 mov	 ecx, DWORD PTR _num$[ebp]
  001ac	83 c1 01	 add	 ecx, 1
  001af	89 4d 0c	 mov	 DWORD PTR _num$[ebp], ecx
  001b2	eb ce		 jmp	 SHORT $LN20@parse_numb
$LN9@parse_numb:

; 105  : 	}
; 106  : 
; 107  : 	n = sign * n*pow(10.0, (scale + subscale * signsubscale));	/* number = +/- number.fraction * 10^+/- exponent */

  001b4	dd 45 d4	 fld	 QWORD PTR _sign$[ebp]
  001b7	dc 4d e4	 fmul	 QWORD PTR _n$[ebp]
  001ba	8b 55 fc	 mov	 edx, DWORD PTR _subscale$[ebp]
  001bd	0f af 55 f8	 imul	 edx, DWORD PTR _signsubscale$[ebp]
  001c1	89 55 ec	 mov	 DWORD PTR tv223[ebp], edx
  001c4	db 45 ec	 fild	 DWORD PTR tv223[ebp]
  001c7	dd 5d bc	 fstp	 QWORD PTR tv224[ebp]
  001ca	dd 45 bc	 fld	 QWORD PTR tv224[ebp]
  001cd	dc 45 dc	 fadd	 QWORD PTR _scale$[ebp]
  001d0	83 ec 08	 sub	 esp, 8
  001d3	dd 1c 24	 fstp	 QWORD PTR [esp]
  001d6	83 ec 08	 sub	 esp, 8
  001d9	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4024000000000000
  001df	dd 1c 24	 fstp	 QWORD PTR [esp]
  001e2	dd 5d b4	 fstp	 QWORD PTR tv244[ebp]
  001e5	e8 00 00 00 00	 call	 _pow
  001ea	83 c4 10	 add	 esp, 16			; 00000010H
  001ed	dc 4d b4	 fmul	 QWORD PTR tv244[ebp]
  001f0	dd 5d e4	 fstp	 QWORD PTR _n$[ebp]

; 108  : 
; 109  : 	item->valuedouble = n;

  001f3	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  001f6	dd 45 e4	 fld	 QWORD PTR _n$[ebp]
  001f9	dd 58 18	 fstp	 QWORD PTR [eax+24]

; 110  : 	item->valueint = (int)n;

  001fc	dd 45 e4	 fld	 QWORD PTR _n$[ebp]
  001ff	e8 00 00 00 00	 call	 __ftol2_sse
  00204	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00207	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 111  : 	item->type = cJSON_Number;

  0020a	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  0020d	c7 42 0c 03 00
	00 00		 mov	 DWORD PTR [edx+12], 3

; 112  : 	return num;

  00214	8b 45 0c	 mov	 eax, DWORD PTR _num$[ebp]

; 113  : }

  00217	8b e5		 mov	 esp, ebp
  00219	5d		 pop	 ebp
  0021a	c3		 ret	 0
_parse_number ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_New_Item
_TEXT	SEGMENT
_node$ = -4						; size = 4
_cJSON_New_Item PROC					; COMDAT

; 71   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 72   : 	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));

  00004	6a 28		 push	 40			; 00000028H
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_malloc
  0000c	83 c4 04	 add	 esp, 4
  0000f	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax

; 73   : 	if (node) memset(node, 0, sizeof(cJSON));

  00012	83 7d fc 00	 cmp	 DWORD PTR _node$[ebp], 0
  00016	74 10		 je	 SHORT $LN2@cJSON_New_
  00018	6a 28		 push	 40			; 00000028H
  0001a	6a 00		 push	 0
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _memset
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@cJSON_New_:

; 74   : 	return node;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]

; 75   : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
_cJSON_New_Item ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_strdup
_TEXT	SEGMENT
_len$ = -8						; size = 4
_copy$ = -4						; size = 4
_str$ = 8						; size = 4
_cJSON_strdup PROC					; COMDAT

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 48   : 	size_t len;
; 49   : 	char* copy;
; 50   : 
; 51   : 	len = strlen(str) + 1;

  00006	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _strlen
  0000f	83 c4 04	 add	 esp, 4
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 52   : 	if (!(copy = (char*)cJSON_malloc(len))) return 0;

  00018	8b 4d f8	 mov	 ecx, DWORD PTR _len$[ebp]
  0001b	51		 push	 ecx
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_malloc
  00022	83 c4 04	 add	 esp, 4
  00025	89 45 fc	 mov	 DWORD PTR _copy$[ebp], eax
  00028	83 7d fc 00	 cmp	 DWORD PTR _copy$[ebp], 0
  0002c	75 04		 jne	 SHORT $LN2@cJSON_strd
  0002e	33 c0		 xor	 eax, eax
  00030	eb 17		 jmp	 SHORT $LN1@cJSON_strd
$LN2@cJSON_strd:

; 53   : 	memcpy(copy, str, len);

  00032	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  00035	52		 push	 edx
  00036	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _copy$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 _memcpy
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH

; 54   : 	return copy;

  00046	8b 45 fc	 mov	 eax, DWORD PTR _copy$[ebp]
$LN1@cJSON_strd:

; 55   : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_cJSON_strdup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_strcasecmp
_TEXT	SEGMENT
tv140 = -20						; size = 4
tv131 = -16						; size = 4
tv87 = -12						; size = 4
tv78 = -8						; size = 4
tv66 = -4						; size = 4
_s1$ = 8						; size = 4
_s2$ = 12						; size = 4
_cJSON_strcasecmp PROC					; COMDAT

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 38   : 	if (!s1) return (s1 == s2) ? 0 : 1; if (!s2) return 1;

  00006	83 7d 08 00	 cmp	 DWORD PTR _s1$[ebp], 0
  0000a	75 20		 jne	 SHORT $LN5@cJSON_strc
  0000c	8b 45 08	 mov	 eax, DWORD PTR _s1$[ebp]
  0000f	3b 45 0c	 cmp	 eax, DWORD PTR _s2$[ebp]
  00012	75 09		 jne	 SHORT $LN9@cJSON_strc
  00014	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
  0001b	eb 07		 jmp	 SHORT $LN10@cJSON_strc
$LN9@cJSON_strc:
  0001d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
$LN10@cJSON_strc:
  00024	8b 45 fc	 mov	 eax, DWORD PTR tv66[ebp]
  00027	e9 f9 00 00 00	 jmp	 $LN1@cJSON_strc
$LN5@cJSON_strc:
  0002c	83 7d 0c 00	 cmp	 DWORD PTR _s2$[ebp], 0
  00030	75 0a		 jne	 SHORT $LN6@cJSON_strc
  00032	b8 01 00 00 00	 mov	 eax, 1
  00037	e9 e9 00 00 00	 jmp	 $LN1@cJSON_strc
$LN6@cJSON_strc:

; 39   : 	for (; tolower(*s1) == tolower(*s2); ++s1, ++s2)	if (*s1 == 0)	return 0;

  0003c	eb 12		 jmp	 SHORT $LN4@cJSON_strc
$LN2@cJSON_strc:
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _s1$[ebp]
  00041	83 c1 01	 add	 ecx, 1
  00044	89 4d 08	 mov	 DWORD PTR _s1$[ebp], ecx
  00047	8b 55 0c	 mov	 edx, DWORD PTR _s2$[ebp]
  0004a	83 c2 01	 add	 edx, 1
  0004d	89 55 0c	 mov	 DWORD PTR _s2$[ebp], edx
$LN4@cJSON_strc:
  00050	8b 45 08	 mov	 eax, DWORD PTR _s1$[ebp]
  00053	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00056	83 f9 41	 cmp	 ecx, 65			; 00000041H
  00059	7c 19		 jl	 SHORT $LN11@cJSON_strc
  0005b	8b 55 08	 mov	 edx, DWORD PTR _s1$[ebp]
  0005e	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00061	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  00064	7f 0e		 jg	 SHORT $LN11@cJSON_strc
  00066	8b 4d 08	 mov	 ecx, DWORD PTR _s1$[ebp]
  00069	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0006c	83 c2 20	 add	 edx, 32			; 00000020H
  0006f	89 55 f8	 mov	 DWORD PTR tv78[ebp], edx
  00072	eb 09		 jmp	 SHORT $LN12@cJSON_strc
$LN11@cJSON_strc:
  00074	8b 45 08	 mov	 eax, DWORD PTR _s1$[ebp]
  00077	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0007a	89 4d f8	 mov	 DWORD PTR tv78[ebp], ecx
$LN12@cJSON_strc:
  0007d	8b 55 0c	 mov	 edx, DWORD PTR _s2$[ebp]
  00080	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00083	83 f8 41	 cmp	 eax, 65			; 00000041H
  00086	7c 19		 jl	 SHORT $LN13@cJSON_strc
  00088	8b 4d 0c	 mov	 ecx, DWORD PTR _s2$[ebp]
  0008b	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0008e	83 fa 5a	 cmp	 edx, 90			; 0000005aH
  00091	7f 0e		 jg	 SHORT $LN13@cJSON_strc
  00093	8b 45 0c	 mov	 eax, DWORD PTR _s2$[ebp]
  00096	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00099	83 c1 20	 add	 ecx, 32			; 00000020H
  0009c	89 4d f4	 mov	 DWORD PTR tv87[ebp], ecx
  0009f	eb 09		 jmp	 SHORT $LN14@cJSON_strc
$LN13@cJSON_strc:
  000a1	8b 55 0c	 mov	 edx, DWORD PTR _s2$[ebp]
  000a4	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000a7	89 45 f4	 mov	 DWORD PTR tv87[ebp], eax
$LN14@cJSON_strc:
  000aa	8b 4d f8	 mov	 ecx, DWORD PTR tv78[ebp]
  000ad	3b 4d f4	 cmp	 ecx, DWORD PTR tv87[ebp]
  000b0	75 13		 jne	 SHORT $LN3@cJSON_strc
  000b2	8b 55 08	 mov	 edx, DWORD PTR _s1$[ebp]
  000b5	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000b8	85 c0		 test	 eax, eax
  000ba	75 04		 jne	 SHORT $LN7@cJSON_strc
  000bc	33 c0		 xor	 eax, eax
  000be	eb 65		 jmp	 SHORT $LN1@cJSON_strc
$LN7@cJSON_strc:
  000c0	e9 79 ff ff ff	 jmp	 $LN2@cJSON_strc
$LN3@cJSON_strc:

; 40   : 	return tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);

  000c5	8b 4d 08	 mov	 ecx, DWORD PTR _s1$[ebp]
  000c8	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  000cb	83 fa 41	 cmp	 edx, 65			; 00000041H
  000ce	7c 19		 jl	 SHORT $LN15@cJSON_strc
  000d0	8b 45 08	 mov	 eax, DWORD PTR _s1$[ebp]
  000d3	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000d6	83 f9 5a	 cmp	 ecx, 90			; 0000005aH
  000d9	7f 0e		 jg	 SHORT $LN15@cJSON_strc
  000db	8b 55 08	 mov	 edx, DWORD PTR _s1$[ebp]
  000de	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000e1	83 c0 20	 add	 eax, 32			; 00000020H
  000e4	89 45 f0	 mov	 DWORD PTR tv131[ebp], eax
  000e7	eb 09		 jmp	 SHORT $LN16@cJSON_strc
$LN15@cJSON_strc:
  000e9	8b 4d 08	 mov	 ecx, DWORD PTR _s1$[ebp]
  000ec	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  000ef	89 55 f0	 mov	 DWORD PTR tv131[ebp], edx
$LN16@cJSON_strc:
  000f2	8b 45 0c	 mov	 eax, DWORD PTR _s2$[ebp]
  000f5	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000f8	83 f9 41	 cmp	 ecx, 65			; 00000041H
  000fb	7c 19		 jl	 SHORT $LN17@cJSON_strc
  000fd	8b 55 0c	 mov	 edx, DWORD PTR _s2$[ebp]
  00100	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00103	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  00106	7f 0e		 jg	 SHORT $LN17@cJSON_strc
  00108	8b 4d 0c	 mov	 ecx, DWORD PTR _s2$[ebp]
  0010b	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0010e	83 c2 20	 add	 edx, 32			; 00000020H
  00111	89 55 ec	 mov	 DWORD PTR tv140[ebp], edx
  00114	eb 09		 jmp	 SHORT $LN18@cJSON_strc
$LN17@cJSON_strc:
  00116	8b 45 0c	 mov	 eax, DWORD PTR _s2$[ebp]
  00119	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0011c	89 4d ec	 mov	 DWORD PTR tv140[ebp], ecx
$LN18@cJSON_strc:
  0011f	8b 45 f0	 mov	 eax, DWORD PTR tv131[ebp]
  00122	2b 45 ec	 sub	 eax, DWORD PTR tv140[ebp]
$LN1@cJSON_strc:

; 41   : }

  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c3		 ret	 0
_cJSON_strcasecmp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_Minify
_TEXT	SEGMENT
_into$ = -4						; size = 4
_json$ = 8						; size = 4
_cJSON_Minify PROC					; COMDAT

; 584  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 585  : 	char *into = json;

  00004	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _into$[ebp], eax
$LN2@cJSON_Mini:

; 586  : 	while (*json)

  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _json$[ebp]
  0000d	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00010	85 d2		 test	 edx, edx
  00012	0f 84 cd 01 00
	00		 je	 $LN3@cJSON_Mini

; 587  : 	{
; 588  : 		if (*json == ' ') json++;

  00018	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  0001b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0001e	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00021	75 0e		 jne	 SHORT $LN10@cJSON_Mini
  00023	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  00026	83 c2 01	 add	 edx, 1
  00029	89 55 08	 mov	 DWORD PTR _json$[ebp], edx
  0002c	e9 af 01 00 00	 jmp	 $LN11@cJSON_Mini
$LN10@cJSON_Mini:

; 589  : 		else if (*json == '\t') json++;	/* Whitespace characters.*/

  00031	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  00034	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00037	83 f9 09	 cmp	 ecx, 9
  0003a	75 0e		 jne	 SHORT $LN12@cJSON_Mini
  0003c	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  0003f	83 c2 01	 add	 edx, 1
  00042	89 55 08	 mov	 DWORD PTR _json$[ebp], edx
  00045	e9 96 01 00 00	 jmp	 $LN11@cJSON_Mini
$LN12@cJSON_Mini:

; 590  : 		else if (*json == '\r') json++;

  0004a	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  0004d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00050	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  00053	75 0e		 jne	 SHORT $LN14@cJSON_Mini
  00055	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  00058	83 c2 01	 add	 edx, 1
  0005b	89 55 08	 mov	 DWORD PTR _json$[ebp], edx
  0005e	e9 7d 01 00 00	 jmp	 $LN11@cJSON_Mini
$LN14@cJSON_Mini:

; 591  : 		else if (*json == '\n') json++;

  00063	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  00066	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00069	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0006c	75 0e		 jne	 SHORT $LN16@cJSON_Mini
  0006e	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  00071	83 c2 01	 add	 edx, 1
  00074	89 55 08	 mov	 DWORD PTR _json$[ebp], edx
  00077	e9 64 01 00 00	 jmp	 $LN11@cJSON_Mini
$LN16@cJSON_Mini:

; 592  : 		else if (*json == '/' && json[1] == '/')  while (*json && *json != '\n') json++;	/* double-slash comments, to end of line.*/

  0007c	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  0007f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00082	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00085	75 39		 jne	 SHORT $LN18@cJSON_Mini
  00087	ba 01 00 00 00	 mov	 edx, 1
  0008c	c1 e2 00	 shl	 edx, 0
  0008f	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  00092	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  00096	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00099	75 25		 jne	 SHORT $LN18@cJSON_Mini
$LN4@cJSON_Mini:
  0009b	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  0009e	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000a1	85 c0		 test	 eax, eax
  000a3	74 16		 je	 SHORT $LN5@cJSON_Mini
  000a5	8b 4d 08	 mov	 ecx, DWORD PTR _json$[ebp]
  000a8	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000ab	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  000ae	74 0b		 je	 SHORT $LN5@cJSON_Mini
  000b0	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  000b3	83 c0 01	 add	 eax, 1
  000b6	89 45 08	 mov	 DWORD PTR _json$[ebp], eax
  000b9	eb e0		 jmp	 SHORT $LN4@cJSON_Mini
$LN5@cJSON_Mini:
  000bb	e9 20 01 00 00	 jmp	 $LN11@cJSON_Mini
$LN18@cJSON_Mini:

; 593  : 		else if (*json == '/' && json[1] == '*') { while (*json && !(*json == '*' && json[1] == '/')) json++; json += 2; }	/* multiline comments.*/

  000c0	8b 4d 08	 mov	 ecx, DWORD PTR _json$[ebp]
  000c3	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000c6	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  000c9	75 56		 jne	 SHORT $LN20@cJSON_Mini
  000cb	b8 01 00 00 00	 mov	 eax, 1
  000d0	c1 e0 00	 shl	 eax, 0
  000d3	8b 4d 08	 mov	 ecx, DWORD PTR _json$[ebp]
  000d6	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  000da	83 fa 2a	 cmp	 edx, 42			; 0000002aH
  000dd	75 42		 jne	 SHORT $LN20@cJSON_Mini
$LN6@cJSON_Mini:
  000df	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  000e2	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000e5	85 c9		 test	 ecx, ecx
  000e7	74 2a		 je	 SHORT $LN7@cJSON_Mini
  000e9	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  000ec	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000ef	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  000f2	75 14		 jne	 SHORT $LN22@cJSON_Mini
  000f4	b9 01 00 00 00	 mov	 ecx, 1
  000f9	c1 e1 00	 shl	 ecx, 0
  000fc	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  000ff	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00103	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00106	74 0b		 je	 SHORT $LN7@cJSON_Mini
$LN22@cJSON_Mini:
  00108	8b 4d 08	 mov	 ecx, DWORD PTR _json$[ebp]
  0010b	83 c1 01	 add	 ecx, 1
  0010e	89 4d 08	 mov	 DWORD PTR _json$[ebp], ecx
  00111	eb cc		 jmp	 SHORT $LN6@cJSON_Mini
$LN7@cJSON_Mini:
  00113	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  00116	83 c2 02	 add	 edx, 2
  00119	89 55 08	 mov	 DWORD PTR _json$[ebp], edx
  0011c	e9 bf 00 00 00	 jmp	 $LN11@cJSON_Mini
$LN20@cJSON_Mini:

; 594  : 		else if (*json == '\"') { *into++ = *json++; while (*json && *json != '\"') { if (*json == '\\') *into++ = *json++; *into++ = *json++; }*into++ = *json++; } /* string literals, which are \" sensitive.*/

  00121	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  00124	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00127	83 f9 22	 cmp	 ecx, 34			; 00000022H
  0012a	0f 85 94 00 00
	00		 jne	 $LN23@cJSON_Mini
  00130	8b 55 fc	 mov	 edx, DWORD PTR _into$[ebp]
  00133	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  00136	8a 08		 mov	 cl, BYTE PTR [eax]
  00138	88 0a		 mov	 BYTE PTR [edx], cl
  0013a	8b 55 fc	 mov	 edx, DWORD PTR _into$[ebp]
  0013d	83 c2 01	 add	 edx, 1
  00140	89 55 fc	 mov	 DWORD PTR _into$[ebp], edx
  00143	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  00146	83 c0 01	 add	 eax, 1
  00149	89 45 08	 mov	 DWORD PTR _json$[ebp], eax
$LN8@cJSON_Mini:
  0014c	8b 4d 08	 mov	 ecx, DWORD PTR _json$[ebp]
  0014f	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00152	85 d2		 test	 edx, edx
  00154	74 50		 je	 SHORT $LN9@cJSON_Mini
  00156	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  00159	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0015c	83 f9 22	 cmp	 ecx, 34			; 00000022H
  0015f	74 45		 je	 SHORT $LN9@cJSON_Mini
  00161	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  00164	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00167	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  0016a	75 1c		 jne	 SHORT $LN25@cJSON_Mini
  0016c	8b 4d fc	 mov	 ecx, DWORD PTR _into$[ebp]
  0016f	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  00172	8a 02		 mov	 al, BYTE PTR [edx]
  00174	88 01		 mov	 BYTE PTR [ecx], al
  00176	8b 4d fc	 mov	 ecx, DWORD PTR _into$[ebp]
  00179	83 c1 01	 add	 ecx, 1
  0017c	89 4d fc	 mov	 DWORD PTR _into$[ebp], ecx
  0017f	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  00182	83 c2 01	 add	 edx, 1
  00185	89 55 08	 mov	 DWORD PTR _json$[ebp], edx
$LN25@cJSON_Mini:
  00188	8b 45 fc	 mov	 eax, DWORD PTR _into$[ebp]
  0018b	8b 4d 08	 mov	 ecx, DWORD PTR _json$[ebp]
  0018e	8a 11		 mov	 dl, BYTE PTR [ecx]
  00190	88 10		 mov	 BYTE PTR [eax], dl
  00192	8b 45 fc	 mov	 eax, DWORD PTR _into$[ebp]
  00195	83 c0 01	 add	 eax, 1
  00198	89 45 fc	 mov	 DWORD PTR _into$[ebp], eax
  0019b	8b 4d 08	 mov	 ecx, DWORD PTR _json$[ebp]
  0019e	83 c1 01	 add	 ecx, 1
  001a1	89 4d 08	 mov	 DWORD PTR _json$[ebp], ecx
  001a4	eb a6		 jmp	 SHORT $LN8@cJSON_Mini
$LN9@cJSON_Mini:
  001a6	8b 55 fc	 mov	 edx, DWORD PTR _into$[ebp]
  001a9	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  001ac	8a 08		 mov	 cl, BYTE PTR [eax]
  001ae	88 0a		 mov	 BYTE PTR [edx], cl
  001b0	8b 55 fc	 mov	 edx, DWORD PTR _into$[ebp]
  001b3	83 c2 01	 add	 edx, 1
  001b6	89 55 fc	 mov	 DWORD PTR _into$[ebp], edx
  001b9	8b 45 08	 mov	 eax, DWORD PTR _json$[ebp]
  001bc	83 c0 01	 add	 eax, 1
  001bf	89 45 08	 mov	 DWORD PTR _json$[ebp], eax
  001c2	eb 1c		 jmp	 SHORT $LN11@cJSON_Mini
$LN23@cJSON_Mini:

; 595  : 		else *into++ = *json++;			/* All other characters.*/

  001c4	8b 4d fc	 mov	 ecx, DWORD PTR _into$[ebp]
  001c7	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  001ca	8a 02		 mov	 al, BYTE PTR [edx]
  001cc	88 01		 mov	 BYTE PTR [ecx], al
  001ce	8b 4d fc	 mov	 ecx, DWORD PTR _into$[ebp]
  001d1	83 c1 01	 add	 ecx, 1
  001d4	89 4d fc	 mov	 DWORD PTR _into$[ebp], ecx
  001d7	8b 55 08	 mov	 edx, DWORD PTR _json$[ebp]
  001da	83 c2 01	 add	 edx, 1
  001dd	89 55 08	 mov	 DWORD PTR _json$[ebp], edx
$LN11@cJSON_Mini:

; 596  : 	}

  001e0	e9 25 fe ff ff	 jmp	 $LN2@cJSON_Mini
$LN3@cJSON_Mini:

; 597  : 	*into = 0;	/* and null-terminate.*/

  001e5	8b 45 fc	 mov	 eax, DWORD PTR _into$[ebp]
  001e8	c6 00 00	 mov	 BYTE PTR [eax], 0

; 598  : }

  001eb	8b e5		 mov	 esp, ebp
  001ed	5d		 pop	 ebp
  001ee	c3		 ret	 0
_cJSON_Minify ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_ParseWithOpts
_TEXT	SEGMENT
_c$ = -8						; size = 4
_end$ = -4						; size = 4
_value$ = 8						; size = 4
_return_parse_end$ = 12					; size = 4
_require_null_terminated$ = 16				; size = 4
_cJSON_ParseWithOpts PROC				; COMDAT

; 263  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 264  : 	const char *end = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _end$[ebp], 0

; 265  : 	cJSON *c = cJSON_New_Item();

  0000d	e8 00 00 00 00	 call	 _cJSON_New_Item
  00012	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 266  : 	ep = 0;

  00015	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _ep, 0

; 267  : 	if (!c) return 0;       /* memory fail */

  0001f	83 7d f8 00	 cmp	 DWORD PTR _c$[ebp], 0
  00023	75 04		 jne	 SHORT $LN2@cJSON_Pars
  00025	33 c0		 xor	 eax, eax
  00027	eb 7b		 jmp	 SHORT $LN1@cJSON_Pars
$LN2@cJSON_Pars:

; 268  : 
; 269  : 	end = parse_value(c, skip(value));

  00029	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 _skip
  00032	83 c4 04	 add	 esp, 4
  00035	50		 push	 eax
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _c$[ebp]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 _parse_value
  0003f	83 c4 08	 add	 esp, 8
  00042	89 45 fc	 mov	 DWORD PTR _end$[ebp], eax

; 270  : 	if (!end) { cJSON_Delete(c); return 0; }	/* parse failure. ep is set. */

  00045	83 7d fc 00	 cmp	 DWORD PTR _end$[ebp], 0
  00049	75 10		 jne	 SHORT $LN3@cJSON_Pars
  0004b	8b 55 f8	 mov	 edx, DWORD PTR _c$[ebp]
  0004e	52		 push	 edx
  0004f	e8 00 00 00 00	 call	 _cJSON_Delete
  00054	83 c4 04	 add	 esp, 4
  00057	33 c0		 xor	 eax, eax
  00059	eb 49		 jmp	 SHORT $LN1@cJSON_Pars
$LN3@cJSON_Pars:

; 271  : 
; 272  : 												/* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
; 273  : 	if (require_null_terminated) { end = skip(end); if (*end) { cJSON_Delete(c); ep = end; return 0; } }

  0005b	83 7d 10 00	 cmp	 DWORD PTR _require_null_terminated$[ebp], 0
  0005f	74 32		 je	 SHORT $LN4@cJSON_Pars
  00061	8b 45 fc	 mov	 eax, DWORD PTR _end$[ebp]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 _skip
  0006a	83 c4 04	 add	 esp, 4
  0006d	89 45 fc	 mov	 DWORD PTR _end$[ebp], eax
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _end$[ebp]
  00073	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00076	85 d2		 test	 edx, edx
  00078	74 19		 je	 SHORT $LN4@cJSON_Pars
  0007a	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _cJSON_Delete
  00083	83 c4 04	 add	 esp, 4
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _end$[ebp]
  00089	89 0d 00 00 00
	00		 mov	 DWORD PTR _ep, ecx
  0008f	33 c0		 xor	 eax, eax
  00091	eb 11		 jmp	 SHORT $LN1@cJSON_Pars
$LN4@cJSON_Pars:

; 274  : 	if (return_parse_end) *return_parse_end = end;

  00093	83 7d 0c 00	 cmp	 DWORD PTR _return_parse_end$[ebp], 0
  00097	74 08		 je	 SHORT $LN6@cJSON_Pars
  00099	8b 55 0c	 mov	 edx, DWORD PTR _return_parse_end$[ebp]
  0009c	8b 45 fc	 mov	 eax, DWORD PTR _end$[ebp]
  0009f	89 02		 mov	 DWORD PTR [edx], eax
$LN6@cJSON_Pars:

; 275  : 	return c;

  000a1	8b 45 f8	 mov	 eax, DWORD PTR _c$[ebp]
$LN1@cJSON_Pars:

; 276  : }

  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
_cJSON_ParseWithOpts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_Duplicate
_TEXT	SEGMENT
_cptr$ = -16						; size = 4
_nptr$ = -12						; size = 4
_newchild$ = -8						; size = 4
_newitem$ = -4						; size = 4
_item$ = 8						; size = 4
_recurse$ = 12						; size = 4
_cJSON_Duplicate PROC					; COMDAT

; 557  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 558  : 	cJSON *newitem, *cptr, *nptr = 0, *newchild;

  00006	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _nptr$[ebp], 0

; 559  : 	/* Bail on bad ptr */
; 560  : 	if (!item) return 0;

  0000d	83 7d 08 00	 cmp	 DWORD PTR _item$[ebp], 0
  00011	75 07		 jne	 SHORT $LN4@cJSON_Dupl
  00013	33 c0		 xor	 eax, eax
  00015	e9 2c 01 00 00	 jmp	 $LN1@cJSON_Dupl
$LN4@cJSON_Dupl:

; 561  : 	/* Create new item */
; 562  : 	newitem = cJSON_New_Item();

  0001a	e8 00 00 00 00	 call	 _cJSON_New_Item
  0001f	89 45 fc	 mov	 DWORD PTR _newitem$[ebp], eax

; 563  : 	if (!newitem) return 0;

  00022	83 7d fc 00	 cmp	 DWORD PTR _newitem$[ebp], 0
  00026	75 07		 jne	 SHORT $LN5@cJSON_Dupl
  00028	33 c0		 xor	 eax, eax
  0002a	e9 17 01 00 00	 jmp	 $LN1@cJSON_Dupl
$LN5@cJSON_Dupl:

; 564  : 	/* Copy over all vars */
; 565  : 	newitem->type = item->type&(~cJSON_IsReference), newitem->valueint = item->valueint, newitem->valuedouble = item->valuedouble;

  0002f	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00032	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00035	81 e1 ff fe ff
	ff		 and	 ecx, -257		; fffffeffH
  0003b	8b 55 fc	 mov	 edx, DWORD PTR _newitem$[ebp]
  0003e	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00041	8b 45 fc	 mov	 eax, DWORD PTR _newitem$[ebp]
  00044	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00047	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0004a	89 50 14	 mov	 DWORD PTR [eax+20], edx
  0004d	8b 45 fc	 mov	 eax, DWORD PTR _newitem$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _item$[ebp]
  00053	dd 41 18	 fld	 QWORD PTR [ecx+24]
  00056	dd 58 18	 fstp	 QWORD PTR [eax+24]

; 566  : 	if (item->valuestring) { newitem->valuestring = cJSON_strdup(item->valuestring);	if (!newitem->valuestring) { cJSON_Delete(newitem); return 0; } }

  00059	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  0005c	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  00060	74 31		 je	 SHORT $LN7@cJSON_Dupl
  00062	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  00065	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 _cJSON_strdup
  0006e	83 c4 04	 add	 esp, 4
  00071	8b 55 fc	 mov	 edx, DWORD PTR _newitem$[ebp]
  00074	89 42 10	 mov	 DWORD PTR [edx+16], eax
  00077	8b 45 fc	 mov	 eax, DWORD PTR _newitem$[ebp]
  0007a	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0007e	75 13		 jne	 SHORT $LN7@cJSON_Dupl
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _newitem$[ebp]
  00083	51		 push	 ecx
  00084	e8 00 00 00 00	 call	 _cJSON_Delete
  00089	83 c4 04	 add	 esp, 4
  0008c	33 c0		 xor	 eax, eax
  0008e	e9 b3 00 00 00	 jmp	 $LN1@cJSON_Dupl
$LN7@cJSON_Dupl:

; 567  : 	if (item->string) { newitem->string = cJSON_strdup(item->string);			if (!newitem->string) { cJSON_Delete(newitem); return 0; } }

  00093	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  00096	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  0009a	74 2e		 je	 SHORT $LN9@cJSON_Dupl
  0009c	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  0009f	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 _cJSON_strdup
  000a8	83 c4 04	 add	 esp, 4
  000ab	8b 55 fc	 mov	 edx, DWORD PTR _newitem$[ebp]
  000ae	89 42 20	 mov	 DWORD PTR [edx+32], eax
  000b1	8b 45 fc	 mov	 eax, DWORD PTR _newitem$[ebp]
  000b4	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  000b8	75 10		 jne	 SHORT $LN9@cJSON_Dupl
  000ba	8b 4d fc	 mov	 ecx, DWORD PTR _newitem$[ebp]
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 _cJSON_Delete
  000c3	83 c4 04	 add	 esp, 4
  000c6	33 c0		 xor	 eax, eax
  000c8	eb 7c		 jmp	 SHORT $LN1@cJSON_Dupl
$LN9@cJSON_Dupl:

; 568  : 	/* If non-recursive, then we're done! */
; 569  : 	if (!recurse) return newitem;

  000ca	83 7d 0c 00	 cmp	 DWORD PTR _recurse$[ebp], 0
  000ce	75 05		 jne	 SHORT $LN10@cJSON_Dupl
  000d0	8b 45 fc	 mov	 eax, DWORD PTR _newitem$[ebp]
  000d3	eb 71		 jmp	 SHORT $LN1@cJSON_Dupl
$LN10@cJSON_Dupl:

; 570  : 	/* Walk the ->next chain for the child. */
; 571  : 	cptr = item->child;

  000d5	8b 55 08	 mov	 edx, DWORD PTR _item$[ebp]
  000d8	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000db	89 45 f0	 mov	 DWORD PTR _cptr$[ebp], eax
$LN2@cJSON_Dupl:

; 572  : 	while (cptr)

  000de	83 7d f0 00	 cmp	 DWORD PTR _cptr$[ebp], 0
  000e2	74 5f		 je	 SHORT $LN3@cJSON_Dupl

; 573  : 	{
; 574  : 		newchild = cJSON_Duplicate(cptr, 1);		/* Duplicate (with recurse) each item in the ->next chain */

  000e4	6a 01		 push	 1
  000e6	8b 4d f0	 mov	 ecx, DWORD PTR _cptr$[ebp]
  000e9	51		 push	 ecx
  000ea	e8 00 00 00 00	 call	 _cJSON_Duplicate
  000ef	83 c4 08	 add	 esp, 8
  000f2	89 45 f8	 mov	 DWORD PTR _newchild$[ebp], eax

; 575  : 		if (!newchild) { cJSON_Delete(newitem); return 0; }

  000f5	83 7d f8 00	 cmp	 DWORD PTR _newchild$[ebp], 0
  000f9	75 10		 jne	 SHORT $LN11@cJSON_Dupl
  000fb	8b 55 fc	 mov	 edx, DWORD PTR _newitem$[ebp]
  000fe	52		 push	 edx
  000ff	e8 00 00 00 00	 call	 _cJSON_Delete
  00104	83 c4 04	 add	 esp, 4
  00107	33 c0		 xor	 eax, eax
  00109	eb 3b		 jmp	 SHORT $LN1@cJSON_Dupl
$LN11@cJSON_Dupl:

; 576  : 		if (nptr) { nptr->next = newchild, newchild->prev = nptr; nptr = newchild; }	/* If newitem->child already set, then crosswire ->prev and ->next and move on */

  0010b	83 7d f4 00	 cmp	 DWORD PTR _nptr$[ebp], 0
  0010f	74 19		 je	 SHORT $LN12@cJSON_Dupl
  00111	8b 45 f4	 mov	 eax, DWORD PTR _nptr$[ebp]
  00114	8b 4d f8	 mov	 ecx, DWORD PTR _newchild$[ebp]
  00117	89 08		 mov	 DWORD PTR [eax], ecx
  00119	8b 55 f8	 mov	 edx, DWORD PTR _newchild$[ebp]
  0011c	8b 45 f4	 mov	 eax, DWORD PTR _nptr$[ebp]
  0011f	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00122	8b 4d f8	 mov	 ecx, DWORD PTR _newchild$[ebp]
  00125	89 4d f4	 mov	 DWORD PTR _nptr$[ebp], ecx
  00128	eb 0f		 jmp	 SHORT $LN13@cJSON_Dupl
$LN12@cJSON_Dupl:

; 577  : 		else { newitem->child = newchild; nptr = newchild; }					/* Set newitem->child and move to it */

  0012a	8b 55 fc	 mov	 edx, DWORD PTR _newitem$[ebp]
  0012d	8b 45 f8	 mov	 eax, DWORD PTR _newchild$[ebp]
  00130	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00133	8b 4d f8	 mov	 ecx, DWORD PTR _newchild$[ebp]
  00136	89 4d f4	 mov	 DWORD PTR _nptr$[ebp], ecx
$LN13@cJSON_Dupl:

; 578  : 		cptr = cptr->next;

  00139	8b 55 f0	 mov	 edx, DWORD PTR _cptr$[ebp]
  0013c	8b 02		 mov	 eax, DWORD PTR [edx]
  0013e	89 45 f0	 mov	 DWORD PTR _cptr$[ebp], eax

; 579  : 	}

  00141	eb 9b		 jmp	 SHORT $LN2@cJSON_Dupl
$LN3@cJSON_Dupl:

; 580  : 	return newitem;

  00143	8b 45 fc	 mov	 eax, DWORD PTR _newitem$[ebp]
$LN1@cJSON_Dupl:

; 581  : }

  00146	8b e5		 mov	 esp, ebp
  00148	5d		 pop	 ebp
  00149	c3		 ret	 0
_cJSON_Duplicate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_ReplaceItemInObject
_TEXT	SEGMENT
_i$ = -8						; size = 4
_c$ = -4						; size = 4
_object$ = 8						; size = 4
_string$ = 12						; size = 4
_newitem$ = 16						; size = 4
_cJSON_ReplaceItemInObject PROC				; COMDAT

; 537  : void   cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem) { int i = 0; cJSON *c = object->child; while (c && cJSON_strcasecmp(c->string, string))i++, c = c->next; if (c) { newitem->string = cJSON_strdup(string); cJSON_ReplaceItemInArray(object, i, newitem); } }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00010	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00013	89 4d fc	 mov	 DWORD PTR _c$[ebp], ecx
$LN2@cJSON_Repl:
  00016	83 7d fc 00	 cmp	 DWORD PTR _c$[ebp], 0
  0001a	74 2a		 je	 SHORT $LN3@cJSON_Repl
  0001c	8b 55 0c	 mov	 edx, DWORD PTR _string$[ebp]
  0001f	52		 push	 edx
  00020	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00023	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 _cJSON_strcasecmp
  0002c	83 c4 08	 add	 esp, 8
  0002f	85 c0		 test	 eax, eax
  00031	74 13		 je	 SHORT $LN3@cJSON_Repl
  00033	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00036	83 c2 01	 add	 edx, 1
  00039	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
  0003c	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  0003f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00041	89 4d fc	 mov	 DWORD PTR _c$[ebp], ecx
  00044	eb d0		 jmp	 SHORT $LN2@cJSON_Repl
$LN3@cJSON_Repl:
  00046	83 7d fc 00	 cmp	 DWORD PTR _c$[ebp], 0
  0004a	74 26		 je	 SHORT $LN1@cJSON_Repl
  0004c	8b 55 0c	 mov	 edx, DWORD PTR _string$[ebp]
  0004f	52		 push	 edx
  00050	e8 00 00 00 00	 call	 _cJSON_strdup
  00055	83 c4 04	 add	 esp, 4
  00058	8b 4d 10	 mov	 ecx, DWORD PTR _newitem$[ebp]
  0005b	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  0005e	8b 55 10	 mov	 edx, DWORD PTR _newitem$[ebp]
  00061	52		 push	 edx
  00062	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00065	50		 push	 eax
  00066	8b 4d 08	 mov	 ecx, DWORD PTR _object$[ebp]
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 _cJSON_ReplaceItemInArray
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@cJSON_Repl:
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
_cJSON_ReplaceItemInObject ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_ReplaceItemInArray
_TEXT	SEGMENT
_c$ = -4						; size = 4
_array$ = 8						; size = 4
_which$ = 12						; size = 4
_newitem$ = 16						; size = 4
_cJSON_ReplaceItemInArray PROC				; COMDAT

; 532  : void   cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 533  : 	cJSON *c = array->child; while (c && which>0) c = c->next, which--; if (!c) return;

  00004	8b 45 08	 mov	 eax, DWORD PTR _array$[ebp]
  00007	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000a	89 4d fc	 mov	 DWORD PTR _c$[ebp], ecx
$LN2@cJSON_Repl:
  0000d	83 7d fc 00	 cmp	 DWORD PTR _c$[ebp], 0
  00011	74 19		 je	 SHORT $LN3@cJSON_Repl
  00013	83 7d 0c 00	 cmp	 DWORD PTR _which$[ebp], 0
  00017	7e 13		 jle	 SHORT $LN3@cJSON_Repl
  00019	8b 55 fc	 mov	 edx, DWORD PTR _c$[ebp]
  0001c	8b 02		 mov	 eax, DWORD PTR [edx]
  0001e	89 45 fc	 mov	 DWORD PTR _c$[ebp], eax
  00021	8b 4d 0c	 mov	 ecx, DWORD PTR _which$[ebp]
  00024	83 e9 01	 sub	 ecx, 1
  00027	89 4d 0c	 mov	 DWORD PTR _which$[ebp], ecx
  0002a	eb e1		 jmp	 SHORT $LN2@cJSON_Repl
$LN3@cJSON_Repl:
  0002c	83 7d fc 00	 cmp	 DWORD PTR _c$[ebp], 0
  00030	75 02		 jne	 SHORT $LN4@cJSON_Repl
  00032	eb 69		 jmp	 SHORT $LN1@cJSON_Repl
$LN4@cJSON_Repl:

; 534  : 	newitem->next = c->next; newitem->prev = c->prev; if (newitem->next) newitem->next->prev = newitem;

  00034	8b 55 10	 mov	 edx, DWORD PTR _newitem$[ebp]
  00037	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  0003a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003c	89 0a		 mov	 DWORD PTR [edx], ecx
  0003e	8b 55 10	 mov	 edx, DWORD PTR _newitem$[ebp]
  00041	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00044	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00047	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0004a	8b 55 10	 mov	 edx, DWORD PTR _newitem$[ebp]
  0004d	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00050	74 0b		 je	 SHORT $LN5@cJSON_Repl
  00052	8b 45 10	 mov	 eax, DWORD PTR _newitem$[ebp]
  00055	8b 08		 mov	 ecx, DWORD PTR [eax]
  00057	8b 55 10	 mov	 edx, DWORD PTR _newitem$[ebp]
  0005a	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN5@cJSON_Repl:

; 535  : 	if (c == array->child) array->child = newitem; else newitem->prev->next = newitem; c->next = c->prev = 0; cJSON_Delete(c);

  0005d	8b 45 08	 mov	 eax, DWORD PTR _array$[ebp]
  00060	8b 4d fc	 mov	 ecx, DWORD PTR _c$[ebp]
  00063	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00066	75 0b		 jne	 SHORT $LN6@cJSON_Repl
  00068	8b 55 08	 mov	 edx, DWORD PTR _array$[ebp]
  0006b	8b 45 10	 mov	 eax, DWORD PTR _newitem$[ebp]
  0006e	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00071	eb 0b		 jmp	 SHORT $LN7@cJSON_Repl
$LN6@cJSON_Repl:
  00073	8b 4d 10	 mov	 ecx, DWORD PTR _newitem$[ebp]
  00076	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00079	8b 45 10	 mov	 eax, DWORD PTR _newitem$[ebp]
  0007c	89 02		 mov	 DWORD PTR [edx], eax
$LN7@cJSON_Repl:
  0007e	8b 4d fc	 mov	 ecx, DWORD PTR _c$[ebp]
  00081	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00088	8b 55 fc	 mov	 edx, DWORD PTR _c$[ebp]
  0008b	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00091	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 _cJSON_Delete
  0009a	83 c4 04	 add	 esp, 4
$LN1@cJSON_Repl:

; 536  : }

  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
_cJSON_ReplaceItemInArray ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_DeleteItemFromObject
_TEXT	SEGMENT
_object$ = 8						; size = 4
_string$ = 12						; size = 4
_cJSON_DeleteItemFromObject PROC			; COMDAT

; 529  : void   cJSON_DeleteItemFromObject(cJSON *object, const char *string) { cJSON_Delete(cJSON_DetachItemFromObject(object, string)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR _string$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _object$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _cJSON_DetachItemFromObject
  00010	83 c4 08	 add	 esp, 8
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _cJSON_Delete
  00019	83 c4 04	 add	 esp, 4
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
_cJSON_DeleteItemFromObject ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_DetachItemFromObject
_TEXT	SEGMENT
_i$ = -8						; size = 4
_c$ = -4						; size = 4
_object$ = 8						; size = 4
_string$ = 12						; size = 4
_cJSON_DetachItemFromObject PROC			; COMDAT

; 528  : cJSON *cJSON_DetachItemFromObject(cJSON *object, const char *string) { int i = 0; cJSON *c = object->child; while (c && cJSON_strcasecmp(c->string, string)) i++, c = c->next; if (c) return cJSON_DetachItemFromArray(object, i); return 0; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000d	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00010	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00013	89 4d fc	 mov	 DWORD PTR _c$[ebp], ecx
$LN2@cJSON_Deta:
  00016	83 7d fc 00	 cmp	 DWORD PTR _c$[ebp], 0
  0001a	74 2a		 je	 SHORT $LN3@cJSON_Deta
  0001c	8b 55 0c	 mov	 edx, DWORD PTR _string$[ebp]
  0001f	52		 push	 edx
  00020	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00023	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 _cJSON_strcasecmp
  0002c	83 c4 08	 add	 esp, 8
  0002f	85 c0		 test	 eax, eax
  00031	74 13		 je	 SHORT $LN3@cJSON_Deta
  00033	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  00036	83 c2 01	 add	 edx, 1
  00039	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
  0003c	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  0003f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00041	89 4d fc	 mov	 DWORD PTR _c$[ebp], ecx
  00044	eb d0		 jmp	 SHORT $LN2@cJSON_Deta
$LN3@cJSON_Deta:
  00046	83 7d fc 00	 cmp	 DWORD PTR _c$[ebp], 0
  0004a	74 12		 je	 SHORT $LN4@cJSON_Deta
  0004c	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0004f	52		 push	 edx
  00050	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 _cJSON_DetachItemFromArray
  00059	83 c4 08	 add	 esp, 8
  0005c	eb 02		 jmp	 SHORT $LN1@cJSON_Deta
$LN4@cJSON_Deta:
  0005e	33 c0		 xor	 eax, eax
$LN1@cJSON_Deta:
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
_cJSON_DetachItemFromObject ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_DeleteItemFromArray
_TEXT	SEGMENT
_array$ = 8						; size = 4
_which$ = 12						; size = 4
_cJSON_DeleteItemFromArray PROC				; COMDAT

; 527  : void   cJSON_DeleteItemFromArray(cJSON *array, int which) { cJSON_Delete(cJSON_DetachItemFromArray(array, which)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR _which$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _array$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 _cJSON_DetachItemFromArray
  00010	83 c4 08	 add	 esp, 8
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _cJSON_Delete
  00019	83 c4 04	 add	 esp, 4
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
_cJSON_DeleteItemFromArray ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_DetachItemFromArray
_TEXT	SEGMENT
_c$ = -4						; size = 4
_array$ = 8						; size = 4
_which$ = 12						; size = 4
_cJSON_DetachItemFromArray PROC				; COMDAT

; 523  : cJSON *cJSON_DetachItemFromArray(cJSON *array, int which) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 524  : 	cJSON *c = array->child; while (c && which>0) c = c->next, which--; if (!c) return 0;

  00004	8b 45 08	 mov	 eax, DWORD PTR _array$[ebp]
  00007	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000a	89 4d fc	 mov	 DWORD PTR _c$[ebp], ecx
$LN2@cJSON_Deta:
  0000d	83 7d fc 00	 cmp	 DWORD PTR _c$[ebp], 0
  00011	74 19		 je	 SHORT $LN3@cJSON_Deta
  00013	83 7d 0c 00	 cmp	 DWORD PTR _which$[ebp], 0
  00017	7e 13		 jle	 SHORT $LN3@cJSON_Deta
  00019	8b 55 fc	 mov	 edx, DWORD PTR _c$[ebp]
  0001c	8b 02		 mov	 eax, DWORD PTR [edx]
  0001e	89 45 fc	 mov	 DWORD PTR _c$[ebp], eax
  00021	8b 4d 0c	 mov	 ecx, DWORD PTR _which$[ebp]
  00024	83 e9 01	 sub	 ecx, 1
  00027	89 4d 0c	 mov	 DWORD PTR _which$[ebp], ecx
  0002a	eb e1		 jmp	 SHORT $LN2@cJSON_Deta
$LN3@cJSON_Deta:
  0002c	83 7d fc 00	 cmp	 DWORD PTR _c$[ebp], 0
  00030	75 04		 jne	 SHORT $LN4@cJSON_Deta
  00032	33 c0		 xor	 eax, eax
  00034	eb 58		 jmp	 SHORT $LN1@cJSON_Deta
$LN4@cJSON_Deta:

; 525  : 	if (c->prev) c->prev->next = c->next; if (c->next) c->next->prev = c->prev; if (c == array->child) array->child = c->next; c->prev = c->next = 0; return c;

  00036	8b 55 fc	 mov	 edx, DWORD PTR _c$[ebp]
  00039	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  0003d	74 0d		 je	 SHORT $LN5@cJSON_Deta
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00042	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00045	8b 55 fc	 mov	 edx, DWORD PTR _c$[ebp]
  00048	8b 02		 mov	 eax, DWORD PTR [edx]
  0004a	89 01		 mov	 DWORD PTR [ecx], eax
$LN5@cJSON_Deta:
  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _c$[ebp]
  0004f	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00052	74 0e		 je	 SHORT $LN6@cJSON_Deta
  00054	8b 55 fc	 mov	 edx, DWORD PTR _c$[ebp]
  00057	8b 02		 mov	 eax, DWORD PTR [edx]
  00059	8b 4d fc	 mov	 ecx, DWORD PTR _c$[ebp]
  0005c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0005f	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN6@cJSON_Deta:
  00062	8b 45 08	 mov	 eax, DWORD PTR _array$[ebp]
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _c$[ebp]
  00068	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0006b	75 0b		 jne	 SHORT $LN7@cJSON_Deta
  0006d	8b 55 08	 mov	 edx, DWORD PTR _array$[ebp]
  00070	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00073	8b 08		 mov	 ecx, DWORD PTR [eax]
  00075	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN7@cJSON_Deta:
  00078	8b 55 fc	 mov	 edx, DWORD PTR _c$[ebp]
  0007b	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  00081	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00084	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0008b	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
$LN1@cJSON_Deta:

; 526  : }

  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
_cJSON_DetachItemFromArray ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_AddItemReferenceToObject
_TEXT	SEGMENT
_object$ = 8						; size = 4
_string$ = 12						; size = 4
_item$ = 16						; size = 4
_cJSON_AddItemReferenceToObject PROC			; COMDAT

; 521  : void	cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item) { cJSON_AddItemToObject(object, string, create_reference(item)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 10	 mov	 eax, DWORD PTR _item$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _create_reference
  0000c	83 c4 04	 add	 esp, 4
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _string$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 08	 mov	 edx, DWORD PTR _object$[ebp]
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _cJSON_AddItemToObject
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
_cJSON_AddItemReferenceToObject ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_AddItemReferenceToArray
_TEXT	SEGMENT
_array$ = 8						; size = 4
_item$ = 12						; size = 4
_cJSON_AddItemReferenceToArray PROC			; COMDAT

; 520  : void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item) { cJSON_AddItemToArray(array, create_reference(item)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR _item$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _create_reference
  0000c	83 c4 04	 add	 esp, 4
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _array$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 _cJSON_AddItemToArray
  00019	83 c4 08	 add	 esp, 8
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
_cJSON_AddItemReferenceToArray ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_AddItemToObject
_TEXT	SEGMENT
_object$ = 8						; size = 4
_string$ = 12						; size = 4
_item$ = 16						; size = 4
_cJSON_AddItemToObject PROC				; COMDAT

; 519  : void   cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item) { if (!item) return; if (item->string) cJSON_free(item->string); item->string = cJSON_strdup(string); cJSON_AddItemToArray(object, item); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 7d 10 00	 cmp	 DWORD PTR _item$[ebp], 0
  00007	75 02		 jne	 SHORT $LN2@cJSON_AddI
  00009	eb 3b		 jmp	 SHORT $LN1@cJSON_AddI
$LN2@cJSON_AddI:
  0000b	8b 45 10	 mov	 eax, DWORD PTR _item$[ebp]
  0000e	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00012	74 10		 je	 SHORT $LN3@cJSON_AddI
  00014	8b 4d 10	 mov	 ecx, DWORD PTR _item$[ebp]
  00017	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0001a	52		 push	 edx
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_free
  00021	83 c4 04	 add	 esp, 4
$LN3@cJSON_AddI:
  00024	8b 45 0c	 mov	 eax, DWORD PTR _string$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _cJSON_strdup
  0002d	83 c4 04	 add	 esp, 4
  00030	8b 4d 10	 mov	 ecx, DWORD PTR _item$[ebp]
  00033	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  00036	8b 55 10	 mov	 edx, DWORD PTR _item$[ebp]
  00039	52		 push	 edx
  0003a	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _cJSON_AddItemToArray
  00043	83 c4 08	 add	 esp, 8
$LN1@cJSON_AddI:
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_cJSON_AddItemToObject ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_AddItemToArray
_TEXT	SEGMENT
_c$ = -4						; size = 4
_array$ = 8						; size = 4
_item$ = 12						; size = 4
_cJSON_AddItemToArray PROC				; COMDAT

; 518  : void   cJSON_AddItemToArray(cJSON *array, cJSON *item) { cJSON *c = array->child; if (!item) return; if (!c) { array->child = item; } else { while (c && c->next) c = c->next; suffix_object(c, item); } }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b 45 08	 mov	 eax, DWORD PTR _array$[ebp]
  00007	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000a	89 4d fc	 mov	 DWORD PTR _c$[ebp], ecx
  0000d	83 7d 0c 00	 cmp	 DWORD PTR _item$[ebp], 0
  00011	75 02		 jne	 SHORT $LN4@cJSON_AddI
  00013	eb 39		 jmp	 SHORT $LN1@cJSON_AddI
$LN4@cJSON_AddI:
  00015	83 7d fc 00	 cmp	 DWORD PTR _c$[ebp], 0
  00019	75 0b		 jne	 SHORT $LN2@cJSON_AddI
  0001b	8b 55 08	 mov	 edx, DWORD PTR _array$[ebp]
  0001e	8b 45 0c	 mov	 eax, DWORD PTR _item$[ebp]
  00021	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00024	eb 28		 jmp	 SHORT $LN1@cJSON_AddI
$LN2@cJSON_AddI:
  00026	83 7d fc 00	 cmp	 DWORD PTR _c$[ebp], 0
  0002a	74 12		 je	 SHORT $LN3@cJSON_AddI
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _c$[ebp]
  0002f	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00032	74 0a		 je	 SHORT $LN3@cJSON_AddI
  00034	8b 55 fc	 mov	 edx, DWORD PTR _c$[ebp]
  00037	8b 02		 mov	 eax, DWORD PTR [edx]
  00039	89 45 fc	 mov	 DWORD PTR _c$[ebp], eax
  0003c	eb e8		 jmp	 SHORT $LN2@cJSON_AddI
$LN3@cJSON_AddI:
  0003e	8b 4d 0c	 mov	 ecx, DWORD PTR _item$[ebp]
  00041	51		 push	 ecx
  00042	8b 55 fc	 mov	 edx, DWORD PTR _c$[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 _suffix_object
  0004b	83 c4 08	 add	 esp, 8
$LN1@cJSON_AddI:
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
_cJSON_AddItemToArray ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateStringArray
_TEXT	SEGMENT
_p$ = -16						; size = 4
_a$ = -12						; size = 4
_n$ = -8						; size = 4
_i$ = -4						; size = 4
_strings$ = 8						; size = 4
_count$ = 12						; size = 4
_cJSON_CreateStringArray PROC				; COMDAT

; 553  : cJSON *cJSON_CreateStringArray(const char **strings, int count) { int i; cJSON *n = 0, *p = 0, *a = cJSON_CreateArray(); for (i = 0; a && i<count; i++) { n = cJSON_CreateString(strings[i]); if (!i)a->child = n; else suffix_object(p, n); p = n; }return a; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  0000d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], 0
  00014	e8 00 00 00 00	 call	 _cJSON_CreateArray
  00019	89 45 f4	 mov	 DWORD PTR _a$[ebp], eax
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00023	eb 09		 jmp	 SHORT $LN4@cJSON_Crea
$LN2@cJSON_Crea:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00028	83 c0 01	 add	 eax, 1
  0002b	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@cJSON_Crea:
  0002e	83 7d f4 00	 cmp	 DWORD PTR _a$[ebp], 0
  00032	74 46		 je	 SHORT $LN3@cJSON_Crea
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00037	3b 4d 0c	 cmp	 ecx, DWORD PTR _count$[ebp]
  0003a	7d 3e		 jge	 SHORT $LN3@cJSON_Crea
  0003c	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0003f	8b 45 08	 mov	 eax, DWORD PTR _strings$[ebp]
  00042	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 _cJSON_CreateString
  0004b	83 c4 04	 add	 esp, 4
  0004e	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
  00051	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00055	75 0b		 jne	 SHORT $LN5@cJSON_Crea
  00057	8b 55 f4	 mov	 edx, DWORD PTR _a$[ebp]
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0005d	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00060	eb 10		 jmp	 SHORT $LN6@cJSON_Crea
$LN5@cJSON_Crea:
  00062	8b 4d f8	 mov	 ecx, DWORD PTR _n$[ebp]
  00065	51		 push	 ecx
  00066	8b 55 f0	 mov	 edx, DWORD PTR _p$[ebp]
  00069	52		 push	 edx
  0006a	e8 00 00 00 00	 call	 _suffix_object
  0006f	83 c4 08	 add	 esp, 8
$LN6@cJSON_Crea:
  00072	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00075	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax
  00078	eb ab		 jmp	 SHORT $LN2@cJSON_Crea
$LN3@cJSON_Crea:
  0007a	8b 45 f4	 mov	 eax, DWORD PTR _a$[ebp]
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
_cJSON_CreateStringArray ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateDoubleArray
_TEXT	SEGMENT
_p$ = -16						; size = 4
_a$ = -12						; size = 4
_n$ = -8						; size = 4
_i$ = -4						; size = 4
_numbers$ = 8						; size = 4
_count$ = 12						; size = 4
_cJSON_CreateDoubleArray PROC				; COMDAT

; 552  : cJSON *cJSON_CreateDoubleArray(const double *numbers, int count) { int i; cJSON *n = 0, *p = 0, *a = cJSON_CreateArray(); for (i = 0; a && i<count; i++) { n = cJSON_CreateNumber(numbers[i]); if (!i)a->child = n; else suffix_object(p, n); p = n; }return a; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  0000d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], 0
  00014	e8 00 00 00 00	 call	 _cJSON_CreateArray
  00019	89 45 f4	 mov	 DWORD PTR _a$[ebp], eax
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00023	eb 09		 jmp	 SHORT $LN4@cJSON_Crea
$LN2@cJSON_Crea:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00028	83 c0 01	 add	 eax, 1
  0002b	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@cJSON_Crea:
  0002e	83 7d f4 00	 cmp	 DWORD PTR _a$[ebp], 0
  00032	74 4b		 je	 SHORT $LN3@cJSON_Crea
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00037	3b 4d 0c	 cmp	 ecx, DWORD PTR _count$[ebp]
  0003a	7d 43		 jge	 SHORT $LN3@cJSON_Crea
  0003c	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0003f	8b 45 08	 mov	 eax, DWORD PTR _numbers$[ebp]
  00042	83 ec 08	 sub	 esp, 8
  00045	dd 04 d0	 fld	 QWORD PTR [eax+edx*8]
  00048	dd 1c 24	 fstp	 QWORD PTR [esp]
  0004b	e8 00 00 00 00	 call	 _cJSON_CreateNumber
  00050	83 c4 08	 add	 esp, 8
  00053	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
  00056	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  0005a	75 0b		 jne	 SHORT $LN5@cJSON_Crea
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  0005f	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  00062	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00065	eb 10		 jmp	 SHORT $LN6@cJSON_Crea
$LN5@cJSON_Crea:
  00067	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d f0	 mov	 ecx, DWORD PTR _p$[ebp]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 _suffix_object
  00074	83 c4 08	 add	 esp, 8
$LN6@cJSON_Crea:
  00077	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  0007a	89 55 f0	 mov	 DWORD PTR _p$[ebp], edx
  0007d	eb a6		 jmp	 SHORT $LN2@cJSON_Crea
$LN3@cJSON_Crea:
  0007f	8b 45 f4	 mov	 eax, DWORD PTR _a$[ebp]
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_cJSON_CreateDoubleArray ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateFloatArray
_TEXT	SEGMENT
_p$ = -16						; size = 4
_a$ = -12						; size = 4
_n$ = -8						; size = 4
_i$ = -4						; size = 4
_numbers$ = 8						; size = 4
_count$ = 12						; size = 4
_cJSON_CreateFloatArray PROC				; COMDAT

; 551  : cJSON *cJSON_CreateFloatArray(const float *numbers, int count) { int i; cJSON *n = 0, *p = 0, *a = cJSON_CreateArray(); for (i = 0; a && i<count; i++) { n = cJSON_CreateNumber(numbers[i]); if (!i)a->child = n; else suffix_object(p, n); p = n; }return a; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  0000d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], 0
  00014	e8 00 00 00 00	 call	 _cJSON_CreateArray
  00019	89 45 f4	 mov	 DWORD PTR _a$[ebp], eax
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00023	eb 09		 jmp	 SHORT $LN4@cJSON_Crea
$LN2@cJSON_Crea:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00028	83 c0 01	 add	 eax, 1
  0002b	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@cJSON_Crea:
  0002e	83 7d f4 00	 cmp	 DWORD PTR _a$[ebp], 0
  00032	74 4b		 je	 SHORT $LN3@cJSON_Crea
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00037	3b 4d 0c	 cmp	 ecx, DWORD PTR _count$[ebp]
  0003a	7d 43		 jge	 SHORT $LN3@cJSON_Crea
  0003c	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0003f	8b 45 08	 mov	 eax, DWORD PTR _numbers$[ebp]
  00042	d9 04 90	 fld	 DWORD PTR [eax+edx*4]
  00045	83 ec 08	 sub	 esp, 8
  00048	dd 1c 24	 fstp	 QWORD PTR [esp]
  0004b	e8 00 00 00 00	 call	 _cJSON_CreateNumber
  00050	83 c4 08	 add	 esp, 8
  00053	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
  00056	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  0005a	75 0b		 jne	 SHORT $LN5@cJSON_Crea
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  0005f	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  00062	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00065	eb 10		 jmp	 SHORT $LN6@cJSON_Crea
$LN5@cJSON_Crea:
  00067	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d f0	 mov	 ecx, DWORD PTR _p$[ebp]
  0006e	51		 push	 ecx
  0006f	e8 00 00 00 00	 call	 _suffix_object
  00074	83 c4 08	 add	 esp, 8
$LN6@cJSON_Crea:
  00077	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  0007a	89 55 f0	 mov	 DWORD PTR _p$[ebp], edx
  0007d	eb a6		 jmp	 SHORT $LN2@cJSON_Crea
$LN3@cJSON_Crea:
  0007f	8b 45 f4	 mov	 eax, DWORD PTR _a$[ebp]
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_cJSON_CreateFloatArray ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateIntArray
_TEXT	SEGMENT
tv82 = -24						; size = 8
_p$ = -16						; size = 4
_a$ = -12						; size = 4
_n$ = -8						; size = 4
_i$ = -4						; size = 4
_numbers$ = 8						; size = 4
_count$ = 12						; size = 4
_cJSON_CreateIntArray PROC				; COMDAT

; 550  : cJSON *cJSON_CreateIntArray(const int *numbers, int count) { int i; cJSON *n = 0, *p = 0, *a = cJSON_CreateArray(); for (i = 0; a && i<count; i++) { n = cJSON_CreateNumber(numbers[i]); if (!i)a->child = n; else suffix_object(p, n); p = n; }return a; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  0000d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _p$[ebp], 0
  00014	e8 00 00 00 00	 call	 _cJSON_CreateArray
  00019	89 45 f4	 mov	 DWORD PTR _a$[ebp], eax
  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00023	eb 09		 jmp	 SHORT $LN4@cJSON_Crea
$LN2@cJSON_Crea:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00028	83 c0 01	 add	 eax, 1
  0002b	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@cJSON_Crea:
  0002e	83 7d f4 00	 cmp	 DWORD PTR _a$[ebp], 0
  00032	74 51		 je	 SHORT $LN3@cJSON_Crea
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00037	3b 4d 0c	 cmp	 ecx, DWORD PTR _count$[ebp]
  0003a	7d 49		 jge	 SHORT $LN3@cJSON_Crea
  0003c	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0003f	8b 45 08	 mov	 eax, DWORD PTR _numbers$[ebp]
  00042	db 04 90	 fild	 DWORD PTR [eax+edx*4]
  00045	dd 5d e8	 fstp	 QWORD PTR tv82[ebp]
  00048	dd 45 e8	 fld	 QWORD PTR tv82[ebp]
  0004b	83 ec 08	 sub	 esp, 8
  0004e	dd 1c 24	 fstp	 QWORD PTR [esp]
  00051	e8 00 00 00 00	 call	 _cJSON_CreateNumber
  00056	83 c4 08	 add	 esp, 8
  00059	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax
  0005c	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  00060	75 0b		 jne	 SHORT $LN5@cJSON_Crea
  00062	8b 4d f4	 mov	 ecx, DWORD PTR _a$[ebp]
  00065	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  00068	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0006b	eb 10		 jmp	 SHORT $LN6@cJSON_Crea
$LN5@cJSON_Crea:
  0006d	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00070	50		 push	 eax
  00071	8b 4d f0	 mov	 ecx, DWORD PTR _p$[ebp]
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 _suffix_object
  0007a	83 c4 08	 add	 esp, 8
$LN6@cJSON_Crea:
  0007d	8b 55 f8	 mov	 edx, DWORD PTR _n$[ebp]
  00080	89 55 f0	 mov	 DWORD PTR _p$[ebp], edx
  00083	eb a0		 jmp	 SHORT $LN2@cJSON_Crea
$LN3@cJSON_Crea:
  00085	8b 45 f4	 mov	 eax, DWORD PTR _a$[ebp]
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
_cJSON_CreateIntArray ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateObject
_TEXT	SEGMENT
_item$ = -4						; size = 4
_cJSON_CreateObject PROC				; COMDAT

; 547  : cJSON *cJSON_CreateObject(void) { cJSON *item = cJSON_New_Item(); if (item)item->type = cJSON_Object; return item; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	e8 00 00 00 00	 call	 _cJSON_New_Item
  00009	89 45 fc	 mov	 DWORD PTR _item$[ebp], eax
  0000c	83 7d fc 00	 cmp	 DWORD PTR _item$[ebp], 0
  00010	74 0a		 je	 SHORT $LN2@cJSON_Crea
  00012	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  00015	c7 40 0c 06 00
	00 00		 mov	 DWORD PTR [eax+12], 6
$LN2@cJSON_Crea:
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_cJSON_CreateObject ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateArray
_TEXT	SEGMENT
_item$ = -4						; size = 4
_cJSON_CreateArray PROC					; COMDAT

; 546  : cJSON *cJSON_CreateArray(void) { cJSON *item = cJSON_New_Item(); if (item)item->type = cJSON_Array; return item; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	e8 00 00 00 00	 call	 _cJSON_New_Item
  00009	89 45 fc	 mov	 DWORD PTR _item$[ebp], eax
  0000c	83 7d fc 00	 cmp	 DWORD PTR _item$[ebp], 0
  00010	74 0a		 je	 SHORT $LN2@cJSON_Crea
  00012	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  00015	c7 40 0c 05 00
	00 00		 mov	 DWORD PTR [eax+12], 5
$LN2@cJSON_Crea:
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_cJSON_CreateArray ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateString
_TEXT	SEGMENT
_item$ = -4						; size = 4
_string$ = 8						; size = 4
_cJSON_CreateString PROC				; COMDAT

; 545  : cJSON *cJSON_CreateString(const char *string) { cJSON *item = cJSON_New_Item(); if (item) { item->type = cJSON_String; item->valuestring = cJSON_strdup(string); }return item; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	e8 00 00 00 00	 call	 _cJSON_New_Item
  00009	89 45 fc	 mov	 DWORD PTR _item$[ebp], eax
  0000c	83 7d fc 00	 cmp	 DWORD PTR _item$[ebp], 0
  00010	74 1c		 je	 SHORT $LN2@cJSON_Crea
  00012	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  00015	c7 40 0c 04 00
	00 00		 mov	 DWORD PTR [eax+12], 4
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 _cJSON_strdup
  00025	83 c4 04	 add	 esp, 4
  00028	8b 55 fc	 mov	 edx, DWORD PTR _item$[ebp]
  0002b	89 42 10	 mov	 DWORD PTR [edx+16], eax
$LN2@cJSON_Crea:
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
_cJSON_CreateString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateNumber
_TEXT	SEGMENT
_item$ = -4						; size = 4
_num$ = 8						; size = 8
_cJSON_CreateNumber PROC				; COMDAT

; 544  : cJSON *cJSON_CreateNumber(double num) { cJSON *item = cJSON_New_Item(); if (item) { item->type = cJSON_Number; item->valuedouble = num; item->valueint = (int)num; }return item; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	e8 00 00 00 00	 call	 _cJSON_New_Item
  00009	89 45 fc	 mov	 DWORD PTR _item$[ebp], eax
  0000c	83 7d fc 00	 cmp	 DWORD PTR _item$[ebp], 0
  00010	74 21		 je	 SHORT $LN2@cJSON_Crea
  00012	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  00015	c7 40 0c 03 00
	00 00		 mov	 DWORD PTR [eax+12], 3
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _item$[ebp]
  0001f	dd 45 08	 fld	 QWORD PTR _num$[ebp]
  00022	dd 59 18	 fstp	 QWORD PTR [ecx+24]
  00025	dd 45 08	 fld	 QWORD PTR _num$[ebp]
  00028	e8 00 00 00 00	 call	 __ftol2_sse
  0002d	8b 55 fc	 mov	 edx, DWORD PTR _item$[ebp]
  00030	89 42 14	 mov	 DWORD PTR [edx+20], eax
$LN2@cJSON_Crea:
  00033	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
_cJSON_CreateNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateBool
_TEXT	SEGMENT
tv68 = -8						; size = 4
_item$ = -4						; size = 4
_b$ = 8							; size = 4
_cJSON_CreateBool PROC					; COMDAT

; 543  : cJSON *cJSON_CreateBool(int b) { cJSON *item = cJSON_New_Item(); if (item)item->type = b ? cJSON_True : cJSON_False; return item; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	e8 00 00 00 00	 call	 _cJSON_New_Item
  0000b	89 45 fc	 mov	 DWORD PTR _item$[ebp], eax
  0000e	83 7d fc 00	 cmp	 DWORD PTR _item$[ebp], 0
  00012	74 1f		 je	 SHORT $LN2@cJSON_Crea
  00014	83 7d 08 00	 cmp	 DWORD PTR _b$[ebp], 0
  00018	74 09		 je	 SHORT $LN4@cJSON_Crea
  0001a	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00021	eb 07		 jmp	 SHORT $LN5@cJSON_Crea
$LN4@cJSON_Crea:
  00023	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN5@cJSON_Crea:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR tv68[ebp]
  00030	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
$LN2@cJSON_Crea:
  00033	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
_cJSON_CreateBool ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateFalse
_TEXT	SEGMENT
_item$ = -4						; size = 4
_cJSON_CreateFalse PROC					; COMDAT

; 542  : cJSON *cJSON_CreateFalse(void) { cJSON *item = cJSON_New_Item(); if (item)item->type = cJSON_False; return item; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	e8 00 00 00 00	 call	 _cJSON_New_Item
  00009	89 45 fc	 mov	 DWORD PTR _item$[ebp], eax
  0000c	83 7d fc 00	 cmp	 DWORD PTR _item$[ebp], 0
  00010	74 0a		 je	 SHORT $LN2@cJSON_Crea
  00012	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  00015	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], 0
$LN2@cJSON_Crea:
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_cJSON_CreateFalse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateTrue
_TEXT	SEGMENT
_item$ = -4						; size = 4
_cJSON_CreateTrue PROC					; COMDAT

; 541  : cJSON *cJSON_CreateTrue(void) { cJSON *item = cJSON_New_Item(); if (item)item->type = cJSON_True; return item; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	e8 00 00 00 00	 call	 _cJSON_New_Item
  00009	89 45 fc	 mov	 DWORD PTR _item$[ebp], eax
  0000c	83 7d fc 00	 cmp	 DWORD PTR _item$[ebp], 0
  00010	74 0a		 je	 SHORT $LN2@cJSON_Crea
  00012	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  00015	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [eax+12], 1
$LN2@cJSON_Crea:
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_cJSON_CreateTrue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_CreateNull
_TEXT	SEGMENT
_item$ = -4						; size = 4
_cJSON_CreateNull PROC					; COMDAT

; 540  : cJSON *cJSON_CreateNull(void) { cJSON *item = cJSON_New_Item(); if (item)item->type = cJSON_NULL; return item; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	e8 00 00 00 00	 call	 _cJSON_New_Item
  00009	89 45 fc	 mov	 DWORD PTR _item$[ebp], eax
  0000c	83 7d fc 00	 cmp	 DWORD PTR _item$[ebp], 0
  00010	74 0a		 je	 SHORT $LN2@cJSON_Crea
  00012	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  00015	c7 40 0c 02 00
	00 00		 mov	 DWORD PTR [eax+12], 2
$LN2@cJSON_Crea:
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _item$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_cJSON_CreateNull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_GetErrorPtr
_TEXT	SEGMENT
_cJSON_GetErrorPtr PROC					; COMDAT

; 34   : const char *cJSON_GetErrorPtr(void) { return ep; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR _ep
  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
_cJSON_GetErrorPtr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_GetObjectItem
_TEXT	SEGMENT
_c$ = -4						; size = 4
_object$ = 8						; size = 4
_string$ = 12						; size = 4
_cJSON_GetObjectItem PROC				; COMDAT

; 510  : cJSON *cJSON_GetObjectItem(cJSON *object, const char *string) { cJSON *c = object->child; while (c && cJSON_strcasecmp(c->string, string)) c = c->next; return c; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b 45 08	 mov	 eax, DWORD PTR _object$[ebp]
  00007	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000a	89 4d fc	 mov	 DWORD PTR _c$[ebp], ecx
$LN2@cJSON_GetO:
  0000d	83 7d fc 00	 cmp	 DWORD PTR _c$[ebp], 0
  00011	74 21		 je	 SHORT $LN3@cJSON_GetO
  00013	8b 55 0c	 mov	 edx, DWORD PTR _string$[ebp]
  00016	52		 push	 edx
  00017	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  0001a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 _cJSON_strcasecmp
  00023	83 c4 08	 add	 esp, 8
  00026	85 c0		 test	 eax, eax
  00028	74 0a		 je	 SHORT $LN3@cJSON_GetO
  0002a	8b 55 fc	 mov	 edx, DWORD PTR _c$[ebp]
  0002d	8b 02		 mov	 eax, DWORD PTR [edx]
  0002f	89 45 fc	 mov	 DWORD PTR _c$[ebp], eax
  00032	eb d9		 jmp	 SHORT $LN2@cJSON_GetO
$LN3@cJSON_GetO:
  00034	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
_cJSON_GetObjectItem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_GetArrayItem
_TEXT	SEGMENT
_c$ = -4						; size = 4
_array$ = 8						; size = 4
_item$ = 12						; size = 4
_cJSON_GetArrayItem PROC				; COMDAT

; 509  : cJSON *cJSON_GetArrayItem(cJSON *array, int item) { cJSON *c = array->child;  while (c && item>0) item--, c = c->next; return c; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b 45 08	 mov	 eax, DWORD PTR _array$[ebp]
  00007	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000a	89 4d fc	 mov	 DWORD PTR _c$[ebp], ecx
$LN2@cJSON_GetA:
  0000d	83 7d fc 00	 cmp	 DWORD PTR _c$[ebp], 0
  00011	74 19		 je	 SHORT $LN3@cJSON_GetA
  00013	83 7d 0c 00	 cmp	 DWORD PTR _item$[ebp], 0
  00017	7e 13		 jle	 SHORT $LN3@cJSON_GetA
  00019	8b 55 0c	 mov	 edx, DWORD PTR _item$[ebp]
  0001c	83 ea 01	 sub	 edx, 1
  0001f	89 55 0c	 mov	 DWORD PTR _item$[ebp], edx
  00022	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	89 4d fc	 mov	 DWORD PTR _c$[ebp], ecx
  0002a	eb e1		 jmp	 SHORT $LN2@cJSON_GetA
$LN3@cJSON_GetA:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
_cJSON_GetArrayItem ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_GetArraySize
_TEXT	SEGMENT
_i$ = -8						; size = 4
_c$ = -4						; size = 4
_array$ = 8						; size = 4
_cJSON_GetArraySize PROC				; COMDAT

; 508  : int    cJSON_GetArraySize(cJSON *array) { cJSON *c = array->child; int i = 0; while (c)i++, c = c->next; return i; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	8b 45 08	 mov	 eax, DWORD PTR _array$[ebp]
  00009	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000c	89 4d fc	 mov	 DWORD PTR _c$[ebp], ecx
  0000f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN2@cJSON_GetA:
  00016	83 7d fc 00	 cmp	 DWORD PTR _c$[ebp], 0
  0001a	74 13		 je	 SHORT $LN3@cJSON_GetA
  0001c	8b 55 f8	 mov	 edx, DWORD PTR _i$[ebp]
  0001f	83 c2 01	 add	 edx, 1
  00022	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx
  00025	8b 45 fc	 mov	 eax, DWORD PTR _c$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	89 4d fc	 mov	 DWORD PTR _c$[ebp], ecx
  0002d	eb e7		 jmp	 SHORT $LN2@cJSON_GetA
$LN3@cJSON_GetA:
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
_cJSON_GetArraySize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_Delete
_TEXT	SEGMENT
_next$ = -4						; size = 4
_c$ = 8							; size = 4
_cJSON_Delete PROC					; COMDAT

; 79   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@cJSON_Dele:

; 80   : 	cJSON *next;
; 81   : 	while (c)

  00004	83 7d 08 00	 cmp	 DWORD PTR _c$[ebp], 0
  00008	0f 84 85 00 00
	00		 je	 $LN1@cJSON_Dele

; 82   : 	{
; 83   : 		next = c->next;

  0000e	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	89 4d fc	 mov	 DWORD PTR _next$[ebp], ecx

; 84   : 		if (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);

  00016	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  00019	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0001c	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00021	75 18		 jne	 SHORT $LN4@cJSON_Dele
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00026	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  0002a	74 0f		 je	 SHORT $LN4@cJSON_Dele
  0002c	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  0002f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _cJSON_Delete
  00038	83 c4 04	 add	 esp, 4
$LN4@cJSON_Dele:

; 85   : 		if (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);

  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  0003e	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00041	81 e2 00 01 00
	00		 and	 edx, 256		; 00000100H
  00047	75 19		 jne	 SHORT $LN5@cJSON_Dele
  00049	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0004c	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00050	74 10		 je	 SHORT $LN5@cJSON_Dele
  00052	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  00055	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00058	52		 push	 edx
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_free
  0005f	83 c4 04	 add	 esp, 4
$LN5@cJSON_Dele:

; 86   : 		if (c->string) cJSON_free(c->string);

  00062	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  00065	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00069	74 10		 je	 SHORT $LN6@cJSON_Dele
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _c$[ebp]
  0006e	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00071	52		 push	 edx
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_free
  00078	83 c4 04	 add	 esp, 4
$LN6@cJSON_Dele:

; 87   : 		cJSON_free(c);

  0007b	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0007e	50		 push	 eax
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR _cJSON_free
  00085	83 c4 04	 add	 esp, 4

; 88   : 		c = next;

  00088	8b 4d fc	 mov	 ecx, DWORD PTR _next$[ebp]
  0008b	89 4d 08	 mov	 DWORD PTR _c$[ebp], ecx

; 89   : 	}

  0008e	e9 71 ff ff ff	 jmp	 $LN2@cJSON_Dele
$LN1@cJSON_Dele:

; 90   : }

  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
_cJSON_Delete ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_PrintUnformatted
_TEXT	SEGMENT
_item$ = 8						; size = 4
_cJSON_PrintUnformatted PROC				; COMDAT

; 282  : char *cJSON_PrintUnformatted(cJSON *item) { return print_value(item, 0, 0); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _print_value
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_cJSON_PrintUnformatted ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_Print
_TEXT	SEGMENT
_item$ = 8						; size = 4
_cJSON_Print PROC					; COMDAT

; 281  : char *cJSON_Print(cJSON *item) { return print_value(item, 0, 1); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 01		 push	 1
  00005	6a 00		 push	 0
  00007	8b 45 08	 mov	 eax, DWORD PTR _item$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _print_value
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_cJSON_Print ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_Parse
_TEXT	SEGMENT
_value$ = 8						; size = 4
_cJSON_Parse PROC					; COMDAT

; 278  : cJSON *cJSON_Parse(const char *value) { return cJSON_ParseWithOpts(value, 0, 0); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	8b 45 08	 mov	 eax, DWORD PTR _value$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _cJSON_ParseWithOpts
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
_cJSON_Parse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\cjson\cjson.c
;	COMDAT _cJSON_InitHooks
_TEXT	SEGMENT
tv72 = -8						; size = 4
tv68 = -4						; size = 4
_hooks$ = 8						; size = 4
_cJSON_InitHooks PROC					; COMDAT

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 59   : 	if (!hooks) { /* Reset hooks */

  00006	83 7d 08 00	 cmp	 DWORD PTR _hooks$[ebp], 0
  0000a	75 16		 jne	 SHORT $LN2@cJSON_Init

; 60   : 		cJSON_malloc = malloc;

  0000c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cJSON_malloc, OFFSET __hx_malloc

; 61   : 		cJSON_free = free;

  00016	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _cJSON_free, OFFSET __hx_free

; 62   : 		return;

  00020	eb 45		 jmp	 SHORT $LN1@cJSON_Init
$LN2@cJSON_Init:

; 63   : 	}
; 64   : 
; 65   : 	cJSON_malloc = (hooks->malloc_fn) ? hooks->malloc_fn : malloc;

  00022	8b 45 08	 mov	 eax, DWORD PTR _hooks$[ebp]
  00025	83 38 00	 cmp	 DWORD PTR [eax], 0
  00028	74 0a		 je	 SHORT $LN4@cJSON_Init
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _hooks$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	89 55 fc	 mov	 DWORD PTR tv68[ebp], edx
  00032	eb 07		 jmp	 SHORT $LN5@cJSON_Init
$LN4@cJSON_Init:
  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], OFFSET __hx_malloc
$LN5@cJSON_Init:
  0003b	8b 45 fc	 mov	 eax, DWORD PTR tv68[ebp]
  0003e	a3 00 00 00 00	 mov	 DWORD PTR _cJSON_malloc, eax

; 66   : 	cJSON_free = (hooks->free_fn) ? hooks->free_fn : free;

  00043	8b 4d 08	 mov	 ecx, DWORD PTR _hooks$[ebp]
  00046	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0004a	74 0b		 je	 SHORT $LN6@cJSON_Init
  0004c	8b 55 08	 mov	 edx, DWORD PTR _hooks$[ebp]
  0004f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00052	89 45 f8	 mov	 DWORD PTR tv72[ebp], eax
  00055	eb 07		 jmp	 SHORT $LN7@cJSON_Init
$LN6@cJSON_Init:
  00057	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], OFFSET __hx_free
$LN7@cJSON_Init:
  0005e	8b 4d f8	 mov	 ecx, DWORD PTR tv72[ebp]
  00061	89 0d 00 00 00
	00		 mov	 DWORD PTR _cJSON_free, ecx
$LN1@cJSON_Init:

; 67   : }

  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_cJSON_InitHooks ENDP
_TEXT	ENDS
END
