; Listing generated by Microsoft (R) Optimizing Compiler Version 19.13.26128.0 

	TITLE	C:\HelloX\personal\HelloX_OS\app\yeelight\hxlib\hellox\cli.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_cmd_buffer DD	01H DUP (?)
_prompt_string DB 041H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG4722	DB	'[%s]', 00H
	ORG $+3
$SG4816	DB	'Too many or too few arguments[%d].', 0dH, 0aH, 00H
	ORG $+3
$SG4818	DB	'Argument should not be empty.', 0dH, 0aH, 00H
$SG4820	DB	'Can not obtain name from[%s].', 0dH, 0aH, 00H
$SG4822	DB	'Application file name too short[%s].', 0dH, 0aH, 00H
_DATA	ENDS
PUBLIC	_getcmd
PUBLIC	__hx_entry
EXTRN	_GetMessage:PROC
EXTRN	_PrintChar:PROC
EXTRN	_GotoHome:PROC
EXTRN	_ChangeLine:PROC
EXTRN	_GotoPrev:PROC
EXTRN	__hx_printf:PROC
EXTRN	__hx_malloc:PROC
EXTRN	__hx_free:PROC
EXTRN	_strrchr:PROC
EXTRN	_strlen:PROC
EXTRN	__hx_main:PROC
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\hellox\cli.c
;	COMDAT __hx_entry
_TEXT	SEGMENT
_ret$ = -12						; size = 4
_length$ = -8						; size = 4
_app_name$ = -4						; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
__hx_entry PROC						; COMDAT

; 217  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 218  : 	char* app_name = NULL;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _app_name$[ebp], 0

; 219  : 	int ret = -1, length = 0;

  0000d	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -1
  00014	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _length$[ebp], 0

; 220  : 
; 221  : 	/* Argument's number must not exceed the max value. */
; 222  : 	if ((argc > CMD_PARAMETER_COUNT) || (0 == argc))

  0001b	83 7d 08 10	 cmp	 DWORD PTR _argc$[ebp], 16 ; 00000010H
  0001f	7f 06		 jg	 SHORT $LN5@hx_entry
  00021	83 7d 08 00	 cmp	 DWORD PTR _argc$[ebp], 0
  00025	75 16		 jne	 SHORT $LN4@hx_entry
$LN5@hx_entry:

; 223  : 	{
; 224  : 		_hx_printf("Too many or too few arguments[%d].\r\n", argc);

  00027	8b 45 08	 mov	 eax, DWORD PTR _argc$[ebp]
  0002a	50		 push	 eax
  0002b	68 00 00 00 00	 push	 OFFSET $SG4816
  00030	e8 00 00 00 00	 call	 __hx_printf
  00035	83 c4 08	 add	 esp, 8

; 225  : 		goto __TERMINAL;

  00038	e9 e9 00 00 00	 jmp	 $__TERMINAL$11
$LN4@hx_entry:

; 226  : 	}
; 227  : 	if (NULL == argv)

  0003d	83 7d 0c 00	 cmp	 DWORD PTR _argv$[ebp], 0
  00041	75 12		 jne	 SHORT $LN6@hx_entry

; 228  : 	{
; 229  : 		_hx_printf("Argument should not be empty.\r\n");

  00043	68 00 00 00 00	 push	 OFFSET $SG4818
  00048	e8 00 00 00 00	 call	 __hx_printf
  0004d	83 c4 04	 add	 esp, 4

; 230  : 		goto __TERMINAL;

  00050	e9 d1 00 00 00	 jmp	 $__TERMINAL$11
$LN6@hx_entry:

; 231  : 	}
; 232  : 
; 233  : 	/* Obtain the application's name,without suffix,as prompt string. */
; 234  : 	app_name = strrchr(argv[0], '\\');

  00055	6a 5c		 push	 92			; 0000005cH
  00057	b9 04 00 00 00	 mov	 ecx, 4
  0005c	6b d1 00	 imul	 edx, ecx, 0
  0005f	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  00062	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 _strrchr
  0006b	83 c4 08	 add	 esp, 8
  0006e	89 45 fc	 mov	 DWORD PTR _app_name$[ebp], eax

; 235  : 	if (NULL == app_name)

  00071	83 7d fc 00	 cmp	 DWORD PTR _app_name$[ebp], 0
  00075	75 21		 jne	 SHORT $LN7@hx_entry

; 236  : 	{
; 237  : 		_hx_printf("Can not obtain name from[%s].\r\n", argv[0]);

  00077	ba 04 00 00 00	 mov	 edx, 4
  0007c	6b c2 00	 imul	 eax, edx, 0
  0007f	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  00082	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00085	52		 push	 edx
  00086	68 00 00 00 00	 push	 OFFSET $SG4820
  0008b	e8 00 00 00 00	 call	 __hx_printf
  00090	83 c4 08	 add	 esp, 8

; 238  : 		goto __TERMINAL;

  00093	e9 8e 00 00 00	 jmp	 $__TERMINAL$11
$LN7@hx_entry:

; 239  : 	}
; 240  : 
; 241  : 	if (strlen(app_name) < 2)

  00098	8b 45 fc	 mov	 eax, DWORD PTR _app_name$[ebp]
  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 _strlen
  000a1	83 c4 04	 add	 esp, 4
  000a4	83 f8 02	 cmp	 eax, 2
  000a7	7d 13		 jge	 SHORT $LN8@hx_entry

; 242  : 	{
; 243  : 		_hx_printf("Application file name too short[%s].\r\n", app_name);

  000a9	8b 4d fc	 mov	 ecx, DWORD PTR _app_name$[ebp]
  000ac	51		 push	 ecx
  000ad	68 00 00 00 00	 push	 OFFSET $SG4822
  000b2	e8 00 00 00 00	 call	 __hx_printf
  000b7	83 c4 08	 add	 esp, 8

; 244  : 		goto __TERMINAL;

  000ba	eb 6a		 jmp	 SHORT $__TERMINAL$11
$LN8@hx_entry:

; 245  : 	}
; 246  : 	app_name += 1; /* Skip the slash. */

  000bc	8b 55 fc	 mov	 edx, DWORD PTR _app_name$[ebp]
  000bf	83 c2 01	 add	 edx, 1
  000c2	89 55 fc	 mov	 DWORD PTR _app_name$[ebp], edx

; 247  : 	length = 0;

  000c5	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _length$[ebp], 0
$LN2@hx_entry:

; 248  : 	while (*app_name && ('.' != *app_name) && (length < CMD_PARAMETER_LEN))

  000cc	8b 45 fc	 mov	 eax, DWORD PTR _app_name$[ebp]
  000cf	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000d2	85 c9		 test	 ecx, ecx
  000d4	74 33		 je	 SHORT $LN3@hx_entry
  000d6	8b 55 fc	 mov	 edx, DWORD PTR _app_name$[ebp]
  000d9	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000dc	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  000df	74 28		 je	 SHORT $LN3@hx_entry
  000e1	83 7d f8 40	 cmp	 DWORD PTR _length$[ebp], 64 ; 00000040H
  000e5	7d 22		 jge	 SHORT $LN3@hx_entry

; 249  : 	{
; 250  : 		prompt_string[length++] = *app_name++;

  000e7	8b 4d f8	 mov	 ecx, DWORD PTR _length$[ebp]
  000ea	8b 55 fc	 mov	 edx, DWORD PTR _app_name$[ebp]
  000ed	8a 02		 mov	 al, BYTE PTR [edx]
  000ef	88 81 00 00 00
	00		 mov	 BYTE PTR _prompt_string[ecx], al
  000f5	8b 4d f8	 mov	 ecx, DWORD PTR _length$[ebp]
  000f8	83 c1 01	 add	 ecx, 1
  000fb	89 4d f8	 mov	 DWORD PTR _length$[ebp], ecx
  000fe	8b 55 fc	 mov	 edx, DWORD PTR _app_name$[ebp]
  00101	83 c2 01	 add	 edx, 1
  00104	89 55 fc	 mov	 DWORD PTR _app_name$[ebp], edx

; 251  : 	}

  00107	eb c3		 jmp	 SHORT $LN2@hx_entry
$LN3@hx_entry:

; 252  : 	prompt_string[length] = 0;

  00109	8b 45 f8	 mov	 eax, DWORD PTR _length$[ebp]
  0010c	c6 80 00 00 00
	00 00		 mov	 BYTE PTR _prompt_string[eax], 0

; 253  : 
; 254  : 	/* Call the application specified entry point. */
; 255  : 	ret = _hx_main(argc, argv);

  00113	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  00116	51		 push	 ecx
  00117	8b 55 08	 mov	 edx, DWORD PTR _argc$[ebp]
  0011a	52		 push	 edx
  0011b	e8 00 00 00 00	 call	 __hx_main
  00120	83 c4 08	 add	 esp, 8
  00123	89 45 f4	 mov	 DWORD PTR _ret$[ebp], eax
$__TERMINAL$11:

; 256  : 
; 257  : __TERMINAL:
; 258  : 	/* Release the command buffer memory if allocated. */
; 259  : 	if (cmd_buffer)

  00126	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cmd_buffer, 0
  0012d	74 0e		 je	 SHORT $LN9@hx_entry

; 260  : 	{
; 261  : 		_hx_free(cmd_buffer);

  0012f	a1 00 00 00 00	 mov	 eax, DWORD PTR _cmd_buffer
  00134	50		 push	 eax
  00135	e8 00 00 00 00	 call	 __hx_free
  0013a	83 c4 04	 add	 esp, 4
$LN9@hx_entry:

; 262  : 	}
; 263  : 	return ret;

  0013d	8b 45 f4	 mov	 eax, DWORD PTR _ret$[ebp]

; 264  : }

  00140	8b e5		 mov	 esp, ebp
  00142	5d		 pop	 ebp
  00143	c3		 ret	 0
__hx_entry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\hellox\cli.c
;	COMDAT _get_user_stroke
_TEXT	SEGMENT
_Msg$ = -40						; size = 8
_ret$ = -32						; size = 4
_bCtrlDown$ = -28					; size = 4
_dwDefaultSize$ = -24					; size = 4
tv73 = -20						; size = 4
_pDataBuffer$ = -16					; size = 4
_pCurrPos$ = -12					; size = 4
_wr$ = -8						; size = 2
_bt$ = -1						; size = 1
_buffer$ = 8						; size = 4
_len$ = 12						; size = 4
_get_user_stroke PROC					; COMDAT

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 38   : 	char*                       pDataBuffer = buffer;

  00006	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00009	89 45 f0	 mov	 DWORD PTR _pDataBuffer$[ebp], eax

; 39   : 	char*                       pCurrPos = NULL;

  0000c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pCurrPos$[ebp], 0

; 40   : 	DWORD                       dwDefaultSize = len; //Command buffer's length.

  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _len$[ebp]
  00016	89 4d e8	 mov	 DWORD PTR _dwDefaultSize$[ebp], ecx

; 41   : 	BOOL                        bCtrlDown = FALSE;

  00019	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bCtrlDown$[ebp], 0

; 42   : 	char                        bt;
; 43   : 	WORD                        wr = 0x0700;

  00020	ba 00 07 00 00	 mov	 edx, 1792		; 00000700H
  00025	66 89 55 f8	 mov	 WORD PTR _wr$[ebp], dx

; 44   : 	MSG                         Msg;
; 45   : 	int                         ret = -1;

  00029	c7 45 e0 ff ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -1

; 46   : 
; 47   : 	//Parameter checking.
; 48   : 	if ((NULL == buffer) || (0 == len))

  00030	83 7d 08 00	 cmp	 DWORD PTR _buffer$[ebp], 0
  00034	74 06		 je	 SHORT $LN7@get_user_s
  00036	83 7d 0c 00	 cmp	 DWORD PTR _len$[ebp], 0
  0003a	75 05		 jne	 SHORT $LN6@get_user_s
$LN7@get_user_s:

; 49   : 	{
; 50   : 		goto __TERMINAL;

  0003c	e9 2b 01 00 00	 jmp	 $__TERMINAL$23
$LN6@get_user_s:

; 51   : 	}
; 52   : 	pCurrPos = pDataBuffer;

  00041	8b 45 f0	 mov	 eax, DWORD PTR _pDataBuffer$[ebp]
  00044	89 45 f4	 mov	 DWORD PTR _pCurrPos$[ebp], eax
$LN2@get_user_s:

; 53   : 
; 54   : 	while (TRUE)

  00047	83 c9 ff	 or	 ecx, -1
  0004a	0f 84 1c 01 00
	00		 je	 $__TERMINAL$23

; 55   : 	{
; 56   : 		if (GetMessage(&Msg))

  00050	8d 55 d8	 lea	 edx, DWORD PTR _Msg$[ebp]
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 _GetMessage
  00059	83 c4 04	 add	 esp, 4
  0005c	85 c0		 test	 eax, eax
  0005e	0f 84 03 01 00
	00		 je	 $LN8@get_user_s

; 57   : 		{
; 58   : 			if (KERNEL_MESSAGE_AKDOWN == Msg.wCommand)    //This is a key down message.

  00064	0f b7 45 d8	 movzx	 eax, WORD PTR _Msg$[ebp]
  00068	83 f8 01	 cmp	 eax, 1
  0006b	0f 85 b2 00 00
	00		 jne	 $LN9@get_user_s

; 59   : 			{
; 60   : 				bt = (BYTE)Msg.dwParam;

  00071	8a 4d dc	 mov	 cl, BYTE PTR _Msg$[ebp+4]
  00074	88 4d ff	 mov	 BYTE PTR _bt$[ebp], cl

; 61   : 				switch (bt)

  00077	8a 55 ff	 mov	 dl, BYTE PTR _bt$[ebp]
  0007a	88 55 ec	 mov	 BYTE PTR tv73[ebp], dl
  0007d	80 7d ec 08	 cmp	 BYTE PTR tv73[ebp], 8
  00081	74 33		 je	 SHORT $LN13@get_user_s
  00083	80 7d ec 0d	 cmp	 BYTE PTR tv73[ebp], 13	; 0000000dH
  00087	74 02		 je	 SHORT $LN11@get_user_s
  00089	eb 51		 jmp	 SHORT $LN16@get_user_s
$LN11@get_user_s:

; 62   : 				{
; 63   : 				case VK_RETURN:
; 64   : 					/* Enter key,terminate command buffer and return. */
; 65   : 					if ((DWORD)(pCurrPos - pDataBuffer) < dwDefaultSize)

  0008b	8b 45 f4	 mov	 eax, DWORD PTR _pCurrPos$[ebp]
  0008e	2b 45 f0	 sub	 eax, DWORD PTR _pDataBuffer$[ebp]
  00091	3b 45 e8	 cmp	 eax, DWORD PTR _dwDefaultSize$[ebp]
  00094	73 1e		 jae	 SHORT $LN12@get_user_s

; 66   : 					{
; 67   : 						*pCurrPos = '\0';

  00096	8b 4d f4	 mov	 ecx, DWORD PTR _pCurrPos$[ebp]
  00099	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 68   : 						ret = pCurrPos - pDataBuffer;

  0009c	8b 55 f4	 mov	 edx, DWORD PTR _pCurrPos$[ebp]
  0009f	2b 55 f0	 sub	 edx, DWORD PTR _pDataBuffer$[ebp]
  000a2	89 55 e0	 mov	 DWORD PTR _ret$[ebp], edx

; 69   : 						/* Change a new line. */
; 70   : 						ChangeLine();

  000a5	e8 00 00 00 00	 call	 _ChangeLine

; 71   : 						GotoHome();

  000aa	e8 00 00 00 00	 call	 _GotoHome

; 72   : 						goto __TERMINAL;

  000af	e9 b8 00 00 00	 jmp	 $__TERMINAL$23
$LN12@get_user_s:

; 73   : 					}
; 74   : 					break;

  000b4	eb 6b		 jmp	 SHORT $LN4@get_user_s
$LN13@get_user_s:

; 75   : 				case VK_BACKSPACE:
; 76   : 					/* Delete current character and move back cursor. */
; 77   : 					if (*pCurrPos == '\n')

  000b6	8b 45 f4	 mov	 eax, DWORD PTR _pCurrPos$[ebp]
  000b9	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000bc	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  000bf	75 0b		 jne	 SHORT $LN14@get_user_s

; 78   : 					{
; 79   : 						pCurrPos -= 2;     //Skip the \r\n.

  000c1	8b 55 f4	 mov	 edx, DWORD PTR _pCurrPos$[ebp]
  000c4	83 ea 02	 sub	 edx, 2
  000c7	89 55 f4	 mov	 DWORD PTR _pCurrPos$[ebp], edx

; 80   : 					}

  000ca	eb 09		 jmp	 SHORT $LN15@get_user_s
$LN14@get_user_s:

; 81   : 					else
; 82   : 					{
; 83   : 						pCurrPos -= 1;

  000cc	8b 45 f4	 mov	 eax, DWORD PTR _pCurrPos$[ebp]
  000cf	83 e8 01	 sub	 eax, 1
  000d2	89 45 f4	 mov	 DWORD PTR _pCurrPos$[ebp], eax
$LN15@get_user_s:

; 84   : 					}
; 85   : 					GotoPrev();

  000d5	e8 00 00 00 00	 call	 _GotoPrev

; 86   : 					break;

  000da	eb 45		 jmp	 SHORT $LN4@get_user_s
$LN16@get_user_s:

; 87   : 				default:
; 88   : 					/* Save the key stroke into buffer,reserve one byte for terminator(0). */
; 89   : 					if ((DWORD)(pCurrPos - pDataBuffer) < dwDefaultSize - 1)

  000dc	8b 4d f4	 mov	 ecx, DWORD PTR _pCurrPos$[ebp]
  000df	2b 4d f0	 sub	 ecx, DWORD PTR _pDataBuffer$[ebp]
  000e2	8b 55 e8	 mov	 edx, DWORD PTR _dwDefaultSize$[ebp]
  000e5	83 ea 01	 sub	 edx, 1
  000e8	3b ca		 cmp	 ecx, edx
  000ea	73 35		 jae	 SHORT $LN4@get_user_s

; 90   : 					{
; 91   : 						*pCurrPos++ = bt;

  000ec	8b 45 f4	 mov	 eax, DWORD PTR _pCurrPos$[ebp]
  000ef	8a 4d ff	 mov	 cl, BYTE PTR _bt$[ebp]
  000f2	88 08		 mov	 BYTE PTR [eax], cl
  000f4	8b 55 f4	 mov	 edx, DWORD PTR _pCurrPos$[ebp]
  000f7	83 c2 01	 add	 edx, 1
  000fa	89 55 f4	 mov	 DWORD PTR _pCurrPos$[ebp], edx

; 92   : 						wr += bt;

  000fd	0f be 45 ff	 movsx	 eax, BYTE PTR _bt$[ebp]
  00101	0f b7 4d f8	 movzx	 ecx, WORD PTR _wr$[ebp]
  00105	03 c8		 add	 ecx, eax
  00107	66 89 4d f8	 mov	 WORD PTR _wr$[ebp], cx

; 93   : 						PrintChar(wr);

  0010b	0f b7 55 f8	 movzx	 edx, WORD PTR _wr$[ebp]
  0010f	52		 push	 edx
  00110	e8 00 00 00 00	 call	 _PrintChar
  00115	83 c4 04	 add	 esp, 4

; 94   : 						wr = 0x0700;

  00118	b8 00 07 00 00	 mov	 eax, 1792		; 00000700H
  0011d	66 89 45 f8	 mov	 WORD PTR _wr$[ebp], ax
$LN4@get_user_s:

; 95   : 					}
; 96   : 					break;
; 97   : 				}
; 98   : 			}

  00121	eb 44		 jmp	 SHORT $LN8@get_user_s
$LN9@get_user_s:

; 99   : 			else
; 100  : 			{
; 101  : 				if (KERNEL_MESSAGE_VKDOWN == Msg.wCommand)

  00123	0f b7 4d d8	 movzx	 ecx, WORD PTR _Msg$[ebp]
  00127	81 f9 cb 00 00
	00		 cmp	 ecx, 203		; 000000cbH
  0012d	75 16		 jne	 SHORT $LN18@get_user_s

; 102  : 				{
; 103  : 					bt = (BYTE)Msg.dwParam;

  0012f	8a 55 dc	 mov	 dl, BYTE PTR _Msg$[ebp+4]
  00132	88 55 ff	 mov	 BYTE PTR _bt$[ebp], dl

; 104  : 					if (VK_CONTROL == bt)

  00135	0f be 45 ff	 movsx	 eax, BYTE PTR _bt$[ebp]
  00139	83 f8 11	 cmp	 eax, 17			; 00000011H
  0013c	75 07		 jne	 SHORT $LN18@get_user_s

; 105  : 					{
; 106  : 						bCtrlDown = TRUE;

  0013e	c7 45 e4 ff ff
	ff ff		 mov	 DWORD PTR _bCtrlDown$[ebp], -1
$LN18@get_user_s:

; 107  : 					}
; 108  : 				}
; 109  : 				if (KERNEL_MESSAGE_VKUP == Msg.wCommand)

  00145	0f b7 4d d8	 movzx	 ecx, WORD PTR _Msg$[ebp]
  00149	81 f9 cc 00 00
	00		 cmp	 ecx, 204		; 000000ccH
  0014f	75 16		 jne	 SHORT $LN8@get_user_s

; 110  : 				{
; 111  : 					bt = (BYTE)Msg.dwParam;

  00151	8a 55 dc	 mov	 dl, BYTE PTR _Msg$[ebp+4]
  00154	88 55 ff	 mov	 BYTE PTR _bt$[ebp], dl

; 112  : 					if (VK_CONTROL == bt)    //Control key up.

  00157	0f be 45 ff	 movsx	 eax, BYTE PTR _bt$[ebp]
  0015b	83 f8 11	 cmp	 eax, 17			; 00000011H
  0015e	75 07		 jne	 SHORT $LN8@get_user_s

; 113  : 					{
; 114  : 						bCtrlDown = FALSE;

  00160	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _bCtrlDown$[ebp], 0
$LN8@get_user_s:

; 115  : 					}
; 116  : 				}
; 117  : 			}
; 118  : 		}
; 119  : 	}

  00167	e9 db fe ff ff	 jmp	 $LN2@get_user_s
$__TERMINAL$23:

; 120  : 
; 121  : __TERMINAL:
; 122  : 	return ret;

  0016c	8b 45 e0	 mov	 eax, DWORD PTR _ret$[ebp]

; 123  : }

  0016f	8b e5		 mov	 esp, ebp
  00171	5d		 pop	 ebp
  00172	c3		 ret	 0
_get_user_stroke ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\hellox\cli.c
;	COMDAT _ShowPrompt
_TEXT	SEGMENT
_ShowPrompt PROC					; COMDAT

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 32   : 	_hx_printf("[%s]", prompt_string);

  00003	68 00 00 00 00	 push	 OFFSET _prompt_string
  00008	68 00 00 00 00	 push	 OFFSET $SG4722
  0000d	e8 00 00 00 00	 call	 __hx_printf
  00012	83 c4 08	 add	 esp, 8

; 33   : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
_ShowPrompt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\hellox\cli.c
;	COMDAT _getcmd
_TEXT	SEGMENT
_ret$ = -16						; size = 4
_cmd_len$ = -12						; size = 4
_pCmdPos$ = -8						; size = 4
_byParamPos$ = -2					; size = 1
_byParamNum$ = -1					; size = 1
_argv$ = 8						; size = 4
_argc$ = 12						; size = 4
_getcmd	PROC						; COMDAT

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 128  : 	int ret = 0;

  00006	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 129  : 	int cmd_len = 0;

  0000d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _cmd_len$[ebp], 0

; 130  : 
; 131  : 	if ((NULL == argv) || (argc <= 0))

  00014	83 7d 08 00	 cmp	 DWORD PTR _argv$[ebp], 0
  00018	74 06		 je	 SHORT $LN7@getcmd
  0001a	83 7d 0c 00	 cmp	 DWORD PTR _argc$[ebp], 0
  0001e	7f 05		 jg	 SHORT $LN6@getcmd
$LN7@getcmd:

; 132  : 	{
; 133  : 		goto __TERMINAL;

  00020	e9 1e 01 00 00	 jmp	 $__TERMINAL$18
$LN6@getcmd:

; 134  : 	}
; 135  : 	if (argc > CMD_PARAMETER_COUNT)

  00025	83 7d 0c 10	 cmp	 DWORD PTR _argc$[ebp], 16 ; 00000010H
  00029	7e 05		 jle	 SHORT $LN8@getcmd

; 136  : 	{
; 137  : 		goto __TERMINAL;

  0002b	e9 13 01 00 00	 jmp	 $__TERMINAL$18
$LN8@getcmd:

; 138  : 	}
; 139  : 
; 140  : 	/* Allocate command buffer if the routine is called at first time. */
; 141  : 	if (NULL == cmd_buffer)

  00030	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cmd_buffer, 0
  00037	75 20		 jne	 SHORT $LN9@getcmd

; 142  : 	{
; 143  : 		cmd_buffer = (char*)_hx_malloc(CMD_BUFFER_LENGTH);

  00039	68 10 04 00 00	 push	 1040			; 00000410H
  0003e	e8 00 00 00 00	 call	 __hx_malloc
  00043	83 c4 04	 add	 esp, 4
  00046	a3 00 00 00 00	 mov	 DWORD PTR _cmd_buffer, eax

; 144  : 		if (NULL == cmd_buffer)

  0004b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _cmd_buffer, 0
  00052	75 05		 jne	 SHORT $LN9@getcmd

; 145  : 		{
; 146  : 			goto __TERMINAL;

  00054	e9 ea 00 00 00	 jmp	 $__TERMINAL$18
$LN9@getcmd:

; 147  : 		}
; 148  : 	}
; 149  : 	/* Show command prompt. */
; 150  : 	ShowPrompt();

  00059	e8 00 00 00 00	 call	 _ShowPrompt

; 151  : 	/* Get command string. */
; 152  : 	cmd_len = get_user_stroke(cmd_buffer, CMD_BUFFER_LENGTH);

  0005e	68 10 04 00 00	 push	 1040			; 00000410H
  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR _cmd_buffer
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 _get_user_stroke
  0006e	83 c4 08	 add	 esp, 8
  00071	89 45 f4	 mov	 DWORD PTR _cmd_len$[ebp], eax

; 153  : 	if (cmd_len < 0)

  00074	83 7d f4 00	 cmp	 DWORD PTR _cmd_len$[ebp], 0
  00078	7d 05		 jge	 SHORT $LN11@getcmd

; 154  : 	{
; 155  : 		/* No user input. */
; 156  : 		goto __TERMINAL;

  0007a	e9 c4 00 00 00	 jmp	 $__TERMINAL$18
$LN11@getcmd:

; 157  : 	}
; 158  : 	/* Splitter the command buffer into string parameters. */
; 159  : 	char byParamNum = 0, byParamPos = 0;

  0007f	c6 45 ff 00	 mov	 BYTE PTR _byParamNum$[ebp], 0
  00083	c6 45 fe 00	 mov	 BYTE PTR _byParamPos$[ebp], 0

; 160  : 	char* pCmdPos = cmd_buffer;

  00087	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _cmd_buffer
  0008d	89 4d f8	 mov	 DWORD PTR _pCmdPos$[ebp], ecx
$LN2@getcmd:

; 161  : 	while (*pCmdPos)

  00090	8b 55 f8	 mov	 edx, DWORD PTR _pCmdPos$[ebp]
  00093	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00096	85 c0		 test	 eax, eax
  00098	0f 84 9e 00 00
	00		 je	 $LN3@getcmd

; 162  : 	{
; 163  : 		/* Skip the leading space char in command string. */
; 164  : 		if (' ' == *pCmdPos)

  0009e	8b 4d f8	 mov	 ecx, DWORD PTR _pCmdPos$[ebp]
  000a1	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000a4	83 fa 20	 cmp	 edx, 32			; 00000020H
  000a7	75 0b		 jne	 SHORT $LN12@getcmd

; 165  : 		{
; 166  : 			pCmdPos++;

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _pCmdPos$[ebp]
  000ac	83 c0 01	 add	 eax, 1
  000af	89 45 f8	 mov	 DWORD PTR _pCmdPos$[ebp], eax

; 167  : 			continue;

  000b2	eb dc		 jmp	 SHORT $LN2@getcmd
$LN12@getcmd:

; 168  : 		}
; 169  : 
; 170  : 		/* Save the parameter into argv. */
; 171  : 		argv[byParamNum] = pCmdPos;

  000b4	0f be 4d ff	 movsx	 ecx, BYTE PTR _byParamNum$[ebp]
  000b8	8b 55 08	 mov	 edx, DWORD PTR _argv$[ebp]
  000bb	8b 45 f8	 mov	 eax, DWORD PTR _pCmdPos$[ebp]
  000be	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
$LN4@getcmd:

; 172  : 		while ((' ' != *pCmdPos) && (*pCmdPos) && (byParamPos < CMD_PARAMETER_LEN))

  000c1	8b 4d f8	 mov	 ecx, DWORD PTR _pCmdPos$[ebp]
  000c4	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000c7	83 fa 20	 cmp	 edx, 32			; 00000020H
  000ca	74 27		 je	 SHORT $LN5@getcmd
  000cc	8b 45 f8	 mov	 eax, DWORD PTR _pCmdPos$[ebp]
  000cf	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000d2	85 c9		 test	 ecx, ecx
  000d4	74 1d		 je	 SHORT $LN5@getcmd
  000d6	0f be 55 fe	 movsx	 edx, BYTE PTR _byParamPos$[ebp]
  000da	83 fa 40	 cmp	 edx, 64			; 00000040H
  000dd	7d 14		 jge	 SHORT $LN5@getcmd

; 173  : 		{
; 174  : 			pCmdPos++;

  000df	8b 45 f8	 mov	 eax, DWORD PTR _pCmdPos$[ebp]
  000e2	83 c0 01	 add	 eax, 1
  000e5	89 45 f8	 mov	 DWORD PTR _pCmdPos$[ebp], eax

; 175  : 			byParamPos++;

  000e8	8a 4d fe	 mov	 cl, BYTE PTR _byParamPos$[ebp]
  000eb	80 c1 01	 add	 cl, 1
  000ee	88 4d fe	 mov	 BYTE PTR _byParamPos$[ebp], cl

; 176  : 		}

  000f1	eb ce		 jmp	 SHORT $LN4@getcmd
$LN5@getcmd:

; 177  : 		byParamNum++;

  000f3	8a 55 ff	 mov	 dl, BYTE PTR _byParamNum$[ebp]
  000f6	80 c2 01	 add	 dl, 1
  000f9	88 55 ff	 mov	 BYTE PTR _byParamNum$[ebp], dl

; 178  : 		byParamPos = 0;

  000fc	c6 45 fe 00	 mov	 BYTE PTR _byParamPos$[ebp], 0

; 179  : 		if (' ' != *pCmdPos)

  00100	8b 45 f8	 mov	 eax, DWORD PTR _pCmdPos$[ebp]
  00103	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00106	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00109	74 12		 je	 SHORT $LN13@getcmd

; 180  : 		{
; 181  : 			if (*pCmdPos)

  0010b	8b 55 f8	 mov	 edx, DWORD PTR _pCmdPos$[ebp]
  0010e	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00111	85 c0		 test	 eax, eax
  00113	74 06		 je	 SHORT $LN14@getcmd

; 182  : 			{
; 183  : 				*pCmdPos = 0; /* Set terminator. */

  00115	8b 4d f8	 mov	 ecx, DWORD PTR _pCmdPos$[ebp]
  00118	c6 01 00	 mov	 BYTE PTR [ecx], 0
$LN14@getcmd:

; 184  : 			}
; 185  : 			break;

  0011b	eb 1f		 jmp	 SHORT $LN3@getcmd
$LN13@getcmd:

; 186  : 		}
; 187  : 		*pCmdPos++ = '\0';

  0011d	8b 55 f8	 mov	 edx, DWORD PTR _pCmdPos$[ebp]
  00120	c6 02 00	 mov	 BYTE PTR [edx], 0
  00123	8b 45 f8	 mov	 eax, DWORD PTR _pCmdPos$[ebp]
  00126	83 c0 01	 add	 eax, 1
  00129	89 45 f8	 mov	 DWORD PTR _pCmdPos$[ebp], eax

; 188  : 
; 189  : 		if (byParamNum == argc)

  0012c	0f be 4d ff	 movsx	 ecx, BYTE PTR _byParamNum$[ebp]
  00130	3b 4d 0c	 cmp	 ecx, DWORD PTR _argc$[ebp]
  00133	75 02		 jne	 SHORT $LN15@getcmd

; 190  : 		{
; 191  : 			break;

  00135	eb 05		 jmp	 SHORT $LN3@getcmd
$LN15@getcmd:

; 192  : 		}
; 193  : 	}

  00137	e9 54 ff ff ff	 jmp	 $LN2@getcmd
$LN3@getcmd:

; 194  : 	ret = byParamNum;

  0013c	0f be 55 ff	 movsx	 edx, BYTE PTR _byParamNum$[ebp]
  00140	89 55 f0	 mov	 DWORD PTR _ret$[ebp], edx
$__TERMINAL$18:

; 195  : 
; 196  : __TERMINAL:
; 197  : 	return ret;

  00143	8b 45 f0	 mov	 eax, DWORD PTR _ret$[ebp]

; 198  : }

  00146	8b e5		 mov	 esp, ebp
  00148	5d		 pop	 ebp
  00149	c3		 ret	 0
_getcmd	ENDP
_TEXT	ENDS
END
