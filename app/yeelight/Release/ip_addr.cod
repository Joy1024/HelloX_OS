; Listing generated by Microsoft (R) Optimizing Compiler Version 19.13.26128.0 

	TITLE	C:\HelloX\personal\HelloX_OS\app\yeelight\hxlib\ip_addr.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_ip_addr_any
PUBLIC	_ip_addr_broadcast
CONST	SEGMENT
_ip_addr_any DD	00H
_ip_addr_broadcast DD 0ffffffffH
CONST	ENDS
PUBLIC	_ip4_addr_netmask_valid
PUBLIC	_ipaddr_addr
PUBLIC	_ipaddr_aton
PUBLIC	_ipaddr_ntoa
PUBLIC	_ipaddr_ntoa_r
EXTRN	__hx_htonl:PROC
_BSS	SEGMENT
?str@?1??ipaddr_ntoa@@9@9 DB 010H DUP (?)		; `ipaddr_ntoa'::`2'::str
_BSS	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\ip_addr.c
;	COMDAT _ipaddr_ntoa_r
_TEXT	SEGMENT
tv130 = -44						; size = 4
tv129 = -40						; size = 4
tv90 = -36						; size = 4
tv89 = -32						; size = 4
tv86 = -28						; size = 4
_s_addr$ = -24						; size = 4
_ap$ = -20						; size = 4
_len$ = -16						; size = 4
_rp$ = -12						; size = 4
_inv$ = -8						; size = 3
_rem$ = -3						; size = 1
_n$ = -2						; size = 1
_i$ = -1						; size = 1
_addr$ = 8						; size = 4
_buf$ = 12						; size = 4
_buflen$ = 16						; size = 4
_ipaddr_ntoa_r PROC					; COMDAT

; 287  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 288  : 	u32_t s_addr;
; 289  : 	char inv[3];
; 290  : 	char *rp;
; 291  : 	u8_t *ap;
; 292  : 	u8_t rem;
; 293  : 	u8_t n;
; 294  : 	u8_t i;
; 295  : 	int len = 0;

  00006	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 296  : 
; 297  : 	s_addr = ip4_addr_get_u32(addr);

  0000d	8b 45 08	 mov	 eax, DWORD PTR _addr$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	89 4d e8	 mov	 DWORD PTR _s_addr$[ebp], ecx

; 298  : 
; 299  : 	rp = buf;

  00015	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00018	89 55 f4	 mov	 DWORD PTR _rp$[ebp], edx

; 300  : 	ap = (u8_t *)&s_addr;

  0001b	8d 45 e8	 lea	 eax, DWORD PTR _s_addr$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _ap$[ebp], eax

; 301  : 	for (n = 0; n < 4; n++) {

  00021	c6 45 fe 00	 mov	 BYTE PTR _n$[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN4@ipaddr_nto
$LN2@ipaddr_nto:
  00027	8a 4d fe	 mov	 cl, BYTE PTR _n$[ebp]
  0002a	80 c1 01	 add	 cl, 1
  0002d	88 4d fe	 mov	 BYTE PTR _n$[ebp], cl
$LN4@ipaddr_nto:
  00030	0f b6 55 fe	 movzx	 edx, BYTE PTR _n$[ebp]
  00034	83 fa 04	 cmp	 edx, 4
  00037	0f 8d d6 00 00
	00		 jge	 $LN3@ipaddr_nto

; 302  : 		i = 0;

  0003d	c6 45 ff 00	 mov	 BYTE PTR _i$[ebp], 0
$LN7@ipaddr_nto:

; 303  : 		do {
; 304  : 			rem = *ap % (u8_t)10;

  00041	8b 45 ec	 mov	 eax, DWORD PTR _ap$[ebp]
  00044	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00047	99		 cdq
  00048	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0004d	f7 f9		 idiv	 ecx
  0004f	88 55 fd	 mov	 BYTE PTR _rem$[ebp], dl

; 305  : 			*ap /= (u8_t)10;

  00052	8b 55 ec	 mov	 edx, DWORD PTR _ap$[ebp]
  00055	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00058	99		 cdq
  00059	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0005e	f7 f9		 idiv	 ecx
  00060	8b 55 ec	 mov	 edx, DWORD PTR _ap$[ebp]
  00063	88 02		 mov	 BYTE PTR [edx], al

; 306  : 			inv[i++] = '0' + rem;

  00065	0f b6 45 fd	 movzx	 eax, BYTE PTR _rem$[ebp]
  00069	83 c0 30	 add	 eax, 48			; 00000030H
  0006c	0f b6 4d ff	 movzx	 ecx, BYTE PTR _i$[ebp]
  00070	88 44 0d f8	 mov	 BYTE PTR _inv$[ebp+ecx], al
  00074	8a 55 ff	 mov	 dl, BYTE PTR _i$[ebp]
  00077	80 c2 01	 add	 dl, 1
  0007a	88 55 ff	 mov	 BYTE PTR _i$[ebp], dl

; 307  : 		} while (*ap);

  0007d	8b 45 ec	 mov	 eax, DWORD PTR _ap$[ebp]
  00080	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00083	85 c9		 test	 ecx, ecx
  00085	75 ba		 jne	 SHORT $LN7@ipaddr_nto
$LN8@ipaddr_nto:

; 308  : 		while (i--) {

  00087	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$[ebp]
  0008b	89 55 e4	 mov	 DWORD PTR tv86[ebp], edx
  0008e	8a 45 ff	 mov	 al, BYTE PTR _i$[ebp]
  00091	2c 01		 sub	 al, 1
  00093	88 45 ff	 mov	 BYTE PTR _i$[ebp], al
  00096	83 7d e4 00	 cmp	 DWORD PTR tv86[ebp], 0
  0009a	74 39		 je	 SHORT $LN9@ipaddr_nto

; 309  : 			if (len++ >= buflen) {

  0009c	8b 4d f0	 mov	 ecx, DWORD PTR _len$[ebp]
  0009f	89 4d e0	 mov	 DWORD PTR tv89[ebp], ecx
  000a2	8b 55 10	 mov	 edx, DWORD PTR _buflen$[ebp]
  000a5	89 55 dc	 mov	 DWORD PTR tv90[ebp], edx
  000a8	8b 45 f0	 mov	 eax, DWORD PTR _len$[ebp]
  000ab	83 c0 01	 add	 eax, 1
  000ae	89 45 f0	 mov	 DWORD PTR _len$[ebp], eax
  000b1	8b 4d e0	 mov	 ecx, DWORD PTR tv89[ebp]
  000b4	3b 4d dc	 cmp	 ecx, DWORD PTR tv90[ebp]
  000b7	7c 04		 jl	 SHORT $LN10@ipaddr_nto

; 310  : 				return NULL;

  000b9	33 c0		 xor	 eax, eax
  000bb	eb 68		 jmp	 SHORT $LN1@ipaddr_nto
$LN10@ipaddr_nto:

; 311  : 			}
; 312  : 			*rp++ = inv[i];

  000bd	0f b6 55 ff	 movzx	 edx, BYTE PTR _i$[ebp]
  000c1	8b 45 f4	 mov	 eax, DWORD PTR _rp$[ebp]
  000c4	8a 4c 15 f8	 mov	 cl, BYTE PTR _inv$[ebp+edx]
  000c8	88 08		 mov	 BYTE PTR [eax], cl
  000ca	8b 55 f4	 mov	 edx, DWORD PTR _rp$[ebp]
  000cd	83 c2 01	 add	 edx, 1
  000d0	89 55 f4	 mov	 DWORD PTR _rp$[ebp], edx

; 313  : 		}

  000d3	eb b2		 jmp	 SHORT $LN8@ipaddr_nto
$LN9@ipaddr_nto:

; 314  : 		if (len++ >= buflen) {

  000d5	8b 45 f0	 mov	 eax, DWORD PTR _len$[ebp]
  000d8	89 45 d8	 mov	 DWORD PTR tv129[ebp], eax
  000db	8b 4d 10	 mov	 ecx, DWORD PTR _buflen$[ebp]
  000de	89 4d d4	 mov	 DWORD PTR tv130[ebp], ecx
  000e1	8b 55 f0	 mov	 edx, DWORD PTR _len$[ebp]
  000e4	83 c2 01	 add	 edx, 1
  000e7	89 55 f0	 mov	 DWORD PTR _len$[ebp], edx
  000ea	8b 45 d8	 mov	 eax, DWORD PTR tv129[ebp]
  000ed	3b 45 d4	 cmp	 eax, DWORD PTR tv130[ebp]
  000f0	7c 04		 jl	 SHORT $LN11@ipaddr_nto

; 315  : 			return NULL;

  000f2	33 c0		 xor	 eax, eax
  000f4	eb 2f		 jmp	 SHORT $LN1@ipaddr_nto
$LN11@ipaddr_nto:

; 316  : 		}
; 317  : 		*rp++ = '.';

  000f6	8b 4d f4	 mov	 ecx, DWORD PTR _rp$[ebp]
  000f9	c6 01 2e	 mov	 BYTE PTR [ecx], 46	; 0000002eH
  000fc	8b 55 f4	 mov	 edx, DWORD PTR _rp$[ebp]
  000ff	83 c2 01	 add	 edx, 1
  00102	89 55 f4	 mov	 DWORD PTR _rp$[ebp], edx

; 318  : 		ap++;

  00105	8b 45 ec	 mov	 eax, DWORD PTR _ap$[ebp]
  00108	83 c0 01	 add	 eax, 1
  0010b	89 45 ec	 mov	 DWORD PTR _ap$[ebp], eax

; 319  : 	}

  0010e	e9 14 ff ff ff	 jmp	 $LN2@ipaddr_nto
$LN3@ipaddr_nto:

; 320  : 	*--rp = 0;

  00113	8b 4d f4	 mov	 ecx, DWORD PTR _rp$[ebp]
  00116	83 e9 01	 sub	 ecx, 1
  00119	89 4d f4	 mov	 DWORD PTR _rp$[ebp], ecx
  0011c	8b 55 f4	 mov	 edx, DWORD PTR _rp$[ebp]
  0011f	c6 02 00	 mov	 BYTE PTR [edx], 0

; 321  : 	return buf;

  00122	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
$LN1@ipaddr_nto:

; 322  : }

  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c3		 ret	 0
_ipaddr_ntoa_r ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\ip_addr.c
;	COMDAT _ipaddr_ntoa
_TEXT	SEGMENT
_addr$ = 8						; size = 4
_ipaddr_ntoa PROC					; COMDAT

; 272  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 273  : 	static char str[16];
; 274  : 	return ipaddr_ntoa_r(addr, str, 16);

  00003	6a 10		 push	 16			; 00000010H
  00005	68 00 00 00 00	 push	 OFFSET ?str@?1??ipaddr_ntoa@@9@9
  0000a	8b 45 08	 mov	 eax, DWORD PTR _addr$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 _ipaddr_ntoa_r
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH

; 275  : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
_ipaddr_ntoa ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\ip_addr.c
;	COMDAT _ipaddr_aton
_TEXT	SEGMENT
_parts$ = -36						; size = 16
tv166 = -20						; size = 4
tv139 = -16						; size = 4
_pp$ = -12						; size = 4
_val$ = -8						; size = 4
_base$ = -2						; size = 1
_c$ = -1						; size = 1
_cp$ = 8						; size = 4
_addr$ = 12						; size = 4
_ipaddr_aton PROC					; COMDAT

; 159  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 160  : 	u32_t val;
; 161  : 	u8_t base;
; 162  : 	char c;
; 163  : 	u32_t parts[4];
; 164  : 	u32_t *pp = parts;

  00006	8d 45 dc	 lea	 eax, DWORD PTR _parts$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR _pp$[ebp], eax

; 165  : 
; 166  : 	c = *cp;

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _cp$[ebp]
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 55 ff	 mov	 BYTE PTR _c$[ebp], dl
$LN4@ipaddr_ato:

; 167  : 	for (;;) {
; 168  : 		/*
; 169  : 		* Collect number up to ``.''.
; 170  : 		* Values are specified as for C:
; 171  : 		* 0x=hex, 0=octal, 1-9=decimal.
; 172  : 		*/
; 173  : 		if (!isdigit(c))

  00014	0f b6 45 ff	 movzx	 eax, BYTE PTR _c$[ebp]
  00018	83 f8 30	 cmp	 eax, 48			; 00000030H
  0001b	7c 09		 jl	 SHORT $LN11@ipaddr_ato
  0001d	0f b6 4d ff	 movzx	 ecx, BYTE PTR _c$[ebp]
  00021	83 f9 39	 cmp	 ecx, 57			; 00000039H
  00024	7e 07		 jle	 SHORT $LN10@ipaddr_ato
$LN11@ipaddr_ato:

; 174  : 			return (0);

  00026	33 c0		 xor	 eax, eax
  00028	e9 98 02 00 00	 jmp	 $LN1@ipaddr_ato
$LN10@ipaddr_ato:

; 175  : 		val = 0;

  0002d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _val$[ebp], 0

; 176  : 		base = 10;

  00034	c6 45 fe 0a	 mov	 BYTE PTR _base$[ebp], 10 ; 0000000aH

; 177  : 		if (c == '0') {

  00038	0f be 55 ff	 movsx	 edx, BYTE PTR _c$[ebp]
  0003c	83 fa 30	 cmp	 edx, 48			; 00000030H
  0003f	75 3e		 jne	 SHORT $LN7@ipaddr_ato

; 178  : 			c = *++cp;

  00041	8b 45 08	 mov	 eax, DWORD PTR _cp$[ebp]
  00044	83 c0 01	 add	 eax, 1
  00047	89 45 08	 mov	 DWORD PTR _cp$[ebp], eax
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _cp$[ebp]
  0004d	8a 11		 mov	 dl, BYTE PTR [ecx]
  0004f	88 55 ff	 mov	 BYTE PTR _c$[ebp], dl

; 179  : 			if (c == 'x' || c == 'X') {

  00052	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  00056	83 f8 78	 cmp	 eax, 120		; 00000078H
  00059	74 09		 je	 SHORT $LN15@ipaddr_ato
  0005b	0f be 4d ff	 movsx	 ecx, BYTE PTR _c$[ebp]
  0005f	83 f9 58	 cmp	 ecx, 88			; 00000058H
  00062	75 17		 jne	 SHORT $LN13@ipaddr_ato
$LN15@ipaddr_ato:

; 180  : 				base = 16;

  00064	c6 45 fe 10	 mov	 BYTE PTR _base$[ebp], 16 ; 00000010H

; 181  : 				c = *++cp;

  00068	8b 55 08	 mov	 edx, DWORD PTR _cp$[ebp]
  0006b	83 c2 01	 add	 edx, 1
  0006e	89 55 08	 mov	 DWORD PTR _cp$[ebp], edx
  00071	8b 45 08	 mov	 eax, DWORD PTR _cp$[ebp]
  00074	8a 08		 mov	 cl, BYTE PTR [eax]
  00076	88 4d ff	 mov	 BYTE PTR _c$[ebp], cl

; 182  : 			}

  00079	eb 04		 jmp	 SHORT $LN7@ipaddr_ato
$LN13@ipaddr_ato:

; 183  : 			else
; 184  : 				base = 8;

  0007b	c6 45 fe 08	 mov	 BYTE PTR _base$[ebp], 8
$LN7@ipaddr_ato:

; 185  : 		}
; 186  : 		for (;;) {
; 187  : 			if (isdigit(c)) {

  0007f	0f b6 55 ff	 movzx	 edx, BYTE PTR _c$[ebp]
  00083	83 fa 30	 cmp	 edx, 48			; 00000030H
  00086	7c 32		 jl	 SHORT $LN16@ipaddr_ato
  00088	0f b6 45 ff	 movzx	 eax, BYTE PTR _c$[ebp]
  0008c	83 f8 39	 cmp	 eax, 57			; 00000039H
  0008f	7f 29		 jg	 SHORT $LN16@ipaddr_ato

; 188  : 				val = (val * base) + (int)(c - '0');

  00091	0f b6 4d fe	 movzx	 ecx, BYTE PTR _base$[ebp]
  00095	0f af 4d f8	 imul	 ecx, DWORD PTR _val$[ebp]
  00099	0f be 55 ff	 movsx	 edx, BYTE PTR _c$[ebp]
  0009d	8d 44 11 d0	 lea	 eax, DWORD PTR [ecx+edx-48]
  000a1	89 45 f8	 mov	 DWORD PTR _val$[ebp], eax

; 189  : 				c = *++cp;

  000a4	8b 4d 08	 mov	 ecx, DWORD PTR _cp$[ebp]
  000a7	83 c1 01	 add	 ecx, 1
  000aa	89 4d 08	 mov	 DWORD PTR _cp$[ebp], ecx
  000ad	8b 55 08	 mov	 edx, DWORD PTR _cp$[ebp]
  000b0	8a 02		 mov	 al, BYTE PTR [edx]
  000b2	88 45 ff	 mov	 BYTE PTR _c$[ebp], al

; 190  : 			}

  000b5	e9 8f 00 00 00	 jmp	 $LN17@ipaddr_ato
$LN16@ipaddr_ato:

; 191  : 			else if (base == 16 && isxdigit(c)) {

  000ba	0f b6 4d fe	 movzx	 ecx, BYTE PTR _base$[ebp]
  000be	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000c1	0f 85 80 00 00
	00		 jne	 $LN18@ipaddr_ato
  000c7	0f b6 55 ff	 movzx	 edx, BYTE PTR _c$[ebp]
  000cb	83 fa 30	 cmp	 edx, 48			; 00000030H
  000ce	7c 09		 jl	 SHORT $LN21@ipaddr_ato
  000d0	0f b6 45 ff	 movzx	 eax, BYTE PTR _c$[ebp]
  000d4	83 f8 39	 cmp	 eax, 57			; 00000039H
  000d7	7e 24		 jle	 SHORT $LN20@ipaddr_ato
$LN21@ipaddr_ato:
  000d9	0f b6 4d ff	 movzx	 ecx, BYTE PTR _c$[ebp]
  000dd	83 f9 61	 cmp	 ecx, 97			; 00000061H
  000e0	7c 09		 jl	 SHORT $LN22@ipaddr_ato
  000e2	0f b6 55 ff	 movzx	 edx, BYTE PTR _c$[ebp]
  000e6	83 fa 66	 cmp	 edx, 102		; 00000066H
  000e9	7e 12		 jle	 SHORT $LN20@ipaddr_ato
$LN22@ipaddr_ato:
  000eb	0f b6 45 ff	 movzx	 eax, BYTE PTR _c$[ebp]
  000ef	83 f8 41	 cmp	 eax, 65			; 00000041H
  000f2	7c 53		 jl	 SHORT $LN18@ipaddr_ato
  000f4	0f b6 4d ff	 movzx	 ecx, BYTE PTR _c$[ebp]
  000f8	83 f9 46	 cmp	 ecx, 70			; 00000046H
  000fb	7f 4a		 jg	 SHORT $LN18@ipaddr_ato
$LN20@ipaddr_ato:

; 192  : 				val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));

  000fd	0f b6 55 ff	 movzx	 edx, BYTE PTR _c$[ebp]
  00101	83 fa 61	 cmp	 edx, 97			; 00000061H
  00104	7c 12		 jl	 SHORT $LN38@ipaddr_ato
  00106	0f b6 45 ff	 movzx	 eax, BYTE PTR _c$[ebp]
  0010a	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  0010d	7f 09		 jg	 SHORT $LN38@ipaddr_ato
  0010f	c7 45 f0 61 00
	00 00		 mov	 DWORD PTR tv139[ebp], 97 ; 00000061H
  00116	eb 07		 jmp	 SHORT $LN39@ipaddr_ato
$LN38@ipaddr_ato:
  00118	c7 45 f0 41 00
	00 00		 mov	 DWORD PTR tv139[ebp], 65 ; 00000041H
$LN39@ipaddr_ato:
  0011f	8b 4d f8	 mov	 ecx, DWORD PTR _val$[ebp]
  00122	c1 e1 04	 shl	 ecx, 4
  00125	0f be 55 ff	 movsx	 edx, BYTE PTR _c$[ebp]
  00129	83 c2 0a	 add	 edx, 10			; 0000000aH
  0012c	2b 55 f0	 sub	 edx, DWORD PTR tv139[ebp]
  0012f	0b ca		 or	 ecx, edx
  00131	89 4d f8	 mov	 DWORD PTR _val$[ebp], ecx

; 193  : 				c = *++cp;

  00134	8b 45 08	 mov	 eax, DWORD PTR _cp$[ebp]
  00137	83 c0 01	 add	 eax, 1
  0013a	89 45 08	 mov	 DWORD PTR _cp$[ebp], eax
  0013d	8b 4d 08	 mov	 ecx, DWORD PTR _cp$[ebp]
  00140	8a 11		 mov	 dl, BYTE PTR [ecx]
  00142	88 55 ff	 mov	 BYTE PTR _c$[ebp], dl

; 194  : 			}

  00145	eb 02		 jmp	 SHORT $LN17@ipaddr_ato
$LN18@ipaddr_ato:

; 195  : 			else
; 196  : 				break;

  00147	eb 05		 jmp	 SHORT $LN6@ipaddr_ato
$LN17@ipaddr_ato:

; 197  : 		}

  00149	e9 31 ff ff ff	 jmp	 $LN7@ipaddr_ato
$LN6@ipaddr_ato:

; 198  : 		if (c == '.') {

  0014e	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  00152	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00155	75 33		 jne	 SHORT $LN23@ipaddr_ato

; 199  : 			/*
; 200  : 			* Internet format:
; 201  : 			*  a.b.c.d
; 202  : 			*  a.b.c   (with c treated as 16 bits)
; 203  : 			*  a.b (with b treated as 24 bits)
; 204  : 			*/
; 205  : 			if (pp >= parts + 3) {

  00157	8d 4d e8	 lea	 ecx, DWORD PTR _parts$[ebp+12]
  0015a	39 4d f4	 cmp	 DWORD PTR _pp$[ebp], ecx
  0015d	72 07		 jb	 SHORT $LN25@ipaddr_ato

; 206  : 				return (0);

  0015f	33 c0		 xor	 eax, eax
  00161	e9 5f 01 00 00	 jmp	 $LN1@ipaddr_ato
$LN25@ipaddr_ato:

; 207  : 			}
; 208  : 			*pp++ = val;

  00166	8b 55 f4	 mov	 edx, DWORD PTR _pp$[ebp]
  00169	8b 45 f8	 mov	 eax, DWORD PTR _val$[ebp]
  0016c	89 02		 mov	 DWORD PTR [edx], eax
  0016e	8b 4d f4	 mov	 ecx, DWORD PTR _pp$[ebp]
  00171	83 c1 04	 add	 ecx, 4
  00174	89 4d f4	 mov	 DWORD PTR _pp$[ebp], ecx

; 209  : 			c = *++cp;

  00177	8b 55 08	 mov	 edx, DWORD PTR _cp$[ebp]
  0017a	83 c2 01	 add	 edx, 1
  0017d	89 55 08	 mov	 DWORD PTR _cp$[ebp], edx
  00180	8b 45 08	 mov	 eax, DWORD PTR _cp$[ebp]
  00183	8a 08		 mov	 cl, BYTE PTR [eax]
  00185	88 4d ff	 mov	 BYTE PTR _c$[ebp], cl

; 210  : 		}

  00188	eb 02		 jmp	 SHORT $LN24@ipaddr_ato
$LN23@ipaddr_ato:

; 211  : 		else
; 212  : 			break;

  0018a	eb 05		 jmp	 SHORT $LN3@ipaddr_ato
$LN24@ipaddr_ato:

; 213  : 	}

  0018c	e9 83 fe ff ff	 jmp	 $LN4@ipaddr_ato
$LN3@ipaddr_ato:

; 214  : 	/*
; 215  : 	* Check for trailing characters.
; 216  : 	*/
; 217  : 	if (c != '\0' && !isspace(c)) {

  00191	0f be 55 ff	 movsx	 edx, BYTE PTR _c$[ebp]
  00195	85 d2		 test	 edx, edx
  00197	74 3d		 je	 SHORT $LN26@ipaddr_ato
  00199	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  0019d	83 f8 20	 cmp	 eax, 32			; 00000020H
  001a0	74 34		 je	 SHORT $LN26@ipaddr_ato
  001a2	0f be 4d ff	 movsx	 ecx, BYTE PTR _c$[ebp]
  001a6	83 f9 0c	 cmp	 ecx, 12			; 0000000cH
  001a9	74 2b		 je	 SHORT $LN26@ipaddr_ato
  001ab	0f be 55 ff	 movsx	 edx, BYTE PTR _c$[ebp]
  001af	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  001b2	74 22		 je	 SHORT $LN26@ipaddr_ato
  001b4	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  001b8	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  001bb	74 19		 je	 SHORT $LN26@ipaddr_ato
  001bd	0f be 4d ff	 movsx	 ecx, BYTE PTR _c$[ebp]
  001c1	83 f9 09	 cmp	 ecx, 9
  001c4	74 10		 je	 SHORT $LN26@ipaddr_ato
  001c6	0f be 55 ff	 movsx	 edx, BYTE PTR _c$[ebp]
  001ca	83 fa 0b	 cmp	 edx, 11			; 0000000bH
  001cd	74 07		 je	 SHORT $LN26@ipaddr_ato

; 218  : 		return (0);

  001cf	33 c0		 xor	 eax, eax
  001d1	e9 ef 00 00 00	 jmp	 $LN1@ipaddr_ato
$LN26@ipaddr_ato:

; 219  : 	}
; 220  : 	/*
; 221  : 	* Concoct the address according to
; 222  : 	* the number of parts specified.
; 223  : 	*/
; 224  : 	switch (pp - parts + 1) {

  001d6	8b 45 f4	 mov	 eax, DWORD PTR _pp$[ebp]
  001d9	8d 4d dc	 lea	 ecx, DWORD PTR _parts$[ebp]
  001dc	2b c1		 sub	 eax, ecx
  001de	c1 f8 02	 sar	 eax, 2
  001e1	83 c0 01	 add	 eax, 1
  001e4	89 45 ec	 mov	 DWORD PTR tv166[ebp], eax
  001e7	83 7d ec 04	 cmp	 DWORD PTR tv166[ebp], 4
  001eb	0f 87 b8 00 00
	00		 ja	 $LN8@ipaddr_ato
  001f1	8b 55 ec	 mov	 edx, DWORD PTR tv166[ebp]
  001f4	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN40@ipaddr_ato[edx*4]
$LN27@ipaddr_ato:

; 225  : 
; 226  : 	case 0:
; 227  : 		return (0);       /* initial nondigit */

  001fb	33 c0		 xor	 eax, eax
  001fd	e9 c3 00 00 00	 jmp	 $LN1@ipaddr_ato

; 228  : 
; 229  : 	case 1:             /* a -- 32 bits */
; 230  : 		break;

  00202	e9 a2 00 00 00	 jmp	 $LN8@ipaddr_ato
$LN29@ipaddr_ato:

; 231  : 
; 232  : 	case 2:             /* a.b -- 8.24 bits */
; 233  : 		if (val > 0xffffffUL) {

  00207	81 7d f8 ff ff
	ff 00		 cmp	 DWORD PTR _val$[ebp], 16777215 ; 00ffffffH
  0020e	76 07		 jbe	 SHORT $LN30@ipaddr_ato

; 234  : 			return (0);

  00210	33 c0		 xor	 eax, eax
  00212	e9 ae 00 00 00	 jmp	 $LN1@ipaddr_ato
$LN30@ipaddr_ato:

; 235  : 		}
; 236  : 		val |= parts[0] << 24;

  00217	b8 04 00 00 00	 mov	 eax, 4
  0021c	6b c8 00	 imul	 ecx, eax, 0
  0021f	8b 54 0d dc	 mov	 edx, DWORD PTR _parts$[ebp+ecx]
  00223	c1 e2 18	 shl	 edx, 24			; 00000018H
  00226	0b 55 f8	 or	 edx, DWORD PTR _val$[ebp]
  00229	89 55 f8	 mov	 DWORD PTR _val$[ebp], edx

; 237  : 		break;

  0022c	eb 7b		 jmp	 SHORT $LN8@ipaddr_ato
$LN31@ipaddr_ato:

; 238  : 
; 239  : 	case 3:             /* a.b.c -- 8.8.16 bits */
; 240  : 		if (val > 0xffff) {

  0022e	81 7d f8 ff ff
	00 00		 cmp	 DWORD PTR _val$[ebp], 65535 ; 0000ffffH
  00235	76 07		 jbe	 SHORT $LN32@ipaddr_ato

; 241  : 			return (0);

  00237	33 c0		 xor	 eax, eax
  00239	e9 87 00 00 00	 jmp	 $LN1@ipaddr_ato
$LN32@ipaddr_ato:

; 242  : 		}
; 243  : 		val |= (parts[0] << 24) | (parts[1] << 16);

  0023e	b8 04 00 00 00	 mov	 eax, 4
  00243	6b c8 00	 imul	 ecx, eax, 0
  00246	8b 54 0d dc	 mov	 edx, DWORD PTR _parts$[ebp+ecx]
  0024a	c1 e2 18	 shl	 edx, 24			; 00000018H
  0024d	b8 04 00 00 00	 mov	 eax, 4
  00252	c1 e0 00	 shl	 eax, 0
  00255	8b 4c 05 dc	 mov	 ecx, DWORD PTR _parts$[ebp+eax]
  00259	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0025c	0b d1		 or	 edx, ecx
  0025e	0b 55 f8	 or	 edx, DWORD PTR _val$[ebp]
  00261	89 55 f8	 mov	 DWORD PTR _val$[ebp], edx

; 244  : 		break;

  00264	eb 43		 jmp	 SHORT $LN8@ipaddr_ato
$LN33@ipaddr_ato:

; 245  : 
; 246  : 	case 4:             /* a.b.c.d -- 8.8.8.8 bits */
; 247  : 		if (val > 0xff) {

  00266	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _val$[ebp], 255 ; 000000ffH
  0026d	76 04		 jbe	 SHORT $LN34@ipaddr_ato

; 248  : 			return (0);

  0026f	33 c0		 xor	 eax, eax
  00271	eb 52		 jmp	 SHORT $LN1@ipaddr_ato
$LN34@ipaddr_ato:

; 249  : 		}
; 250  : 		val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);

  00273	ba 04 00 00 00	 mov	 edx, 4
  00278	6b c2 00	 imul	 eax, edx, 0
  0027b	8b 4c 05 dc	 mov	 ecx, DWORD PTR _parts$[ebp+eax]
  0027f	c1 e1 18	 shl	 ecx, 24			; 00000018H
  00282	ba 04 00 00 00	 mov	 edx, 4
  00287	c1 e2 00	 shl	 edx, 0
  0028a	8b 44 15 dc	 mov	 eax, DWORD PTR _parts$[ebp+edx]
  0028e	c1 e0 10	 shl	 eax, 16			; 00000010H
  00291	0b c8		 or	 ecx, eax
  00293	ba 04 00 00 00	 mov	 edx, 4
  00298	d1 e2		 shl	 edx, 1
  0029a	8b 44 15 dc	 mov	 eax, DWORD PTR _parts$[ebp+edx]
  0029e	c1 e0 08	 shl	 eax, 8
  002a1	0b c8		 or	 ecx, eax
  002a3	0b 4d f8	 or	 ecx, DWORD PTR _val$[ebp]
  002a6	89 4d f8	 mov	 DWORD PTR _val$[ebp], ecx
$LN8@ipaddr_ato:

; 251  : 		break;
; 252  : 	default:
; 253  : 		//LWIP_ASSERT("unhandled", 0);
; 254  : 		break;
; 255  : 	}
; 256  : 	if (addr) {

  002a9	83 7d 0c 00	 cmp	 DWORD PTR _addr$[ebp], 0
  002ad	74 11		 je	 SHORT $LN36@ipaddr_ato

; 257  : 		ip4_addr_set_u32(addr, _hx_htonl(val));

  002af	8b 4d f8	 mov	 ecx, DWORD PTR _val$[ebp]
  002b2	51		 push	 ecx
  002b3	e8 00 00 00 00	 call	 __hx_htonl
  002b8	83 c4 04	 add	 esp, 4
  002bb	8b 55 0c	 mov	 edx, DWORD PTR _addr$[ebp]
  002be	89 02		 mov	 DWORD PTR [edx], eax
$LN36@ipaddr_ato:

; 258  : 	}
; 259  : 	return (1);

  002c0	b8 01 00 00 00	 mov	 eax, 1
$LN1@ipaddr_ato:

; 260  : }

  002c5	8b e5		 mov	 esp, ebp
  002c7	5d		 pop	 ebp
  002c8	c3		 ret	 0
  002c9	8d 49 00	 npad	 3
$LN40@ipaddr_ato:
  002cc	00 00 00 00	 DD	 $LN27@ipaddr_ato
  002d0	00 00 00 00	 DD	 $LN8@ipaddr_ato
  002d4	00 00 00 00	 DD	 $LN29@ipaddr_ato
  002d8	00 00 00 00	 DD	 $LN31@ipaddr_ato
  002dc	00 00 00 00	 DD	 $LN33@ipaddr_ato
_ipaddr_aton ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\ip_addr.c
;	COMDAT _ipaddr_addr
_TEXT	SEGMENT
_val$ = -4						; size = 4
_cp$ = 8						; size = 4
_ipaddr_addr PROC					; COMDAT

; 137  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 138  : 	ip_addr_t val;
; 139  : 
; 140  : 	if (ipaddr_aton(cp, &val)) {

  00004	8d 45 fc	 lea	 eax, DWORD PTR _val$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _cp$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 _ipaddr_aton
  00011	83 c4 08	 add	 esp, 8
  00014	85 c0		 test	 eax, eax
  00016	74 05		 je	 SHORT $LN2@ipaddr_add

; 141  : 		return ip4_addr_get_u32(&val);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _val$[ebp]
  0001b	eb 03		 jmp	 SHORT $LN1@ipaddr_add
$LN2@ipaddr_add:

; 142  : 	}
; 143  : 	return (IPADDR_NONE);

  0001d	83 c8 ff	 or	 eax, -1
$LN1@ipaddr_add:

; 144  : }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_ipaddr_addr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\ip_addr.c
;	COMDAT _ip4_addr_netmask_valid
_TEXT	SEGMENT
_nm_hostorder$ = -8					; size = 4
_mask$ = -4						; size = 4
_netmask$ = 8						; size = 4
_ip4_addr_netmask_valid PROC				; COMDAT

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 98   : 	u32_t mask;
; 99   : 	u32_t nm_hostorder = _hx_htonl(netmask);

  00006	8b 45 08	 mov	 eax, DWORD PTR _netmask$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 __hx_htonl
  0000f	83 c4 04	 add	 esp, 4
  00012	89 45 f8	 mov	 DWORD PTR _nm_hostorder$[ebp], eax

; 100  : 
; 101  : 	/* first, check for the first zero */
; 102  : 	for (mask = 1UL << 31; mask != 0; mask >>= 1) {

  00015	c7 45 fc 00 00
	00 80		 mov	 DWORD PTR _mask$[ebp], -2147483648 ; 80000000H
  0001c	eb 08		 jmp	 SHORT $LN4@ip4_addr_n
$LN2@ip4_addr_n:
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _mask$[ebp]
  00021	d1 e9		 shr	 ecx, 1
  00023	89 4d fc	 mov	 DWORD PTR _mask$[ebp], ecx
$LN4@ip4_addr_n:
  00026	83 7d fc 00	 cmp	 DWORD PTR _mask$[ebp], 0
  0002a	74 0c		 je	 SHORT $LN3@ip4_addr_n

; 103  : 		if ((nm_hostorder & mask) == 0) {

  0002c	8b 55 f8	 mov	 edx, DWORD PTR _nm_hostorder$[ebp]
  0002f	23 55 fc	 and	 edx, DWORD PTR _mask$[ebp]
  00032	75 02		 jne	 SHORT $LN8@ip4_addr_n

; 104  : 			break;

  00034	eb 02		 jmp	 SHORT $LN3@ip4_addr_n
$LN8@ip4_addr_n:

; 105  : 		}
; 106  : 	}

  00036	eb e6		 jmp	 SHORT $LN2@ip4_addr_n
$LN3@ip4_addr_n:

; 107  : 	/* then check that there is no one */
; 108  : 	for (; mask != 0; mask >>= 1) {

  00038	eb 08		 jmp	 SHORT $LN7@ip4_addr_n
$LN5@ip4_addr_n:
  0003a	8b 45 fc	 mov	 eax, DWORD PTR _mask$[ebp]
  0003d	d1 e8		 shr	 eax, 1
  0003f	89 45 fc	 mov	 DWORD PTR _mask$[ebp], eax
$LN7@ip4_addr_n:
  00042	83 7d fc 00	 cmp	 DWORD PTR _mask$[ebp], 0
  00046	74 0e		 je	 SHORT $LN6@ip4_addr_n

; 109  : 		if ((nm_hostorder & mask) != 0) {

  00048	8b 4d f8	 mov	 ecx, DWORD PTR _nm_hostorder$[ebp]
  0004b	23 4d fc	 and	 ecx, DWORD PTR _mask$[ebp]
  0004e	74 04		 je	 SHORT $LN9@ip4_addr_n

; 110  : 			/* there is a one after the first zero -> invalid */
; 111  : 			return 0;

  00050	32 c0		 xor	 al, al
  00052	eb 04		 jmp	 SHORT $LN1@ip4_addr_n
$LN9@ip4_addr_n:

; 112  : 		}
; 113  : 	}

  00054	eb e4		 jmp	 SHORT $LN5@ip4_addr_n
$LN6@ip4_addr_n:

; 114  : 	/* no one after the first zero -> valid */
; 115  : 	return 1;

  00056	b0 01		 mov	 al, 1
$LN1@ip4_addr_n:

; 116  : }

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_ip4_addr_netmask_valid ENDP
_TEXT	ENDS
END
