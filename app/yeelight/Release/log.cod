; Listing generated by Microsoft (R) Optimizing Compiler Version 19.13.26128.0 

	TITLE	C:\HelloX\personal\HelloX_OS\app\yeelight\hxlib\log.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_log
PUBLIC	__real@0000000000000000
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\log.c
;	COMDAT _log
_TEXT	SEGMENT
_x$ = 8							; size = 8
_log	PROC						; COMDAT

; 96   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 97   : 	//Implement later,since the code may has error.
; 98   : 	return 0.0;

  00003	d9 ee		 fldz

; 99   : #if 0
; 100  :   double hfsq, f, s, z, R, w, t1, t2, dk;
; 101  :   int k, hx, i, j;
; 102  :   unsigned lx;
; 103  : 
; 104  :   hx = __HI (x); /* high word of x */
; 105  :   lx = __LO (x); /* low  word of x */
; 106  : 
; 107  :   k = 0;
; 108  :   if (hx < 0x00100000) /* x < 2**-1022  */
; 109  :   {
; 110  :     if (((hx & 0x7fffffff) | lx) == 0) /* log(+-0) = -inf */
; 111  :     {
; 112  :       return -two54 / zero;
; 113  :     }
; 114  :     if (hx < 0) /* log(-#) = NaN */
; 115  :     {
; 116  :       return (x - x) / zero;
; 117  :     }
; 118  :     k -= 54;
; 119  :     x *= two54; /* subnormal number, scale up x */
; 120  :     hx = __HI (x); /* high word of x */
; 121  :   }
; 122  :   if (hx >= 0x7ff00000)
; 123  :   {
; 124  :     return x + x;
; 125  :   }
; 126  :   k += (hx >> 20) - 1023;
; 127  :   hx &= 0x000fffff;
; 128  :   i = (hx + 0x95f64) & 0x100000;
; 129  :   __HI (x) = hx | (i ^ 0x3ff00000); /* normalize x or x / 2 */
; 130  :   k += (i >> 20);
; 131  :   f = x - 1.0;
; 132  :   if ((0x000fffff & (2 + hx)) < 3) /* |f| < 2**-20 */
; 133  :   {
; 134  :     if (f == zero)
; 135  :     {
; 136  :       if (k == 0)
; 137  :       {
; 138  :         return zero;
; 139  :       }
; 140  :       else
; 141  :       {
; 142  :         dk = (double) k;
; 143  :         return dk * ln2_hi + dk * ln2_lo;
; 144  :       }
; 145  :     }
; 146  :     R = f * f * (0.5 - 0.33333333333333333 * f);
; 147  :     if (k == 0)
; 148  :     {
; 149  :       return f - R;
; 150  :     }
; 151  :     else
; 152  :     {
; 153  :       dk = (double) k;
; 154  :       return dk * ln2_hi - ((R - dk * ln2_lo) - f);
; 155  :     }
; 156  :   }
; 157  :   s = f / (2.0 + f);
; 158  :   dk = (double) k;
; 159  :   z = s * s;
; 160  :   i = hx - 0x6147a;
; 161  :   w = z * z;
; 162  :   j = 0x6b851 - hx;
; 163  :   t1 = w * (Lg2 + w * (Lg4 + w * Lg6));
; 164  :   t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));
; 165  :   i |= j;
; 166  :   R = t2 + t1;
; 167  :   if (i > 0)
; 168  :   {
; 169  :     hfsq = 0.5 * f * f;
; 170  :     if (k == 0)
; 171  :     {
; 172  :       return f - (hfsq - s * (hfsq + R));
; 173  :     }
; 174  :     else
; 175  :     {
; 176  :       return dk * ln2_hi - ((hfsq - (s * (hfsq + R) + dk * ln2_lo)) - f);
; 177  :     }
; 178  :   }
; 179  :   else
; 180  :   {
; 181  :     if (k == 0)
; 182  :     {
; 183  :       return f - s * (f - R);
; 184  :     }
; 185  :     else
; 186  :     {
; 187  :       return dk * ln2_hi - ((s * (f - R) - dk * ln2_lo) - f);
; 188  :     }
; 189  :   }
; 190  : #endif
; 191  : } /* log */

  00005	5d		 pop	 ebp
  00006	c3		 ret	 0
_log	ENDP
_TEXT	ENDS
END
