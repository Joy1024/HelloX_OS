; Listing generated by Microsoft (R) Optimizing Compiler Version 19.13.26128.0 

	TITLE	C:\HelloX\personal\HelloX_OS\app\yeelight\hxlib\memory.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_memcpy
PUBLIC	_memset
PUBLIC	_memzero
PUBLIC	_memcmp
PUBLIC	_memchr
PUBLIC	_memmove
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\memory.c
;	COMDAT _memmove
_TEXT	SEGMENT
tv80 = -16						; size = 4
tv72 = -12						; size = 4
_sp$ = -8						; size = 4
_dp$ = -4						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_n$ = 16						; size = 4
_memmove PROC						; COMDAT

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 70   :      char *dp = (char *)dst;

  00006	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _dp$[ebp], eax

; 71   :      char *sp = (char *)src; 

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  0000f	89 4d f8	 mov	 DWORD PTR _sp$[ebp], ecx

; 72   :      
; 73   : 	 if((NULL == dst) || (NULL == src) || (n <= 0))

  00012	83 7d 08 00	 cmp	 DWORD PTR _dst$[ebp], 0
  00016	74 0c		 je	 SHORT $LN7@memmove
  00018	83 7d 0c 00	 cmp	 DWORD PTR _src$[ebp], 0
  0001c	74 06		 je	 SHORT $LN7@memmove
  0001e	83 7d 10 00	 cmp	 DWORD PTR _n$[ebp], 0
  00022	7f 07		 jg	 SHORT $LN6@memmove
$LN7@memmove:

; 74   : 	 {
; 75   : 		 return NULL;

  00024	33 c0		 xor	 eax, eax
  00026	e9 a4 00 00 00	 jmp	 $LN1@memmove
$LN6@memmove:

; 76   : 	 }
; 77   : 
; 78   :      //Not overlaped.
; 79   :      if(sp>dp||(sp+n)<dp)

  0002b	8b 55 f8	 mov	 edx, DWORD PTR _sp$[ebp]
  0002e	3b 55 fc	 cmp	 edx, DWORD PTR _dp$[ebp]
  00031	77 0b		 ja	 SHORT $LN2@memmove
  00033	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  00036	03 45 10	 add	 eax, DWORD PTR _n$[ebp]
  00039	3b 45 fc	 cmp	 eax, DWORD PTR _dp$[ebp]
  0003c	73 3b		 jae	 SHORT $LN8@memmove
$LN2@memmove:

; 80   :      { 
; 81   :          while(n--) 

  0003e	8b 4d 10	 mov	 ecx, DWORD PTR _n$[ebp]
  00041	89 4d f4	 mov	 DWORD PTR tv72[ebp], ecx
  00044	8b 55 10	 mov	 edx, DWORD PTR _n$[ebp]
  00047	83 ea 01	 sub	 edx, 1
  0004a	89 55 10	 mov	 DWORD PTR _n$[ebp], edx
  0004d	83 7d f4 00	 cmp	 DWORD PTR tv72[ebp], 0
  00051	74 1e		 je	 SHORT $LN3@memmove

; 82   :              *(dp++) = *(sp++);

  00053	8b 45 fc	 mov	 eax, DWORD PTR _dp$[ebp]
  00056	8b 4d f8	 mov	 ecx, DWORD PTR _sp$[ebp]
  00059	8a 11		 mov	 dl, BYTE PTR [ecx]
  0005b	88 10		 mov	 BYTE PTR [eax], dl
  0005d	8b 45 fc	 mov	 eax, DWORD PTR _dp$[ebp]
  00060	83 c0 01	 add	 eax, 1
  00063	89 45 fc	 mov	 DWORD PTR _dp$[ebp], eax
  00066	8b 4d f8	 mov	 ecx, DWORD PTR _sp$[ebp]
  00069	83 c1 01	 add	 ecx, 1
  0006c	89 4d f8	 mov	 DWORD PTR _sp$[ebp], ecx
  0006f	eb cd		 jmp	 SHORT $LN2@memmove
$LN3@memmove:

; 83   :          *dp = '\0';

  00071	8b 55 fc	 mov	 edx, DWORD PTR _dp$[ebp]
  00074	c6 02 00	 mov	 BYTE PTR [edx], 0

; 84   :      }

  00077	eb 53		 jmp	 SHORT $LN9@memmove
$LN8@memmove:

; 85   :      else if(sp<dp) //Overlaped.

  00079	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  0007c	3b 45 fc	 cmp	 eax, DWORD PTR _dp$[ebp]
  0007f	73 4b		 jae	 SHORT $LN9@memmove

; 86   :      {
; 87   : 		 sp += n; 

  00081	8b 4d f8	 mov	 ecx, DWORD PTR _sp$[ebp]
  00084	03 4d 10	 add	 ecx, DWORD PTR _n$[ebp]
  00087	89 4d f8	 mov	 DWORD PTR _sp$[ebp], ecx

; 88   :          dp += n; 

  0008a	8b 55 fc	 mov	 edx, DWORD PTR _dp$[ebp]
  0008d	03 55 10	 add	 edx, DWORD PTR _n$[ebp]
  00090	89 55 fc	 mov	 DWORD PTR _dp$[ebp], edx

; 89   :          *dp = '\0'; 

  00093	8b 45 fc	 mov	 eax, DWORD PTR _dp$[ebp]
  00096	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN4@memmove:

; 90   :          while(n--)

  00099	8b 4d 10	 mov	 ecx, DWORD PTR _n$[ebp]
  0009c	89 4d f0	 mov	 DWORD PTR tv80[ebp], ecx
  0009f	8b 55 10	 mov	 edx, DWORD PTR _n$[ebp]
  000a2	83 ea 01	 sub	 edx, 1
  000a5	89 55 10	 mov	 DWORD PTR _n$[ebp], edx
  000a8	83 7d f0 00	 cmp	 DWORD PTR tv80[ebp], 0
  000ac	74 1e		 je	 SHORT $LN9@memmove

; 91   :             *(--dp) = *(--sp); 

  000ae	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  000b1	83 e8 01	 sub	 eax, 1
  000b4	89 45 f8	 mov	 DWORD PTR _sp$[ebp], eax
  000b7	8b 4d fc	 mov	 ecx, DWORD PTR _dp$[ebp]
  000ba	83 e9 01	 sub	 ecx, 1
  000bd	89 4d fc	 mov	 DWORD PTR _dp$[ebp], ecx
  000c0	8b 55 fc	 mov	 edx, DWORD PTR _dp$[ebp]
  000c3	8b 45 f8	 mov	 eax, DWORD PTR _sp$[ebp]
  000c6	8a 08		 mov	 cl, BYTE PTR [eax]
  000c8	88 0a		 mov	 BYTE PTR [edx], cl
  000ca	eb cd		 jmp	 SHORT $LN4@memmove
$LN9@memmove:

; 92   :      }
; 93   :      return dst;

  000cc	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
$LN1@memmove:

; 94   : }

  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c3		 ret	 0
_memmove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\memory.c
;	COMDAT _memchr
_TEXT	SEGMENT
tv71 = -4						; size = 4
_buf$ = 8						; size = 4
_chr$ = 12						; size = 4
_cnt$ = 16						; size = 4
_memchr	PROC						; COMDAT

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@memchr:

; 45   : 	while ( cnt && (*(unsigned char *)buf != (unsigned char)chr) ) 

  00004	83 7d 10 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00008	74 22		 je	 SHORT $LN3@memchr
  0000a	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0000d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00010	0f b6 55 0c	 movzx	 edx, BYTE PTR _chr$[ebp]
  00014	3b ca		 cmp	 ecx, edx
  00016	74 14		 je	 SHORT $LN3@memchr

; 46   : 	{
; 47   : 		buf = (unsigned char *)buf + 1;

  00018	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0001b	83 c0 01	 add	 eax, 1
  0001e	89 45 08	 mov	 DWORD PTR _buf$[ebp], eax

; 48   : 		cnt--;

  00021	8b 4d 10	 mov	 ecx, DWORD PTR _cnt$[ebp]
  00024	83 e9 01	 sub	 ecx, 1
  00027	89 4d 10	 mov	 DWORD PTR _cnt$[ebp], ecx

; 49   : 	}

  0002a	eb d8		 jmp	 SHORT $LN2@memchr
$LN3@memchr:

; 50   : 
; 51   : 	return(cnt ? (void *)buf : NULL);

  0002c	83 7d 10 00	 cmp	 DWORD PTR _cnt$[ebp], 0
  00030	74 08		 je	 SHORT $LN5@memchr
  00032	8b 55 08	 mov	 edx, DWORD PTR _buf$[ebp]
  00035	89 55 fc	 mov	 DWORD PTR tv71[ebp], edx
  00038	eb 07		 jmp	 SHORT $LN6@memchr
$LN5@memchr:
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN6@memchr:
  00041	8b 45 fc	 mov	 eax, DWORD PTR tv71[ebp]

; 52   : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_memchr	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\memory.c
;	COMDAT _memcmp
_TEXT	SEGMENT
_buffer1$ = 8						; size = 4
_buffer2$ = 12						; size = 4
_count$ = 16						; size = 4
_memcmp	PROC						; COMDAT

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 56   : 	if (!count) return(0);

  00003	83 7d 10 00	 cmp	 DWORD PTR _count$[ebp], 0
  00007	75 04		 jne	 SHORT $LN2@memcmp
  00009	33 c0		 xor	 eax, eax
  0000b	eb 3d		 jmp	 SHORT $LN1@memcmp
$LN2@memcmp:

; 57   : 
; 58   : 	while ( --count && *(char *)buffer1 == *(char *)buffer2)

  0000d	8b 45 10	 mov	 eax, DWORD PTR _count$[ebp]
  00010	83 e8 01	 sub	 eax, 1
  00013	89 45 10	 mov	 DWORD PTR _count$[ebp], eax
  00016	74 24		 je	 SHORT $LN3@memcmp
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _buffer1$[ebp]
  0001b	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0001e	8b 45 0c	 mov	 eax, DWORD PTR _buffer2$[ebp]
  00021	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00024	3b d1		 cmp	 edx, ecx
  00026	75 14		 jne	 SHORT $LN3@memcmp

; 59   : 	{
; 60   : 		buffer1 = (char *)buffer1 + 1;

  00028	8b 55 08	 mov	 edx, DWORD PTR _buffer1$[ebp]
  0002b	83 c2 01	 add	 edx, 1
  0002e	89 55 08	 mov	 DWORD PTR _buffer1$[ebp], edx

; 61   : 		buffer2 = (char *)buffer2 + 1;

  00031	8b 45 0c	 mov	 eax, DWORD PTR _buffer2$[ebp]
  00034	83 c0 01	 add	 eax, 1
  00037	89 45 0c	 mov	 DWORD PTR _buffer2$[ebp], eax

; 62   : 	}

  0003a	eb d1		 jmp	 SHORT $LN2@memcmp
$LN3@memcmp:

; 63   : 
; 64   : 	return( *((unsigned char *)buffer1) - *((unsigned char *)buffer2) );

  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _buffer1$[ebp]
  0003f	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00042	8b 55 0c	 mov	 edx, DWORD PTR _buffer2$[ebp]
  00045	0f b6 0a	 movzx	 ecx, BYTE PTR [edx]
  00048	2b c1		 sub	 eax, ecx
$LN1@memcmp:

; 65   : }

  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_memcmp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\memory.c
;	COMDAT _memzero
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_count$ = 12						; size = 4
_memzero PROC						; COMDAT

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 40   : 	return memset(dst,0,count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _count$[ebp]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _memset
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 41   : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
_memzero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\memory.c
;	COMDAT _memset
_TEXT	SEGMENT
_start$ = -8						; size = 4
tv66 = -4						; size = 4
_dst$ = 8						; size = 4
_val$ = 12						; size = 4
_count$ = 16						; size = 4
_memset	PROC						; COMDAT

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 27   : 	void *start = dst;

  00006	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _start$[ebp], eax
$LN2@memset:

; 28   : 
; 29   : 	while (count--) 

  0000c	8b 4d 10	 mov	 ecx, DWORD PTR _count$[ebp]
  0000f	89 4d fc	 mov	 DWORD PTR tv66[ebp], ecx
  00012	8b 55 10	 mov	 edx, DWORD PTR _count$[ebp]
  00015	83 ea 01	 sub	 edx, 1
  00018	89 55 10	 mov	 DWORD PTR _count$[ebp], edx
  0001b	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  0001f	74 13		 je	 SHORT $LN3@memset

; 30   : 	{
; 31   : 		*(char *)dst = (char)val;

  00021	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00024	8a 4d 0c	 mov	 cl, BYTE PTR _val$[ebp]
  00027	88 08		 mov	 BYTE PTR [eax], cl

; 32   : 		dst = (char *)dst + 1;

  00029	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  0002c	83 c2 01	 add	 edx, 1
  0002f	89 55 08	 mov	 DWORD PTR _dst$[ebp], edx

; 33   : 	}

  00032	eb d8		 jmp	 SHORT $LN2@memset
$LN3@memset:

; 34   : 
; 35   : 	return(start);

  00034	8b 45 f8	 mov	 eax, DWORD PTR _start$[ebp]

; 36   : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
_memset	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\memory.c
;	COMDAT _memcpy
_TEXT	SEGMENT
_ret$ = -8						; size = 4
tv66 = -4						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_count$ = 16						; size = 4
_memcpy	PROC						; COMDAT

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 12   : 	void * ret = dst;

  00006	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax
$LN2@memcpy:

; 13   : 
; 14   : 	//copy from lower addresses to higher addresses
; 15   : 	while (count--) 

  0000c	8b 4d 10	 mov	 ecx, DWORD PTR _count$[ebp]
  0000f	89 4d fc	 mov	 DWORD PTR tv66[ebp], ecx
  00012	8b 55 10	 mov	 edx, DWORD PTR _count$[ebp]
  00015	83 ea 01	 sub	 edx, 1
  00018	89 55 10	 mov	 DWORD PTR _count$[ebp], edx
  0001b	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  0001f	74 1e		 je	 SHORT $LN3@memcpy

; 16   : 	{
; 17   : 		*(char *)dst = *(char *)src;

  00021	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00024	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00027	8a 11		 mov	 dl, BYTE PTR [ecx]
  00029	88 10		 mov	 BYTE PTR [eax], dl

; 18   : 		dst = (char *)dst + 1;

  0002b	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  0002e	83 c0 01	 add	 eax, 1
  00031	89 45 08	 mov	 DWORD PTR _dst$[ebp], eax

; 19   : 		src = (char *)src + 1;

  00034	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00037	83 c1 01	 add	 ecx, 1
  0003a	89 4d 0c	 mov	 DWORD PTR _src$[ebp], ecx

; 20   : 	}

  0003d	eb cd		 jmp	 SHORT $LN2@memcpy
$LN3@memcpy:

; 21   : 
; 22   : 	return(ret);

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]

; 23   : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
_memcpy	ENDP
_TEXT	ENDS
END
