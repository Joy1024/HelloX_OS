; Listing generated by Microsoft (R) Optimizing Compiler Version 19.13.26128.0 

	TITLE	C:\HelloX\personal\HelloX_OS\app\yeelight\hxlib\scalbn.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_scalbn
PUBLIC	__real@01a56e1fc2f8f359
PUBLIC	__real@3c90000000000000
PUBLIC	__real@4350000000000000
PUBLIC	__real@7e37e43c8800759c
EXTRN	_copysign:PROC
EXTRN	__fltused:DWORD
;	COMDAT __real@7e37e43c8800759c
CONST	SEGMENT
__real@7e37e43c8800759c DQ 07e37e43c8800759cr	; 1e+300
CONST	ENDS
;	COMDAT __real@4350000000000000
CONST	SEGMENT
__real@4350000000000000 DQ 04350000000000000r	; 1.80144e+16
CONST	ENDS
;	COMDAT __real@3c90000000000000
CONST	SEGMENT
__real@3c90000000000000 DQ 03c90000000000000r	; 5.55112e-17
CONST	ENDS
;	COMDAT __real@01a56e1fc2f8f359
CONST	SEGMENT
__real@01a56e1fc2f8f359 DQ 001a56e1fc2f8f359r	; 1e-300
CONST	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\scalbn.c
;	COMDAT _scalbn
_TEXT	SEGMENT
_lx$ = -12						; size = 4
_hx$ = -8						; size = 4
_k$ = -4						; size = 4
_x$ = 8							; size = 8
_n$ = 16						; size = 4
_scalbn	PROC						; COMDAT

; 43   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 44   :   int k, hx, lx;
; 45   : 
; 46   :   hx = __HI (x);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp+4]
  00009	89 45 f8	 mov	 DWORD PTR _hx$[ebp], eax

; 47   :   lx = __LO (x);

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0000f	89 4d f4	 mov	 DWORD PTR _lx$[ebp], ecx

; 48   :   k = (hx & 0x7ff00000) >> 20; /* extract exponent */

  00012	8b 55 f8	 mov	 edx, DWORD PTR _hx$[ebp]
  00015	81 e2 00 00 f0
	7f		 and	 edx, 2146435072		; 7ff00000H
  0001b	c1 fa 14	 sar	 edx, 20			; 00000014H
  0001e	89 55 fc	 mov	 DWORD PTR _k$[ebp], edx

; 49   :   if (k == 0) /* 0 or subnormal x */

  00021	83 7d fc 00	 cmp	 DWORD PTR _k$[ebp], 0
  00025	75 50		 jne	 SHORT $LN4@scalbn

; 50   :   {
; 51   :     if ((lx | (hx & 0x7fffffff)) == 0) /* +-0 */

  00027	8b 45 f8	 mov	 eax, DWORD PTR _hx$[ebp]
  0002a	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH
  0002f	0b 45 f4	 or	 eax, DWORD PTR _lx$[ebp]
  00032	75 08		 jne	 SHORT $LN3@scalbn

; 52   :     {
; 53   :       return x;

  00034	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  00037	e9 2c 01 00 00	 jmp	 $LN1@scalbn
$LN3@scalbn:

; 54   :     }
; 55   :     x *= two54;

  0003c	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  0003f	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@4350000000000000
  00045	dd 5d 08	 fstp	 QWORD PTR _x$[ebp]

; 56   :     hx = __HI (x);

  00048	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp+4]
  0004b	89 4d f8	 mov	 DWORD PTR _hx$[ebp], ecx

; 57   :     k = ((hx & 0x7ff00000) >> 20) - 54;

  0004e	8b 55 f8	 mov	 edx, DWORD PTR _hx$[ebp]
  00051	81 e2 00 00 f0
	7f		 and	 edx, 2146435072		; 7ff00000H
  00057	c1 fa 14	 sar	 edx, 20			; 00000014H
  0005a	83 ea 36	 sub	 edx, 54			; 00000036H
  0005d	89 55 fc	 mov	 DWORD PTR _k$[ebp], edx

; 58   :     if (n < -50000) /*underflow */

  00060	81 7d 10 b0 3c
	ff ff		 cmp	 DWORD PTR _n$[ebp], -50000 ; ffff3cb0H
  00067	7d 0e		 jge	 SHORT $LN4@scalbn

; 59   :     {
; 60   :       return tiny * x;

  00069	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@01a56e1fc2f8f359
  0006f	dc 4d 08	 fmul	 QWORD PTR _x$[ebp]
  00072	e9 f1 00 00 00	 jmp	 $LN1@scalbn
$LN4@scalbn:

; 61   :     }
; 62   :   }
; 63   :   if (k == 0x7ff) /* NaN or Inf */

  00077	81 7d fc ff 07
	00 00		 cmp	 DWORD PTR _k$[ebp], 2047 ; 000007ffH
  0007e	75 0b		 jne	 SHORT $LN5@scalbn

; 64   :   {
; 65   :     return x + x;

  00080	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  00083	dc 45 08	 fadd	 QWORD PTR _x$[ebp]
  00086	e9 dd 00 00 00	 jmp	 $LN1@scalbn
$LN5@scalbn:

; 66   :   }
; 67   :   k = k + n;

  0008b	8b 45 fc	 mov	 eax, DWORD PTR _k$[ebp]
  0008e	03 45 10	 add	 eax, DWORD PTR _n$[ebp]
  00091	89 45 fc	 mov	 DWORD PTR _k$[ebp], eax

; 68   :   if (k > 0x7fe) /* overflow  */

  00094	81 7d fc fe 07
	00 00		 cmp	 DWORD PTR _k$[ebp], 2046 ; 000007feH
  0009b	7e 28		 jle	 SHORT $LN6@scalbn

; 69   :   {
; 70   :     return huge * copysign (huge, x);

  0009d	83 ec 08	 sub	 esp, 8
  000a0	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  000a3	dd 1c 24	 fstp	 QWORD PTR [esp]
  000a6	83 ec 08	 sub	 esp, 8
  000a9	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@7e37e43c8800759c
  000af	dd 1c 24	 fstp	 QWORD PTR [esp]
  000b2	e8 00 00 00 00	 call	 _copysign
  000b7	83 c4 10	 add	 esp, 16			; 00000010H
  000ba	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@7e37e43c8800759c
  000c0	e9 a3 00 00 00	 jmp	 $LN1@scalbn
$LN6@scalbn:

; 71   :   }
; 72   :   if (k > 0) /* normal result */

  000c5	83 7d fc 00	 cmp	 DWORD PTR _k$[ebp], 0
  000c9	7e 1c		 jle	 SHORT $LN7@scalbn

; 73   :   {
; 74   :     __HI (x) = (hx & 0x800fffff) | (k << 20);

  000cb	8b 4d f8	 mov	 ecx, DWORD PTR _hx$[ebp]
  000ce	81 e1 ff ff 0f
	80		 and	 ecx, -2146435073	; 800fffffH
  000d4	8b 55 fc	 mov	 edx, DWORD PTR _k$[ebp]
  000d7	c1 e2 14	 shl	 edx, 20			; 00000014H
  000da	0b ca		 or	 ecx, edx
  000dc	89 4d 0c	 mov	 DWORD PTR _x$[ebp+4], ecx

; 75   :     return x;

  000df	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  000e2	e9 81 00 00 00	 jmp	 $LN1@scalbn
$LN7@scalbn:

; 76   :   }
; 77   :   if (k <= -54)

  000e7	83 7d fc ca	 cmp	 DWORD PTR _k$[ebp], -54	; ffffffcaH
  000eb	7f 55		 jg	 SHORT $LN10@scalbn

; 78   :   {
; 79   :     if (n > 50000) /* in case integer overflow in n + k */

  000ed	81 7d 10 50 c3
	00 00		 cmp	 DWORD PTR _n$[ebp], 50000 ; 0000c350H
  000f4	7e 27		 jle	 SHORT $LN9@scalbn

; 80   :     {
; 81   :       return huge * copysign (huge, x); /*overflow */

  000f6	83 ec 08	 sub	 esp, 8
  000f9	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  000fc	dd 1c 24	 fstp	 QWORD PTR [esp]
  000ff	83 ec 08	 sub	 esp, 8
  00102	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@7e37e43c8800759c
  00108	dd 1c 24	 fstp	 QWORD PTR [esp]
  0010b	e8 00 00 00 00	 call	 _copysign
  00110	83 c4 10	 add	 esp, 16			; 00000010H
  00113	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@7e37e43c8800759c
  00119	eb 4d		 jmp	 SHORT $LN1@scalbn

; 82   :     }

  0011b	eb 25		 jmp	 SHORT $LN10@scalbn
$LN9@scalbn:

; 83   :     else
; 84   :     {
; 85   :       return tiny * copysign (tiny, x); /*underflow */

  0011d	83 ec 08	 sub	 esp, 8
  00120	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  00123	dd 1c 24	 fstp	 QWORD PTR [esp]
  00126	83 ec 08	 sub	 esp, 8
  00129	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@01a56e1fc2f8f359
  0012f	dd 1c 24	 fstp	 QWORD PTR [esp]
  00132	e8 00 00 00 00	 call	 _copysign
  00137	83 c4 10	 add	 esp, 16			; 00000010H
  0013a	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@01a56e1fc2f8f359
  00140	eb 26		 jmp	 SHORT $LN1@scalbn
$LN10@scalbn:

; 86   :     }
; 87   :   }
; 88   :   k += 54; /* subnormal result */

  00142	8b 45 fc	 mov	 eax, DWORD PTR _k$[ebp]
  00145	83 c0 36	 add	 eax, 54			; 00000036H
  00148	89 45 fc	 mov	 DWORD PTR _k$[ebp], eax

; 89   :   __HI (x) = (hx & 0x800fffff) | (k << 20);

  0014b	8b 4d f8	 mov	 ecx, DWORD PTR _hx$[ebp]
  0014e	81 e1 ff ff 0f
	80		 and	 ecx, -2146435073	; 800fffffH
  00154	8b 55 fc	 mov	 edx, DWORD PTR _k$[ebp]
  00157	c1 e2 14	 shl	 edx, 20			; 00000014H
  0015a	0b ca		 or	 ecx, edx
  0015c	89 4d 0c	 mov	 DWORD PTR _x$[ebp+4], ecx

; 90   :   return x * twom54;

  0015f	dd 45 08	 fld	 QWORD PTR _x$[ebp]
  00162	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3c90000000000000
$LN1@scalbn:

; 91   : } /* scalbn */

  00168	8b e5		 mov	 esp, ebp
  0016a	5d		 pop	 ebp
  0016b	c3		 ret	 0
_scalbn	ENDP
_TEXT	ENDS
END
