; Listing generated by Microsoft (R) Optimizing Compiler Version 19.13.26128.0 

	TITLE	C:\HelloX\personal\HelloX_OS\app\yeelight\src\server.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG5034	DB	'Failed to create server socket[sock = %d].', 0dH, 0aH, 00H
	ORG $+3
$SG5036	DB	'ylight_server', 00H
	ORG $+2
$SG5037	DB	'%s:failed to set sock''s timeout.', 0dH, 0aH, 00H
	ORG $+1
$SG5039	DB	'Failed to bind the server port to local[ret = %d].', 0dH
	DB	0aH, 00H
	ORG $+3
$SG5041	DB	'Failed to listen[ret = %d].', 0dH, 0aH, 00H
	ORG $+2
$SG5046	DB	'Connection from[%s/%d] is established.', 0dH, 0aH, 00H
	ORG $+3
$SG5051	DB	'_hellox', 00H
$SG5054	DB	'quit', 00H
	ORG $+3
$SG5058	DB	'Bulb server exit.', 0dH, 0aH, 00H
_DATA	ENDS
PUBLIC	_ylight_server
EXTRN	_PeekMessage:PROC
EXTRN	_PrintChar:PROC
EXTRN	_GotoHome:PROC
EXTRN	_ChangeLine:PROC
EXTRN	_LogHeader:PROC
EXTRN	__hx_printf:PROC
EXTRN	__hx_malloc:PROC
EXTRN	__hx_free:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	_ipaddr_ntoa:PROC
EXTRN	__hx_htonl:PROC
EXTRN	__hx_htons:PROC
EXTRN	__hx_ntohs:PROC
EXTRN	_accept:PROC
EXTRN	_bind:PROC
EXTRN	_setsockopt:PROC
EXTRN	_close:PROC
EXTRN	_listen:PROC
EXTRN	_recv:PROC
EXTRN	_send:PROC
EXTRN	_socket:PROC
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\src\server.c
;	COMDAT _ylight_server
_TEXT	SEGMENT
_sa$ = -56						; size = 16
_msg$ = -40						; size = 8
_addr_len$ = -32					; size = 4
_timeout$ = -28						; size = 4
_clt_sock$ = -24					; size = 4
_i$ = -20						; size = 4
_srv_sock$ = -16					; size = 4
_incoming_data$ = -12					; size = 4
_ret$ = -8						; size = 4
_wr$ = -4						; size = 2
_pData$ = 8						; size = 4
_ylight_server PROC					; COMDAT

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H

; 27   : 	int srv_sock = -1;

  00006	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _srv_sock$[ebp], -1

; 28   : 	int clt_sock = -1; /* Socket after client connection is accepted. */

  0000d	c7 45 e8 ff ff
	ff ff		 mov	 DWORD PTR _clt_sock$[ebp], -1

; 29   : 	int ret = -1;

  00014	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -1

; 30   : 	struct sockaddr_in sa;
; 31   : 	u32_t addr_len = 0;

  0001b	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _addr_len$[ebp], 0

; 32   : 	char* incoming_data = NULL;

  00022	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _incoming_data$[ebp], 0

; 33   : 	int timeout = 0;

  00029	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _timeout$[ebp], 0

; 34   : 	WORD wr = 0x0700;

  00030	b8 00 07 00 00	 mov	 eax, 1792		; 00000700H
  00035	66 89 45 fc	 mov	 WORD PTR _wr$[ebp], ax

; 35   : 	int i = 0;

  00039	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 36   : 	MSG msg;
; 37   : 
; 38   : 	/* Create the server socket. */
; 39   : 	srv_sock = socket(AF_INET, SOCK_STREAM, 0);

  00040	6a 00		 push	 0
  00042	6a 01		 push	 1
  00044	6a 02		 push	 2
  00046	e8 00 00 00 00	 call	 _socket
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	89 45 f0	 mov	 DWORD PTR _srv_sock$[ebp], eax

; 40   : 	if (srv_sock < 0)

  00051	83 7d f0 00	 cmp	 DWORD PTR _srv_sock$[ebp], 0
  00055	7d 20		 jge	 SHORT $LN9@ylight_ser

; 41   : 	{
; 42   : 		__LOG("Failed to create server socket[sock = %d].\r\n",

  00057	6a 00		 push	 0
  00059	e8 00 00 00 00	 call	 _LogHeader
  0005e	83 c4 04	 add	 esp, 4
  00061	8b 4d f0	 mov	 ecx, DWORD PTR _srv_sock$[ebp]
  00064	51		 push	 ecx
  00065	68 00 00 00 00	 push	 OFFSET $SG5034
  0006a	e8 00 00 00 00	 call	 __hx_printf
  0006f	83 c4 08	 add	 esp, 8

; 43   : 			srv_sock);
; 44   : 		goto __TERMINAL;

  00072	e9 a6 02 00 00	 jmp	 $__TERMINAL$28
$LN9@ylight_ser:

; 45   : 	}
; 46   : 
; 47   : 	/* Set receiving timeout value. */
; 48   : 	timeout = YLIGHT_WAIT_TIMEOUT;

  00077	c7 45 e4 88 13
	00 00		 mov	 DWORD PTR _timeout$[ebp], 5000 ; 00001388H

; 49   : 	ret = setsockopt(srv_sock, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));

  0007e	6a 04		 push	 4
  00080	8d 55 e4	 lea	 edx, DWORD PTR _timeout$[ebp]
  00083	52		 push	 edx
  00084	68 06 10 00 00	 push	 4102			; 00001006H
  00089	68 ff 0f 00 00	 push	 4095			; 00000fffH
  0008e	8b 45 f0	 mov	 eax, DWORD PTR _srv_sock$[ebp]
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 _setsockopt
  00097	83 c4 14	 add	 esp, 20			; 00000014H
  0009a	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 50   : 	if (ret < 0)

  0009d	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  000a1	7d 21		 jge	 SHORT $LN10@ylight_ser

; 51   : 	{
; 52   : 		__LOG("%s:failed to set sock's timeout.\r\n", __FUNCTION__);

  000a3	6a 00		 push	 0
  000a5	e8 00 00 00 00	 call	 _LogHeader
  000aa	83 c4 04	 add	 esp, 4
  000ad	68 00 00 00 00	 push	 OFFSET $SG5036
  000b2	68 00 00 00 00	 push	 OFFSET $SG5037
  000b7	e8 00 00 00 00	 call	 __hx_printf
  000bc	83 c4 08	 add	 esp, 8

; 53   : 		goto __TERMINAL;

  000bf	e9 59 02 00 00	 jmp	 $__TERMINAL$28
$LN10@ylight_ser:

; 54   : 	}
; 55   : 
; 56   : 	/* Bind to server port,use any local IP interface. */
; 57   : 	sa.sin_family = AF_INET;

  000c4	c6 45 c9 02	 mov	 BYTE PTR _sa$[ebp+1], 2

; 58   : 	sa.sin_port = _hx_htons(YLIGHT_SERVER_PORT);

  000c8	68 01 08 00 00	 push	 2049			; 00000801H
  000cd	e8 00 00 00 00	 call	 __hx_htons
  000d2	83 c4 04	 add	 esp, 4
  000d5	66 89 45 ca	 mov	 WORD PTR _sa$[ebp+2], ax

; 59   : 	sa.sin_addr.s_addr = _hx_htonl(INADDR_ANY);

  000d9	6a 00		 push	 0
  000db	e8 00 00 00 00	 call	 __hx_htonl
  000e0	83 c4 04	 add	 esp, 4
  000e3	89 45 cc	 mov	 DWORD PTR _sa$[ebp+4], eax

; 60   : 	memset(sa.sin_zero, 0, sizeof(sa.sin_zero));

  000e6	6a 08		 push	 8
  000e8	6a 00		 push	 0
  000ea	8d 4d d0	 lea	 ecx, DWORD PTR _sa$[ebp+8]
  000ed	51		 push	 ecx
  000ee	e8 00 00 00 00	 call	 _memset
  000f3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 61   : 	ret = bind(srv_sock, (const struct sockaddr*)&sa, sizeof(sa));

  000f6	6a 10		 push	 16			; 00000010H
  000f8	8d 55 c8	 lea	 edx, DWORD PTR _sa$[ebp]
  000fb	52		 push	 edx
  000fc	8b 45 f0	 mov	 eax, DWORD PTR _srv_sock$[ebp]
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 _bind
  00105	83 c4 0c	 add	 esp, 12			; 0000000cH
  00108	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 62   : 	if (ret < 0)

  0010b	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0010f	7d 20		 jge	 SHORT $LN11@ylight_ser

; 63   : 	{
; 64   : 		__LOG("Failed to bind the server port to local[ret = %d].\r\n",

  00111	6a 00		 push	 0
  00113	e8 00 00 00 00	 call	 _LogHeader
  00118	83 c4 04	 add	 esp, 4
  0011b	8b 4d f8	 mov	 ecx, DWORD PTR _ret$[ebp]
  0011e	51		 push	 ecx
  0011f	68 00 00 00 00	 push	 OFFSET $SG5039
  00124	e8 00 00 00 00	 call	 __hx_printf
  00129	83 c4 08	 add	 esp, 8

; 65   : 			ret);
; 66   : 		goto __TERMINAL;

  0012c	e9 ec 01 00 00	 jmp	 $__TERMINAL$28
$LN11@ylight_ser:

; 67   : 	}
; 68   : 
; 69   : 	/* Listen on local network. */
; 70   : 	ret = listen(srv_sock, 1);

  00131	6a 01		 push	 1
  00133	8b 55 f0	 mov	 edx, DWORD PTR _srv_sock$[ebp]
  00136	52		 push	 edx
  00137	e8 00 00 00 00	 call	 _listen
  0013c	83 c4 08	 add	 esp, 8
  0013f	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 71   : 	if (ret < 0)

  00142	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00146	7d 20		 jge	 SHORT $LN12@ylight_ser

; 72   : 	{
; 73   : 		__LOG("Failed to listen[ret = %d].\r\n", ret);

  00148	6a 00		 push	 0
  0014a	e8 00 00 00 00	 call	 _LogHeader
  0014f	83 c4 04	 add	 esp, 4
  00152	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]
  00155	50		 push	 eax
  00156	68 00 00 00 00	 push	 OFFSET $SG5041
  0015b	e8 00 00 00 00	 call	 __hx_printf
  00160	83 c4 08	 add	 esp, 8

; 74   : 		goto __TERMINAL;

  00163	e9 b5 01 00 00	 jmp	 $__TERMINAL$28
$LN12@ylight_ser:

; 75   : 	}
; 76   : 
; 77   : 	/* Allocate the incoming data buffer. */
; 78   : 	incoming_data = (char*)_hx_malloc(1500);

  00168	68 dc 05 00 00	 push	 1500			; 000005dcH
  0016d	e8 00 00 00 00	 call	 __hx_malloc
  00172	83 c4 04	 add	 esp, 4
  00175	89 45 f4	 mov	 DWORD PTR _incoming_data$[ebp], eax

; 79   : 	if (NULL == incoming_data)

  00178	83 7d f4 00	 cmp	 DWORD PTR _incoming_data$[ebp], 0
  0017c	75 05		 jne	 SHORT $LN2@ylight_ser

; 80   : 	{
; 81   : 		goto __TERMINAL;

  0017e	e9 9a 01 00 00	 jmp	 $__TERMINAL$28
$LN2@ylight_ser:

; 82   : 	}
; 83   : 
; 84   : 	while (TRUE)

  00183	83 c9 ff	 or	 ecx, -1
  00186	0f 84 91 01 00
	00		 je	 $__TERMINAL$28

; 85   : 	{
; 86   : 		/* Check if we should exit. */
; 87   : 		if (PeekMessage(&msg))

  0018c	8d 55 d8	 lea	 edx, DWORD PTR _msg$[ebp]
  0018f	52		 push	 edx
  00190	e8 00 00 00 00	 call	 _PeekMessage
  00195	83 c4 04	 add	 esp, 4
  00198	85 c0		 test	 eax, eax
  0019a	74 0e		 je	 SHORT $LN14@ylight_ser

; 88   : 		{
; 89   : 			if (KERNEL_MESSAGE_TERMINAL == msg.wCommand)

  0019c	0f b7 45 d8	 movzx	 eax, WORD PTR _msg$[ebp]
  001a0	83 f8 05	 cmp	 eax, 5
  001a3	75 05		 jne	 SHORT $LN14@ylight_ser

; 90   : 			{
; 91   : 				goto __TERMINAL;

  001a5	e9 73 01 00 00	 jmp	 $__TERMINAL$28
$LN14@ylight_ser:

; 92   : 			}
; 93   : 		}
; 94   : 
; 95   : 		/* Accept the incoming client. */
; 96   : 		addr_len = sizeof(sa);

  001aa	c7 45 e0 10 00
	00 00		 mov	 DWORD PTR _addr_len$[ebp], 16 ; 00000010H

; 97   : 		clt_sock = accept(srv_sock, (struct sockaddr*)&sa, &addr_len);

  001b1	8d 4d e0	 lea	 ecx, DWORD PTR _addr_len$[ebp]
  001b4	51		 push	 ecx
  001b5	8d 55 c8	 lea	 edx, DWORD PTR _sa$[ebp]
  001b8	52		 push	 edx
  001b9	8b 45 f0	 mov	 eax, DWORD PTR _srv_sock$[ebp]
  001bc	50		 push	 eax
  001bd	e8 00 00 00 00	 call	 _accept
  001c2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c5	89 45 e8	 mov	 DWORD PTR _clt_sock$[ebp], eax

; 98   : 		if (clt_sock < 0)

  001c8	83 7d e8 00	 cmp	 DWORD PTR _clt_sock$[ebp], 0
  001cc	7d 02		 jge	 SHORT $LN16@ylight_ser

; 99   : 		{
; 100  : 			continue; /* May caused by timeout. */

  001ce	eb b3		 jmp	 SHORT $LN2@ylight_ser
$LN16@ylight_ser:

; 101  : 		}
; 102  : 
; 103  : 		/* Show client information. */
; 104  : 		_hx_printf("Connection from[%s/%d] is established.\r\n",

  001d0	0f b7 4d ca	 movzx	 ecx, WORD PTR _sa$[ebp+2]
  001d4	51		 push	 ecx
  001d5	e8 00 00 00 00	 call	 __hx_ntohs
  001da	83 c4 04	 add	 esp, 4
  001dd	0f b7 d0	 movzx	 edx, ax
  001e0	52		 push	 edx
  001e1	8d 45 cc	 lea	 eax, DWORD PTR _sa$[ebp+4]
  001e4	50		 push	 eax
  001e5	e8 00 00 00 00	 call	 _ipaddr_ntoa
  001ea	83 c4 04	 add	 esp, 4
  001ed	50		 push	 eax
  001ee	68 00 00 00 00	 push	 OFFSET $SG5046
  001f3	e8 00 00 00 00	 call	 __hx_printf
  001f8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@ylight_ser:

; 105  : 			inet_ntoa(sa.sin_addr),
; 106  : 			_hx_ntohs(sa.sin_port));
; 107  : 
; 108  : 		/* Process the incoming request from connected client. */
; 109  : 		while (TRUE) {

  001fb	83 c9 ff	 or	 ecx, -1
  001fe	0f 84 01 01 00
	00		 je	 $LN5@ylight_ser

; 110  : 			ret = recv(clt_sock, incoming_data, 1500, 0);

  00204	6a 00		 push	 0
  00206	68 dc 05 00 00	 push	 1500			; 000005dcH
  0020b	8b 55 f4	 mov	 edx, DWORD PTR _incoming_data$[ebp]
  0020e	52		 push	 edx
  0020f	8b 45 e8	 mov	 eax, DWORD PTR _clt_sock$[ebp]
  00212	50		 push	 eax
  00213	e8 00 00 00 00	 call	 _recv
  00218	83 c4 10	 add	 esp, 16			; 00000010H
  0021b	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 111  : 			if (ret > 0)

  0021e	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00222	0f 8e d6 00 00
	00		 jle	 $LN17@ylight_ser

; 112  : 			{
; 113  : 				/* Just show the incoming command. */
; 114  : 				for (i = 0; i < ret; i++)

  00228	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0022f	eb 09		 jmp	 SHORT $LN8@ylight_ser
$LN6@ylight_ser:
  00231	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  00234	83 c1 01	 add	 ecx, 1
  00237	89 4d ec	 mov	 DWORD PTR _i$[ebp], ecx
$LN8@ylight_ser:
  0023a	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  0023d	3b 55 f8	 cmp	 edx, DWORD PTR _ret$[ebp]
  00240	7d 5f		 jge	 SHORT $LN7@ylight_ser

; 115  : 				{
; 116  : 					if (incoming_data[i] == '\r')

  00242	8b 45 f4	 mov	 eax, DWORD PTR _incoming_data$[ebp]
  00245	03 45 ec	 add	 eax, DWORD PTR _i$[ebp]
  00248	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0024b	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  0024e	75 07		 jne	 SHORT $LN19@ylight_ser

; 117  : 					{
; 118  : 						GotoHome();

  00250	e8 00 00 00 00	 call	 _GotoHome

; 119  : 						continue;

  00255	eb da		 jmp	 SHORT $LN6@ylight_ser
$LN19@ylight_ser:

; 120  : 					}
; 121  : 					if (incoming_data[i] == '\n')

  00257	8b 55 f4	 mov	 edx, DWORD PTR _incoming_data$[ebp]
  0025a	03 55 ec	 add	 edx, DWORD PTR _i$[ebp]
  0025d	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00260	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00263	75 07		 jne	 SHORT $LN20@ylight_ser

; 122  : 					{
; 123  : 						ChangeLine();

  00265	e8 00 00 00 00	 call	 _ChangeLine

; 124  : 						continue;

  0026a	eb c5		 jmp	 SHORT $LN6@ylight_ser
$LN20@ylight_ser:

; 125  : 					}
; 126  : 					/* Show out all ASCII characters. */
; 127  : 					wr += incoming_data[i];

  0026c	8b 4d f4	 mov	 ecx, DWORD PTR _incoming_data$[ebp]
  0026f	03 4d ec	 add	 ecx, DWORD PTR _i$[ebp]
  00272	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00275	0f b7 45 fc	 movzx	 eax, WORD PTR _wr$[ebp]
  00279	03 c2		 add	 eax, edx
  0027b	66 89 45 fc	 mov	 WORD PTR _wr$[ebp], ax

; 128  : 					PrintChar(wr);

  0027f	0f b7 4d fc	 movzx	 ecx, WORD PTR _wr$[ebp]
  00283	51		 push	 ecx
  00284	e8 00 00 00 00	 call	 _PrintChar
  00289	83 c4 04	 add	 esp, 4

; 129  : 					wr -= incoming_data[i];

  0028c	8b 55 f4	 mov	 edx, DWORD PTR _incoming_data$[ebp]
  0028f	03 55 ec	 add	 edx, DWORD PTR _i$[ebp]
  00292	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00295	0f b7 4d fc	 movzx	 ecx, WORD PTR _wr$[ebp]
  00299	2b c8		 sub	 ecx, eax
  0029b	66 89 4d fc	 mov	 WORD PTR _wr$[ebp], cx

; 130  : 				}

  0029f	eb 90		 jmp	 SHORT $LN6@ylight_ser
$LN7@ylight_ser:

; 131  : 				/* Send back the received data. */
; 132  : 				strcpy((incoming_data), "_hellox");

  002a1	68 00 00 00 00	 push	 OFFSET $SG5051
  002a6	8b 55 f4	 mov	 edx, DWORD PTR _incoming_data$[ebp]
  002a9	52		 push	 edx
  002aa	e8 00 00 00 00	 call	 _strcpy
  002af	83 c4 08	 add	 esp, 8

; 133  : 				ret = send(clt_sock, incoming_data, strlen(incoming_data), 0);

  002b2	6a 00		 push	 0
  002b4	8b 45 f4	 mov	 eax, DWORD PTR _incoming_data$[ebp]
  002b7	50		 push	 eax
  002b8	e8 00 00 00 00	 call	 _strlen
  002bd	83 c4 04	 add	 esp, 4
  002c0	50		 push	 eax
  002c1	8b 4d f4	 mov	 ecx, DWORD PTR _incoming_data$[ebp]
  002c4	51		 push	 ecx
  002c5	8b 55 e8	 mov	 edx, DWORD PTR _clt_sock$[ebp]
  002c8	52		 push	 edx
  002c9	e8 00 00 00 00	 call	 _send
  002ce	83 c4 10	 add	 esp, 16			; 00000010H
  002d1	89 45 f8	 mov	 DWORD PTR _ret$[ebp], eax

; 134  : 				if (ret < 0)

  002d4	83 7d f8 00	 cmp	 DWORD PTR _ret$[ebp], 0
  002d8	7d 02		 jge	 SHORT $LN21@ylight_ser

; 135  : 				{
; 136  : 					goto __TERMINAL;

  002da	eb 41		 jmp	 SHORT $__TERMINAL$28
$LN21@ylight_ser:

; 137  : 				}
; 138  : 				/* Quit the loop. */
; 139  : 				incoming_data[ret] = 0;

  002dc	8b 45 f4	 mov	 eax, DWORD PTR _incoming_data$[ebp]
  002df	03 45 f8	 add	 eax, DWORD PTR _ret$[ebp]
  002e2	c6 00 00	 mov	 BYTE PTR [eax], 0

; 140  : 				if (0 == strcmp(incoming_data, "quit"))

  002e5	68 00 00 00 00	 push	 OFFSET $SG5054
  002ea	8b 4d f4	 mov	 ecx, DWORD PTR _incoming_data$[ebp]
  002ed	51		 push	 ecx
  002ee	e8 00 00 00 00	 call	 _strcmp
  002f3	83 c4 08	 add	 esp, 8
  002f6	85 c0		 test	 eax, eax
  002f8	75 02		 jne	 SHORT $LN22@ylight_ser

; 141  : 				{
; 142  : 					goto __TERMINAL;

  002fa	eb 21		 jmp	 SHORT $__TERMINAL$28
$LN22@ylight_ser:

; 143  : 				}
; 144  : 			}

  002fc	eb 02		 jmp	 SHORT $LN18@ylight_ser
$LN17@ylight_ser:

; 145  : 			else /* The connection may lost. */
; 146  : 			{
; 147  : 				break;

  002fe	eb 05		 jmp	 SHORT $LN5@ylight_ser
$LN18@ylight_ser:

; 148  : 			}
; 149  : 		}

  00300	e9 f6 fe ff ff	 jmp	 $LN4@ylight_ser
$LN5@ylight_ser:

; 150  : 		/* Close the connection. */
; 151  : 		close(clt_sock);

  00305	8b 55 e8	 mov	 edx, DWORD PTR _clt_sock$[ebp]
  00308	52		 push	 edx
  00309	e8 00 00 00 00	 call	 _close
  0030e	83 c4 04	 add	 esp, 4

; 152  : 		clt_sock = -1;

  00311	c7 45 e8 ff ff
	ff ff		 mov	 DWORD PTR _clt_sock$[ebp], -1

; 153  : 	}

  00318	e9 66 fe ff ff	 jmp	 $LN2@ylight_ser
$__TERMINAL$28:

; 154  : 
; 155  : __TERMINAL:
; 156  : 	/* Close all opened socket(s). */
; 157  : 	if (srv_sock > 0)

  0031d	83 7d f0 00	 cmp	 DWORD PTR _srv_sock$[ebp], 0
  00321	7e 0c		 jle	 SHORT $LN23@ylight_ser

; 158  : 	{
; 159  : 		close(srv_sock);

  00323	8b 45 f0	 mov	 eax, DWORD PTR _srv_sock$[ebp]
  00326	50		 push	 eax
  00327	e8 00 00 00 00	 call	 _close
  0032c	83 c4 04	 add	 esp, 4
$LN23@ylight_ser:

; 160  : 	}
; 161  : 	if (clt_sock > 0)

  0032f	83 7d e8 00	 cmp	 DWORD PTR _clt_sock$[ebp], 0
  00333	7e 0c		 jle	 SHORT $LN24@ylight_ser

; 162  : 	{
; 163  : 		close(clt_sock);

  00335	8b 4d e8	 mov	 ecx, DWORD PTR _clt_sock$[ebp]
  00338	51		 push	 ecx
  00339	e8 00 00 00 00	 call	 _close
  0033e	83 c4 04	 add	 esp, 4
$LN24@ylight_ser:

; 164  : 	}
; 165  : 	/* Release receiving buffer. */
; 166  : 	if (incoming_data)

  00341	83 7d f4 00	 cmp	 DWORD PTR _incoming_data$[ebp], 0
  00345	74 0c		 je	 SHORT $LN25@ylight_ser

; 167  : 	{
; 168  : 		_hx_free(incoming_data);

  00347	8b 55 f4	 mov	 edx, DWORD PTR _incoming_data$[ebp]
  0034a	52		 push	 edx
  0034b	e8 00 00 00 00	 call	 __hx_free
  00350	83 c4 04	 add	 esp, 4
$LN25@ylight_ser:

; 169  : 	}
; 170  : 	/* Show exit message. */
; 171  : 	__LOG("Bulb server exit.\r\n");

  00353	6a 00		 push	 0
  00355	e8 00 00 00 00	 call	 _LogHeader
  0035a	83 c4 04	 add	 esp, 4
  0035d	68 00 00 00 00	 push	 OFFSET $SG5058
  00362	e8 00 00 00 00	 call	 __hx_printf
  00367	83 c4 04	 add	 esp, 4

; 172  : 	return 0;

  0036a	33 c0		 xor	 eax, eax

; 173  : }

  0036c	8b e5		 mov	 esp, ebp
  0036e	5d		 pop	 ebp
  0036f	c3		 ret	 0
_ylight_server ENDP
_TEXT	ENDS
END
