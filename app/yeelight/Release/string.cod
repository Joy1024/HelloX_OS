; Listing generated by Microsoft (R) Optimizing Compiler Version 19.13.26128.0 

	TITLE	C:\HelloX\personal\HelloX_OS\app\yeelight\hxlib\string.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_strcat
PUBLIC	_strcpy
PUBLIC	_strchr
PUBLIC	_strrchr
PUBLIC	_strstr
PUBLIC	_strcmp
PUBLIC	_strlen
PUBLIC	_strncpy
PUBLIC	_strncmp
PUBLIC	_strtrim
PUBLIC	_strtol
PUBLIC	_strtok
PUBLIC	_ffs
EXTRN	_memcpy:PROC
EXTRN	_abort:PROC
EXTRN	___ctype:DWORD
_BSS	SEGMENT
?last@?1??strtok@@9@9 DD 01H DUP (?)			; `strtok'::`2'::last
_BSS	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\string.c
;	COMDAT _ffs
_TEXT	SEGMENT
_r$ = -4						; size = 4
_x$ = 8							; size = 4
_ffs	PROC						; COMDAT

; 162  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 163  : 	int r = 1;

  00004	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _r$[ebp], 1

; 164  : 	if(!x)

  0000b	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  0000f	75 07		 jne	 SHORT $LN2@ffs

; 165  : 	{
; 166  : 		return 0;

  00011	33 c0		 xor	 eax, eax
  00013	e9 88 00 00 00	 jmp	 $LN1@ffs
$LN2@ffs:

; 167  : 	}
; 168  : 	if(!(x & 0xFFFF))

  00018	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0001b	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00020	75 12		 jne	 SHORT $LN3@ffs

; 169  : 	{
; 170  : 		x >>= 16;

  00022	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00025	c1 f9 10	 sar	 ecx, 16			; 00000010H
  00028	89 4d 08	 mov	 DWORD PTR _x$[ebp], ecx

; 171  : 		r += 16;

  0002b	8b 55 fc	 mov	 edx, DWORD PTR _r$[ebp]
  0002e	83 c2 10	 add	 edx, 16			; 00000010H
  00031	89 55 fc	 mov	 DWORD PTR _r$[ebp], edx
$LN3@ffs:

; 172  : 	}
; 173  : 	if(!(x & 0xFF))

  00034	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00037	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0003c	75 12		 jne	 SHORT $LN4@ffs

; 174  : 	{
; 175  : 		x >>= 8;

  0003e	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00041	c1 f9 08	 sar	 ecx, 8
  00044	89 4d 08	 mov	 DWORD PTR _x$[ebp], ecx

; 176  : 		r += 8;

  00047	8b 55 fc	 mov	 edx, DWORD PTR _r$[ebp]
  0004a	83 c2 08	 add	 edx, 8
  0004d	89 55 fc	 mov	 DWORD PTR _r$[ebp], edx
$LN4@ffs:

; 177  : 	}
; 178  : 	if(!(x & 0x0F))

  00050	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00053	83 e0 0f	 and	 eax, 15			; 0000000fH
  00056	75 12		 jne	 SHORT $LN5@ffs

; 179  : 	{
; 180  : 		x >>= 4;

  00058	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0005b	c1 f9 04	 sar	 ecx, 4
  0005e	89 4d 08	 mov	 DWORD PTR _x$[ebp], ecx

; 181  : 		r += 4;

  00061	8b 55 fc	 mov	 edx, DWORD PTR _r$[ebp]
  00064	83 c2 04	 add	 edx, 4
  00067	89 55 fc	 mov	 DWORD PTR _r$[ebp], edx
$LN5@ffs:

; 182  : 	}
; 183  : 	if(!(x & 3))

  0006a	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0006d	83 e0 03	 and	 eax, 3
  00070	75 12		 jne	 SHORT $LN6@ffs

; 184  : 	{
; 185  : 		x >>= 2;

  00072	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00075	c1 f9 02	 sar	 ecx, 2
  00078	89 4d 08	 mov	 DWORD PTR _x$[ebp], ecx

; 186  : 		r += 2;

  0007b	8b 55 fc	 mov	 edx, DWORD PTR _r$[ebp]
  0007e	83 c2 02	 add	 edx, 2
  00081	89 55 fc	 mov	 DWORD PTR _r$[ebp], edx
$LN6@ffs:

; 187  : 	}
; 188  : 	if(!(x & 1))

  00084	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00087	83 e0 01	 and	 eax, 1
  0008a	75 11		 jne	 SHORT $LN7@ffs

; 189  : 	{
; 190  : 		x >>= 1;

  0008c	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0008f	d1 f9		 sar	 ecx, 1
  00091	89 4d 08	 mov	 DWORD PTR _x$[ebp], ecx

; 191  : 		r += 1;

  00094	8b 55 fc	 mov	 edx, DWORD PTR _r$[ebp]
  00097	83 c2 01	 add	 edx, 1
  0009a	89 55 fc	 mov	 DWORD PTR _r$[ebp], edx
$LN7@ffs:

; 192  : 	}
; 193  : 	return r;

  0009d	8b 45 fc	 mov	 eax, DWORD PTR _r$[ebp]
$LN1@ffs:

; 194  : }

  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
_ffs	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\string.c
;	COMDAT _strtok
_TEXT	SEGMENT
_map$ = -48						; size = 32
tv85 = -16						; size = 4
_count$ = -12						; size = 4
_ctrl$ = -8						; size = 4
_str$ = -4						; size = 4
_string_org$ = 8					; size = 4
_demial$ = 12						; size = 4
_strtok	PROC						; COMDAT

; 583  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H

; 584  : 	static unsigned char* last;
; 585  : 	unsigned char* str;
; 586  : 	const unsigned char* ctrl = (const unsigned char*)demial;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _demial$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _ctrl$[ebp], eax

; 587  : 	unsigned char map[32];
; 588  : 	int count;
; 589  : 
; 590  : 	for (count = 0; count <32; count++){

  0000c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  00013	eb 09		 jmp	 SHORT $LN4@strtok
$LN2@strtok:
  00015	8b 4d f4	 mov	 ecx, DWORD PTR _count$[ebp]
  00018	83 c1 01	 add	 ecx, 1
  0001b	89 4d f4	 mov	 DWORD PTR _count$[ebp], ecx
$LN4@strtok:
  0001e	83 7d f4 20	 cmp	 DWORD PTR _count$[ebp], 32 ; 00000020H
  00022	7d 0a		 jge	 SHORT $LN7@strtok

; 591  : 		map[count] = 0;

  00024	8b 55 f4	 mov	 edx, DWORD PTR _count$[ebp]
  00027	c6 44 15 d0 00	 mov	 BYTE PTR _map$[ebp+edx], 0

; 592  : 	}

  0002c	eb e7		 jmp	 SHORT $LN2@strtok
$LN7@strtok:

; 593  : 	do {
; 594  : 		map[*ctrl >> 3] |= (1 << (*ctrl & 7));

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _ctrl$[ebp]
  00031	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00034	c1 fa 03	 sar	 edx, 3
  00037	8b 45 f8	 mov	 eax, DWORD PTR _ctrl$[ebp]
  0003a	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0003d	83 e1 07	 and	 ecx, 7
  00040	b8 01 00 00 00	 mov	 eax, 1
  00045	d3 e0		 shl	 eax, cl
  00047	0f b6 4c 15 d0	 movzx	 ecx, BYTE PTR _map$[ebp+edx]
  0004c	0b c8		 or	 ecx, eax
  0004e	8b 55 f8	 mov	 edx, DWORD PTR _ctrl$[ebp]
  00051	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00054	c1 f8 03	 sar	 eax, 3
  00057	88 4c 05 d0	 mov	 BYTE PTR _map$[ebp+eax], cl

; 595  : 	} while (*ctrl++);

  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _ctrl$[ebp]
  0005e	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00061	89 55 f0	 mov	 DWORD PTR tv85[ebp], edx
  00064	8b 45 f8	 mov	 eax, DWORD PTR _ctrl$[ebp]
  00067	83 c0 01	 add	 eax, 1
  0006a	89 45 f8	 mov	 DWORD PTR _ctrl$[ebp], eax
  0006d	83 7d f0 00	 cmp	 DWORD PTR tv85[ebp], 0
  00071	75 bb		 jne	 SHORT $LN7@strtok

; 596  : 	if (string_org){

  00073	83 7d 08 00	 cmp	 DWORD PTR _string_org$[ebp], 0
  00077	74 08		 je	 SHORT $LN13@strtok

; 597  : 		str = (unsigned char*)string_org;

  00079	8b 4d 08	 mov	 ecx, DWORD PTR _string_org$[ebp]
  0007c	89 4d fc	 mov	 DWORD PTR _str$[ebp], ecx

; 598  : 	}

  0007f	eb 09		 jmp	 SHORT $LN8@strtok
$LN13@strtok:

; 599  : 	else{
; 600  : 		str = last;

  00081	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?last@?1??strtok@@9@9
  00087	89 55 fc	 mov	 DWORD PTR _str$[ebp], edx
$LN8@strtok:

; 601  : 	}
; 602  : 	while ((map[*str >> 3] & (1 << (*str & 7))) && *str){

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  0008d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00090	c1 f9 03	 sar	 ecx, 3
  00093	0f b6 54 0d d0	 movzx	 edx, BYTE PTR _map$[ebp+ecx]
  00098	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  0009b	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0009e	83 e1 07	 and	 ecx, 7
  000a1	b8 01 00 00 00	 mov	 eax, 1
  000a6	d3 e0		 shl	 eax, cl
  000a8	23 d0		 and	 edx, eax
  000aa	74 15		 je	 SHORT $LN9@strtok
  000ac	8b 4d fc	 mov	 ecx, DWORD PTR _str$[ebp]
  000af	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  000b2	85 d2		 test	 edx, edx
  000b4	74 0b		 je	 SHORT $LN9@strtok

; 603  : 		str++;

  000b6	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  000b9	83 c0 01	 add	 eax, 1
  000bc	89 45 fc	 mov	 DWORD PTR _str$[ebp], eax

; 604  : 	}

  000bf	eb c9		 jmp	 SHORT $LN8@strtok
$LN9@strtok:

; 605  : 	string_org = (char*)str;

  000c1	8b 4d fc	 mov	 ecx, DWORD PTR _str$[ebp]
  000c4	89 4d 08	 mov	 DWORD PTR _string_org$[ebp], ecx

; 606  : 	for (; *str; str++){

  000c7	eb 09		 jmp	 SHORT $LN12@strtok
$LN10@strtok:
  000c9	8b 55 fc	 mov	 edx, DWORD PTR _str$[ebp]
  000cc	83 c2 01	 add	 edx, 1
  000cf	89 55 fc	 mov	 DWORD PTR _str$[ebp], edx
$LN12@strtok:
  000d2	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  000d5	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000d8	85 c9		 test	 ecx, ecx
  000da	74 35		 je	 SHORT $LN11@strtok

; 607  : 		if (map[*str >> 3] & (1 << (*str & 7))){

  000dc	8b 55 fc	 mov	 edx, DWORD PTR _str$[ebp]
  000df	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000e2	c1 f8 03	 sar	 eax, 3
  000e5	0f b6 54 05 d0	 movzx	 edx, BYTE PTR _map$[ebp+eax]
  000ea	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  000ed	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  000f0	83 e1 07	 and	 ecx, 7
  000f3	b8 01 00 00 00	 mov	 eax, 1
  000f8	d3 e0		 shl	 eax, cl
  000fa	23 d0		 and	 edx, eax
  000fc	74 11		 je	 SHORT $LN15@strtok

; 608  : 			*str++ = '\0';

  000fe	8b 4d fc	 mov	 ecx, DWORD PTR _str$[ebp]
  00101	c6 01 00	 mov	 BYTE PTR [ecx], 0
  00104	8b 55 fc	 mov	 edx, DWORD PTR _str$[ebp]
  00107	83 c2 01	 add	 edx, 1
  0010a	89 55 fc	 mov	 DWORD PTR _str$[ebp], edx

; 609  : 			break;

  0010d	eb 02		 jmp	 SHORT $LN11@strtok
$LN15@strtok:

; 610  : 		}
; 611  : 	}

  0010f	eb b8		 jmp	 SHORT $LN10@strtok
$LN11@strtok:

; 612  : 	last = str;

  00111	8b 45 fc	 mov	 eax, DWORD PTR _str$[ebp]
  00114	a3 00 00 00 00	 mov	 DWORD PTR ?last@?1??strtok@@9@9, eax

; 613  : 	if (string_org == (char*)str){

  00119	8b 4d 08	 mov	 ecx, DWORD PTR _string_org$[ebp]
  0011c	3b 4d fc	 cmp	 ecx, DWORD PTR _str$[ebp]
  0011f	75 06		 jne	 SHORT $LN16@strtok

; 614  : 		return NULL;

  00121	33 c0		 xor	 eax, eax
  00123	eb 05		 jmp	 SHORT $LN1@strtok

; 615  : 	}

  00125	eb 03		 jmp	 SHORT $LN1@strtok
$LN16@strtok:

; 616  : 	else{
; 617  : 		return string_org;

  00127	8b 45 08	 mov	 eax, DWORD PTR _string_org$[ebp]
$LN1@strtok:

; 618  : 	}
; 619  : }

  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c3		 ret	 0
_strtok	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\string.c
;	COMDAT _strtol
_TEXT	SEGMENT
_LimitRemainder$ = -48					; size = 4
tv158 = -44						; size = 4
tv152 = -40						; size = 4
tv141 = -36						; size = 4
tv88 = -32						; size = 4
tv86 = -28						; size = 4
_sign$ = -24						; size = 4
_flag$ = -20						; size = 4
_Overflow$ = -16					; size = 4
_ret$ = -12						; size = 4
_p$ = -8						; size = 4
_ch$ = -4						; size = 4
_nptr$ = 8						; size = 4
_endptr$ = 12						; size = 4
_base$ = 16						; size = 4
_strtol	PROC						; COMDAT

; 210  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H

; 211  :    const char *p = nptr;

  00006	8b 45 08	 mov	 eax, DWORD PTR _nptr$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax

; 212  :    unsigned long ret;
; 213  :    int ch;
; 214  :    unsigned long Overflow;
; 215  :    int sign = 0, flag, LimitRemainder;

  0000c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _sign$[ebp], 0
$LN4@strtol:

; 216  :   
; 217  :    do
; 218  :    {
; 219  :       ch = *p++;

  00013	8b 4d f8	 mov	 ecx, DWORD PTR _p$[ebp]
  00016	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00019	89 55 fc	 mov	 DWORD PTR _ch$[ebp], edx
  0001c	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  0001f	83 c0 01	 add	 eax, 1
  00022	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax

; 220  :    } while (' ' == ch);

  00025	83 7d fc 20	 cmp	 DWORD PTR _ch$[ebp], 32	; 00000020H
  00029	74 e8		 je	 SHORT $LN4@strtol

; 221  :   
; 222  :    if (ch == '-')

  0002b	83 7d fc 2d	 cmp	 DWORD PTR _ch$[ebp], 45	; 0000002dH
  0002f	75 1b		 jne	 SHORT $LN8@strtol

; 223  :    {
; 224  :       sign = 1;

  00031	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _sign$[ebp], 1

; 225  :       ch = *p++;

  00038	8b 4d f8	 mov	 ecx, DWORD PTR _p$[ebp]
  0003b	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0003e	89 55 fc	 mov	 DWORD PTR _ch$[ebp], edx
  00041	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00044	83 c0 01	 add	 eax, 1
  00047	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax

; 226  :    }

  0004a	eb 18		 jmp	 SHORT $LN9@strtol
$LN8@strtol:

; 227  :    else if (ch == '+')

  0004c	83 7d fc 2b	 cmp	 DWORD PTR _ch$[ebp], 43	; 0000002bH
  00050	75 12		 jne	 SHORT $LN9@strtol

; 228  :       ch = *p++;

  00052	8b 4d f8	 mov	 ecx, DWORD PTR _p$[ebp]
  00055	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00058	89 55 fc	 mov	 DWORD PTR _ch$[ebp], edx
  0005b	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  0005e	83 c0 01	 add	 eax, 1
  00061	89 45 f8	 mov	 DWORD PTR _p$[ebp], eax
$LN9@strtol:

; 229  :    if ((base == 0 || base == 16) &&
; 230  :       ch == '0' && (*p == 'x' || *p == 'X'))

  00064	83 7d 10 00	 cmp	 DWORD PTR _base$[ebp], 0
  00068	74 06		 je	 SHORT $LN12@strtol
  0006a	83 7d 10 10	 cmp	 DWORD PTR _base$[ebp], 16 ; 00000010H
  0006e	75 3e		 jne	 SHORT $LN11@strtol
$LN12@strtol:
  00070	83 7d fc 30	 cmp	 DWORD PTR _ch$[ebp], 48	; 00000030H
  00074	75 38		 jne	 SHORT $LN11@strtol
  00076	8b 4d f8	 mov	 ecx, DWORD PTR _p$[ebp]
  00079	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0007c	83 fa 78	 cmp	 edx, 120		; 00000078H
  0007f	74 0b		 je	 SHORT $LN13@strtol
  00081	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00084	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00087	83 f9 58	 cmp	 ecx, 88			; 00000058H
  0008a	75 22		 jne	 SHORT $LN11@strtol
$LN13@strtol:

; 231  :    {
; 232  :       ch = p[1];

  0008c	ba 01 00 00 00	 mov	 edx, 1
  00091	c1 e2 00	 shl	 edx, 0
  00094	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00097	0f be 0c 10	 movsx	 ecx, BYTE PTR [eax+edx]
  0009b	89 4d fc	 mov	 DWORD PTR _ch$[ebp], ecx

; 233  :       p += 2;

  0009e	8b 55 f8	 mov	 edx, DWORD PTR _p$[ebp]
  000a1	83 c2 02	 add	 edx, 2
  000a4	89 55 f8	 mov	 DWORD PTR _p$[ebp], edx

; 234  :       base = 16;

  000a7	c7 45 10 10 00
	00 00		 mov	 DWORD PTR _base$[ebp], 16 ; 00000010H
$LN11@strtol:

; 235  :    }
; 236  :    if (base == 0)

  000ae	83 7d 10 00	 cmp	 DWORD PTR _base$[ebp], 0
  000b2	75 1c		 jne	 SHORT $LN14@strtol

; 237  :       base = ch == '0' ? 8 : 10;

  000b4	83 7d fc 30	 cmp	 DWORD PTR _ch$[ebp], 48	; 00000030H
  000b8	75 09		 jne	 SHORT $LN28@strtol
  000ba	c7 45 e4 08 00
	00 00		 mov	 DWORD PTR tv86[ebp], 8
  000c1	eb 07		 jmp	 SHORT $LN29@strtol
$LN28@strtol:
  000c3	c7 45 e4 0a 00
	00 00		 mov	 DWORD PTR tv86[ebp], 10	; 0000000aH
$LN29@strtol:
  000ca	8b 45 e4	 mov	 eax, DWORD PTR tv86[ebp]
  000cd	89 45 10	 mov	 DWORD PTR _base$[ebp], eax
$LN14@strtol:

; 238  :  
; 239  :    Overflow = sign ? -(unsigned long)LONG_MIN : LONG_MAX;

  000d0	83 7d e8 00	 cmp	 DWORD PTR _sign$[ebp], 0
  000d4	74 09		 je	 SHORT $LN30@strtol
  000d6	c7 45 e0 00 00
	00 80		 mov	 DWORD PTR tv88[ebp], -2147483648 ; 80000000H
  000dd	eb 07		 jmp	 SHORT $LN31@strtol
$LN30@strtol:
  000df	c7 45 e0 ff ff
	ff 7f		 mov	 DWORD PTR tv88[ebp], 2147483647 ; 7fffffffH
$LN31@strtol:
  000e6	8b 4d e0	 mov	 ecx, DWORD PTR tv88[ebp]
  000e9	89 4d f0	 mov	 DWORD PTR _Overflow$[ebp], ecx

; 240  :    LimitRemainder = Overflow % (unsigned long)base;

  000ec	8b 45 f0	 mov	 eax, DWORD PTR _Overflow$[ebp]
  000ef	33 d2		 xor	 edx, edx
  000f1	f7 75 10	 div	 DWORD PTR _base$[ebp]
  000f4	89 55 d0	 mov	 DWORD PTR _LimitRemainder$[ebp], edx

; 241  :    Overflow /= (unsigned long)base;

  000f7	8b 45 f0	 mov	 eax, DWORD PTR _Overflow$[ebp]
  000fa	33 d2		 xor	 edx, edx
  000fc	f7 75 10	 div	 DWORD PTR _base$[ebp]
  000ff	89 45 f0	 mov	 DWORD PTR _Overflow$[ebp], eax

; 242  :  
; 243  :    for (ret = 0, flag = 0;; ch = *p++)

  00102	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0
  00109	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _flag$[ebp], 0
  00110	eb 12		 jmp	 SHORT $LN7@strtol
$LN5@strtol:
  00112	8b 55 f8	 mov	 edx, DWORD PTR _p$[ebp]
  00115	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00118	89 45 fc	 mov	 DWORD PTR _ch$[ebp], eax
  0011b	8b 4d f8	 mov	 ecx, DWORD PTR _p$[ebp]
  0011e	83 c1 01	 add	 ecx, 1
  00121	89 4d f8	 mov	 DWORD PTR _p$[ebp], ecx
$LN7@strtol:

; 244  :    {
; 245  :       if (isdigit(ch))

  00124	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ___ctype
  0012a	03 55 fc	 add	 edx, DWORD PTR _ch$[ebp]
  0012d	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00130	83 e0 04	 and	 eax, 4
  00133	74 0b		 je	 SHORT $LN15@strtol

; 246  :         ch -= '0';

  00135	8b 4d fc	 mov	 ecx, DWORD PTR _ch$[ebp]
  00138	83 e9 30	 sub	 ecx, 48			; 00000030H
  0013b	89 4d fc	 mov	 DWORD PTR _ch$[ebp], ecx
  0013e	eb 3f		 jmp	 SHORT $LN16@strtol
$LN15@strtol:

; 247  :       else if (isalpha(ch))

  00140	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ___ctype
  00146	03 55 fc	 add	 edx, DWORD PTR _ch$[ebp]
  00149	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0014c	83 e0 03	 and	 eax, 3
  0014f	74 2c		 je	 SHORT $LN17@strtol

; 248  :         ch -= isupper(ch) ? 'A' - 10 : 'a' - 10;

  00151	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ___ctype
  00157	03 4d fc	 add	 ecx, DWORD PTR _ch$[ebp]
  0015a	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0015d	83 e2 01	 and	 edx, 1
  00160	74 09		 je	 SHORT $LN32@strtol
  00162	c7 45 dc 37 00
	00 00		 mov	 DWORD PTR tv141[ebp], 55 ; 00000037H
  00169	eb 07		 jmp	 SHORT $LN33@strtol
$LN32@strtol:
  0016b	c7 45 dc 57 00
	00 00		 mov	 DWORD PTR tv141[ebp], 87 ; 00000057H
$LN33@strtol:
  00172	8b 45 fc	 mov	 eax, DWORD PTR _ch$[ebp]
  00175	2b 45 dc	 sub	 eax, DWORD PTR tv141[ebp]
  00178	89 45 fc	 mov	 DWORD PTR _ch$[ebp], eax
  0017b	eb 02		 jmp	 SHORT $LN16@strtol
$LN17@strtol:

; 249  :       else
; 250  :         break;

  0017d	eb 50		 jmp	 SHORT $LN6@strtol
$LN16@strtol:

; 251  :       if (ch >= base)

  0017f	8b 4d fc	 mov	 ecx, DWORD PTR _ch$[ebp]
  00182	3b 4d 10	 cmp	 ecx, DWORD PTR _base$[ebp]
  00185	7c 02		 jl	 SHORT $LN19@strtol

; 252  :         break;

  00187	eb 46		 jmp	 SHORT $LN6@strtol
$LN19@strtol:

; 253  :  
; 254  :       if (flag < 0 || ret > Overflow || (ret == Overflow && ch > LimitRemainder))

  00189	83 7d ec 00	 cmp	 DWORD PTR _flag$[ebp], 0
  0018d	7c 18		 jl	 SHORT $LN22@strtol
  0018f	8b 55 f4	 mov	 edx, DWORD PTR _ret$[ebp]
  00192	3b 55 f0	 cmp	 edx, DWORD PTR _Overflow$[ebp]
  00195	77 10		 ja	 SHORT $LN22@strtol
  00197	8b 45 f4	 mov	 eax, DWORD PTR _ret$[ebp]
  0019a	3b 45 f0	 cmp	 eax, DWORD PTR _Overflow$[ebp]
  0019d	75 11		 jne	 SHORT $LN20@strtol
  0019f	8b 4d fc	 mov	 ecx, DWORD PTR _ch$[ebp]
  001a2	3b 4d d0	 cmp	 ecx, DWORD PTR _LimitRemainder$[ebp]
  001a5	7e 09		 jle	 SHORT $LN20@strtol
$LN22@strtol:

; 255  :         flag = -1;

  001a7	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR _flag$[ebp], -1
  001ae	eb 1a		 jmp	 SHORT $LN21@strtol
$LN20@strtol:

; 256  :       else
; 257  :       {
; 258  :         flag = 1;

  001b0	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _flag$[ebp], 1

; 259  :         ret *= base;

  001b7	8b 55 f4	 mov	 edx, DWORD PTR _ret$[ebp]
  001ba	0f af 55 10	 imul	 edx, DWORD PTR _base$[ebp]
  001be	89 55 f4	 mov	 DWORD PTR _ret$[ebp], edx

; 260  :         ret += ch;

  001c1	8b 45 f4	 mov	 eax, DWORD PTR _ret$[ebp]
  001c4	03 45 fc	 add	 eax, DWORD PTR _ch$[ebp]
  001c7	89 45 f4	 mov	 DWORD PTR _ret$[ebp], eax
$LN21@strtol:

; 261  :       }
; 262  :    }

  001ca	e9 43 ff ff ff	 jmp	 $LN5@strtol
$LN6@strtol:

; 263  :  
; 264  :    if (flag < 0)

  001cf	83 7d ec 00	 cmp	 DWORD PTR _flag$[ebp], 0
  001d3	7d 1e		 jge	 SHORT $LN23@strtol

; 265  :       ret = sign ? LONG_MIN : LONG_MAX;

  001d5	83 7d e8 00	 cmp	 DWORD PTR _sign$[ebp], 0
  001d9	74 09		 je	 SHORT $LN34@strtol
  001db	c7 45 d8 00 00
	00 80		 mov	 DWORD PTR tv152[ebp], -2147483648 ; 80000000H
  001e2	eb 07		 jmp	 SHORT $LN35@strtol
$LN34@strtol:
  001e4	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR tv152[ebp], 2147483647 ; 7fffffffH
$LN35@strtol:
  001eb	8b 4d d8	 mov	 ecx, DWORD PTR tv152[ebp]
  001ee	89 4d f4	 mov	 DWORD PTR _ret$[ebp], ecx
  001f1	eb 0e		 jmp	 SHORT $LN24@strtol
$LN23@strtol:

; 266  :    else if (sign)

  001f3	83 7d e8 00	 cmp	 DWORD PTR _sign$[ebp], 0
  001f7	74 08		 je	 SHORT $LN24@strtol

; 267  :       ret = -ret;

  001f9	8b 55 f4	 mov	 edx, DWORD PTR _ret$[ebp]
  001fc	f7 da		 neg	 edx
  001fe	89 55 f4	 mov	 DWORD PTR _ret$[ebp], edx
$LN24@strtol:

; 268  :    if (endptr != 0)

  00201	83 7d 0c 00	 cmp	 DWORD PTR _endptr$[ebp], 0
  00205	74 1f		 je	 SHORT $LN26@strtol

; 269  :       *endptr = (char *)(flag ?(p - 1) : nptr);

  00207	83 7d ec 00	 cmp	 DWORD PTR _flag$[ebp], 0
  0020b	74 0b		 je	 SHORT $LN36@strtol
  0020d	8b 45 f8	 mov	 eax, DWORD PTR _p$[ebp]
  00210	83 e8 01	 sub	 eax, 1
  00213	89 45 d4	 mov	 DWORD PTR tv158[ebp], eax
  00216	eb 06		 jmp	 SHORT $LN37@strtol
$LN36@strtol:
  00218	8b 4d 08	 mov	 ecx, DWORD PTR _nptr$[ebp]
  0021b	89 4d d4	 mov	 DWORD PTR tv158[ebp], ecx
$LN37@strtol:
  0021e	8b 55 0c	 mov	 edx, DWORD PTR _endptr$[ebp]
  00221	8b 45 d4	 mov	 eax, DWORD PTR tv158[ebp]
  00224	89 02		 mov	 DWORD PTR [edx], eax
$LN26@strtol:

; 270  :  
; 271  :    return ret;

  00226	8b 45 f4	 mov	 eax, DWORD PTR _ret$[ebp]

; 272  : }

  00229	8b e5		 mov	 esp, ebp
  0022b	5d		 pop	 ebp
  0022c	c3		 ret	 0
_strtol	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\string.c
;	COMDAT _strtrim
_TEXT	SEGMENT
_pos$ = -12						; size = 4
_len$ = -8						; size = 4
_i$ = -4						; size = 4
_dst$ = 8						; size = 4
_flag$ = 12						; size = 4
_strtrim PROC						; COMDAT

; 71   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 72   : 	char* pos   = dst;

  00006	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR _pos$[ebp], eax

; 73   : 	int   len   = 0;

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 74   : 	int   i     = 0;

  00013	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 75   : 	
; 76   : 	if(NULL == dst)

  0001a	83 7d 08 00	 cmp	 DWORD PTR _dst$[ebp], 0
  0001e	75 05		 jne	 SHORT $LN7@strtrim

; 77   : 	{
; 78   : 		return;

  00020	e9 cf 00 00 00	 jmp	 $LN1@strtrim
$LN7@strtrim:

; 79   : 	}
; 80   : 
; 81   : 	len = strlen(dst);

  00025	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 _strlen
  0002e	83 c4 04	 add	 esp, 4
  00031	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 82   : 	if(len <= 0)

  00034	83 7d f8 00	 cmp	 DWORD PTR _len$[ebp], 0
  00038	7f 05		 jg	 SHORT $LN8@strtrim

; 83   : 	{
; 84   : 		return; 

  0003a	e9 b5 00 00 00	 jmp	 $LN1@strtrim
$LN8@strtrim:

; 85   : 	}
; 86   : 	if(flag&TRIM_LEFT)

  0003f	8b 55 0c	 mov	 edx, DWORD PTR _flag$[ebp]
  00042	83 e2 01	 and	 edx, 1
  00045	74 6e		 je	 SHORT $LN9@strtrim
$LN2@strtrim:

; 87   : 	{
; 88   : 		while(i < len)

  00047	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0004a	3b 45 f8	 cmp	 eax, DWORD PTR _len$[ebp]
  0004d	7d 21		 jge	 SHORT $LN3@strtrim

; 89   : 		{
; 90   : 			if(*pos != 0x20) 

  0004f	8b 4d f4	 mov	 ecx, DWORD PTR _pos$[ebp]
  00052	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00055	83 fa 20	 cmp	 edx, 32			; 00000020H
  00058	74 02		 je	 SHORT $LN10@strtrim

; 91   : 			{
; 92   : 				break;

  0005a	eb 14		 jmp	 SHORT $LN3@strtrim
$LN10@strtrim:

; 93   : 			}
; 94   : 
; 95   : 			pos ++;

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _pos$[ebp]
  0005f	83 c0 01	 add	 eax, 1
  00062	89 45 f4	 mov	 DWORD PTR _pos$[ebp], eax

; 96   : 			i   ++;

  00065	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00068	83 c1 01	 add	 ecx, 1
  0006b	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx

; 97   : 		}

  0006e	eb d7		 jmp	 SHORT $LN2@strtrim
$LN3@strtrim:

; 98   : 
; 99   : 		//ȫ�ǿո�
; 100  : 		if(len == i)

  00070	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  00073	3b 55 fc	 cmp	 edx, DWORD PTR _i$[ebp]
  00076	75 11		 jne	 SHORT $LN11@strtrim

; 101  : 		{
; 102  : 			dst[0] = 0;

  00078	b8 01 00 00 00	 mov	 eax, 1
  0007d	6b c8 00	 imul	 ecx, eax, 0
  00080	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  00083	c6 04 0a 00	 mov	 BYTE PTR [edx+ecx], 0

; 103  : 			return;

  00087	eb 6b		 jmp	 SHORT $LN1@strtrim
$LN11@strtrim:

; 104  : 		}
; 105  : 
; 106  : 		if(i > 0) 

  00089	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  0008d	7e 26		 jle	 SHORT $LN9@strtrim

; 107  : 		{
; 108  : 			len -=  i;

  0008f	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  00092	2b 45 fc	 sub	 eax, DWORD PTR _i$[ebp]
  00095	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 109  : 			memcpy(dst,pos,len);

  00098	8b 4d f8	 mov	 ecx, DWORD PTR _len$[ebp]
  0009b	51		 push	 ecx
  0009c	8b 55 f4	 mov	 edx, DWORD PTR _pos$[ebp]
  0009f	52		 push	 edx
  000a0	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 _memcpy
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 110  : 			dst[len] = 0;

  000ac	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000af	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  000b2	c6 01 00	 mov	 BYTE PTR [ecx], 0
$LN9@strtrim:

; 111  : 		}
; 112  : 	}
; 113  : 	
; 114  : 	if(flag&TRIM_RIGHT)

  000b5	8b 55 0c	 mov	 edx, DWORD PTR _flag$[ebp]
  000b8	83 e2 02	 and	 edx, 2
  000bb	74 37		 je	 SHORT $LN1@strtrim

; 115  : 	{
; 116  : 		for(i = len-1; i >= 0;i--)

  000bd	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  000c0	83 e8 01	 sub	 eax, 1
  000c3	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  000c6	eb 09		 jmp	 SHORT $LN6@strtrim
$LN4@strtrim:
  000c8	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000cb	83 e9 01	 sub	 ecx, 1
  000ce	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
$LN6@strtrim:
  000d1	83 7d fc 00	 cmp	 DWORD PTR _i$[ebp], 0
  000d5	7c 1d		 jl	 SHORT $LN1@strtrim

; 117  : 		{
; 118  : 			if(dst[i] == 0x20)

  000d7	8b 55 08	 mov	 edx, DWORD PTR _dst$[ebp]
  000da	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000dd	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000e0	83 f8 20	 cmp	 eax, 32			; 00000020H
  000e3	75 0b		 jne	 SHORT $LN14@strtrim

; 119  : 			{
; 120  : 				dst[i] = 0;

  000e5	8b 4d 08	 mov	 ecx, DWORD PTR _dst$[ebp]
  000e8	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  000eb	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 121  : 			}

  000ee	eb 02		 jmp	 SHORT $LN15@strtrim
$LN14@strtrim:

; 122  : 			else
; 123  : 			{
; 124  : 				break;

  000f0	eb 02		 jmp	 SHORT $LN1@strtrim
$LN15@strtrim:

; 125  : 			}
; 126  : 		}

  000f2	eb d4		 jmp	 SHORT $LN4@strtrim
$LN1@strtrim:

; 127  : 	}
; 128  : 	
; 129  : }

  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
_strtrim ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\string.c
;	COMDAT _strncmp
_TEXT	SEGMENT
_s1$ = 8						; size = 4
_s2$ = 12						; size = 4
_n$ = 16						; size = 4
_strncmp PROC						; COMDAT

; 148  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 149  :   if ( !n )

  00003	83 7d 10 00	 cmp	 DWORD PTR _n$[ebp], 0
  00007	75 04		 jne	 SHORT $LN2@strncmp

; 150  :    return(0);

  00009	33 c0		 xor	 eax, eax
  0000b	eb 47		 jmp	 SHORT $LN1@strncmp
$LN2@strncmp:

; 151  : 
; 152  :   while (--n && *s1 && *s1 == *s2)

  0000d	8b 45 10	 mov	 eax, DWORD PTR _n$[ebp]
  00010	83 e8 01	 sub	 eax, 1
  00013	89 45 10	 mov	 DWORD PTR _n$[ebp], eax
  00016	74 2e		 je	 SHORT $LN3@strncmp
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _s1$[ebp]
  0001b	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0001e	85 d2		 test	 edx, edx
  00020	74 24		 je	 SHORT $LN3@strncmp
  00022	8b 45 08	 mov	 eax, DWORD PTR _s1$[ebp]
  00025	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00028	8b 55 0c	 mov	 edx, DWORD PTR _s2$[ebp]
  0002b	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0002e	3b c8		 cmp	 ecx, eax
  00030	75 14		 jne	 SHORT $LN3@strncmp

; 153  :   {
; 154  :      s1++;

  00032	8b 4d 08	 mov	 ecx, DWORD PTR _s1$[ebp]
  00035	83 c1 01	 add	 ecx, 1
  00038	89 4d 08	 mov	 DWORD PTR _s1$[ebp], ecx

; 155  :      s2++;

  0003b	8b 55 0c	 mov	 edx, DWORD PTR _s2$[ebp]
  0003e	83 c2 01	 add	 edx, 1
  00041	89 55 0c	 mov	 DWORD PTR _s2$[ebp], edx

; 156  :   }

  00044	eb c7		 jmp	 SHORT $LN2@strncmp
$LN3@strncmp:

; 157  :   return( *s1 - *s2 );

  00046	8b 45 08	 mov	 eax, DWORD PTR _s1$[ebp]
  00049	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _s2$[ebp]
  0004f	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00052	2b c2		 sub	 eax, edx
$LN1@strncmp:

; 158  : }

  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_strncmp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\string.c
;	COMDAT _strncpy
_TEXT	SEGMENT
_strRtn$ = -8						; size = 4
tv69 = -4						; size = 4
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_n$ = 16						; size = 4
_strncpy PROC						; COMDAT

; 133  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 134  : 	char *strRtn=dest;

  00006	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _strRtn$[ebp], eax
$LN2@strncpy:

; 135  : 	while(n && (*dest++=*src++))

  0000c	83 7d 10 00	 cmp	 DWORD PTR _n$[ebp], 0
  00010	74 36		 je	 SHORT $LN3@strncpy
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  00015	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00018	8a 02		 mov	 al, BYTE PTR [edx]
  0001a	88 01		 mov	 BYTE PTR [ecx], al
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  0001f	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00022	89 55 fc	 mov	 DWORD PTR tv69[ebp], edx
  00025	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00028	83 c0 01	 add	 eax, 1
  0002b	89 45 08	 mov	 DWORD PTR _dest$[ebp], eax
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00031	83 c1 01	 add	 ecx, 1
  00034	89 4d 0c	 mov	 DWORD PTR _src$[ebp], ecx
  00037	83 7d fc 00	 cmp	 DWORD PTR tv69[ebp], 0
  0003b	74 0b		 je	 SHORT $LN3@strncpy

; 136  : 	{
; 137  : 		n--;

  0003d	8b 55 10	 mov	 edx, DWORD PTR _n$[ebp]
  00040	83 ea 01	 sub	 edx, 1
  00043	89 55 10	 mov	 DWORD PTR _n$[ebp], edx

; 138  : 	} 

  00046	eb c4		 jmp	 SHORT $LN2@strncpy
$LN3@strncpy:

; 139  : 	if(n){

  00048	83 7d 10 00	 cmp	 DWORD PTR _n$[ebp], 0
  0004c	74 16		 je	 SHORT $LN6@strncpy
$LN4@strncpy:

; 140  : 		while(--n)

  0004e	8b 45 10	 mov	 eax, DWORD PTR _n$[ebp]
  00051	83 e8 01	 sub	 eax, 1
  00054	89 45 10	 mov	 DWORD PTR _n$[ebp], eax
  00057	74 0b		 je	 SHORT $LN6@strncpy

; 141  : 			*dest++;  //There may be bug...

  00059	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  0005c	83 c1 01	 add	 ecx, 1
  0005f	89 4d 08	 mov	 DWORD PTR _dest$[ebp], ecx
  00062	eb ea		 jmp	 SHORT $LN4@strncpy
$LN6@strncpy:

; 142  : 	}  
; 143  :     return strRtn;  

  00064	8b 45 f8	 mov	 eax, DWORD PTR _strRtn$[ebp]

; 144  : } 

  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_strncpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\string.c
;	COMDAT _strlen
_TEXT	SEGMENT
_i$ = -4						; size = 4
_s$ = 8							; size = 4
_strlen	PROC						; COMDAT

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 41   :    int i;
; 42   :    for (i = 0; s[i]; i++) ;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0000b	eb 09		 jmp	 SHORT $LN4@strlen
$LN2@strlen:
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00010	83 c0 01	 add	 eax, 1
  00013	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@strlen:
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00019	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  0001c	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0001f	85 d2		 test	 edx, edx
  00021	74 02		 je	 SHORT $LN3@strlen
  00023	eb e8		 jmp	 SHORT $LN2@strlen
$LN3@strlen:

; 43   :    return i;

  00025	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]

; 44   : }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
_strlen	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\string.c
;	COMDAT _strcmp
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
_strcmp	PROC						; COMDAT

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 29   :         int ret = 0 ;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0
$LN2@strcmp:

; 30   :         while( ! (ret = *(unsigned char *)src - *(unsigned char *)dst) && *dst)

  0000b	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0000e	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00011	8b 55 0c	 mov	 edx, DWORD PTR _dst$[ebp]
  00014	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00017	2b c8		 sub	 ecx, eax
  00019	89 4d fc	 mov	 DWORD PTR _ret$[ebp], ecx
  0001c	75 1e		 jne	 SHORT $LN3@strcmp
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR _dst$[ebp]
  00021	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00024	85 d2		 test	 edx, edx
  00026	74 14		 je	 SHORT $LN3@strcmp

; 31   :                 ++src, ++dst;  

  00028	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0002b	83 c0 01	 add	 eax, 1
  0002e	89 45 08	 mov	 DWORD PTR _src$[ebp], eax
  00031	8b 4d 0c	 mov	 ecx, DWORD PTR _dst$[ebp]
  00034	83 c1 01	 add	 ecx, 1
  00037	89 4d 0c	 mov	 DWORD PTR _dst$[ebp], ecx
  0003a	eb cf		 jmp	 SHORT $LN2@strcmp
$LN3@strcmp:

; 32   :         if ( ret < 0 )

  0003c	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00040	7d 09		 jge	 SHORT $LN4@strcmp

; 33   :                 ret = -1 ;

  00042	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -1
  00049	eb 0d		 jmp	 SHORT $LN5@strcmp
$LN4@strcmp:

; 34   :         else if ( ret > 0 )

  0004b	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0004f	7e 07		 jle	 SHORT $LN5@strcmp

; 35   :                 ret = 1 ;

  00051	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 1
$LN5@strcmp:

; 36   :         return( ret );

  00058	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]

; 37   : }

  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
_strcmp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\string.c
;	COMDAT _strstr
_TEXT	SEGMENT
_i$1 = -4						; size = 4
_s1$ = 8						; size = 4
_s2$ = 12						; size = 4
_strstr	PROC						; COMDAT

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 289  : 	if (*s1 == 0)

  00004	8b 45 08	 mov	 eax, DWORD PTR _s1$[ebp]
  00007	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0000a	85 c9		 test	 ecx, ecx
  0000c	75 13		 jne	 SHORT $LN2@strstr

; 290  : 	{
; 291  : 		if (*s2)

  0000e	8b 55 0c	 mov	 edx, DWORD PTR _s2$[ebp]
  00011	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00014	85 c0		 test	 eax, eax
  00016	74 04		 je	 SHORT $LN7@strstr

; 292  : 		{
; 293  : 			return (char *) NULL;

  00018	33 c0		 xor	 eax, eax
  0001a	eb 61		 jmp	 SHORT $LN1@strstr
$LN7@strstr:

; 294  : 		}
; 295  : 		return (char *) s1;

  0001c	8b 45 08	 mov	 eax, DWORD PTR _s1$[ebp]
  0001f	eb 5c		 jmp	 SHORT $LN1@strstr
$LN2@strstr:

; 296  : 	}
; 297  : 	while (*s1)

  00021	8b 4d 08	 mov	 ecx, DWORD PTR _s1$[ebp]
  00024	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00027	85 d2		 test	 edx, edx
  00029	74 50		 je	 SHORT $LN3@strstr

; 298  : 	{
; 299  : 		size_t i;
; 300  : 		i = 0;

  0002b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
$LN4@strstr:

; 301  : 		while (1)

  00032	b8 01 00 00 00	 mov	 eax, 1
  00037	85 c0		 test	 eax, eax
  00039	74 35		 je	 SHORT $LN5@strstr

; 302  : 		{
; 303  : 			if (s2[i] == 0)

  0003b	8b 4d 0c	 mov	 ecx, DWORD PTR _s2$[ebp]
  0003e	03 4d fc	 add	 ecx, DWORD PTR _i$1[ebp]
  00041	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00044	85 d2		 test	 edx, edx
  00046	75 05		 jne	 SHORT $LN8@strstr

; 304  : 			{
; 305  : 				return (char *) s1;

  00048	8b 45 08	 mov	 eax, DWORD PTR _s1$[ebp]
  0004b	eb 30		 jmp	 SHORT $LN1@strstr
$LN8@strstr:

; 306  : 			}
; 307  : 			if (s2[i] != s1[i])

  0004d	8b 45 0c	 mov	 eax, DWORD PTR _s2$[ebp]
  00050	03 45 fc	 add	 eax, DWORD PTR _i$1[ebp]
  00053	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00056	8b 55 08	 mov	 edx, DWORD PTR _s1$[ebp]
  00059	03 55 fc	 add	 edx, DWORD PTR _i$1[ebp]
  0005c	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0005f	3b c8		 cmp	 ecx, eax
  00061	74 02		 je	 SHORT $LN9@strstr

; 308  : 			{
; 309  : 				break;

  00063	eb 0b		 jmp	 SHORT $LN5@strstr
$LN9@strstr:

; 310  : 			}
; 311  : 			i++;

  00065	8b 4d fc	 mov	 ecx, DWORD PTR _i$1[ebp]
  00068	83 c1 01	 add	 ecx, 1
  0006b	89 4d fc	 mov	 DWORD PTR _i$1[ebp], ecx

; 312  : 		}

  0006e	eb c2		 jmp	 SHORT $LN4@strstr
$LN5@strstr:

; 313  : 		s1++;

  00070	8b 55 08	 mov	 edx, DWORD PTR _s1$[ebp]
  00073	83 c2 01	 add	 edx, 1
  00076	89 55 08	 mov	 DWORD PTR _s1$[ebp], edx

; 314  : 	}

  00079	eb a6		 jmp	 SHORT $LN2@strstr
$LN3@strstr:

; 315  : 	return (char *) NULL;

  0007b	33 c0		 xor	 eax, eax
$LN1@strstr:

; 316  : }

  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
_strstr	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\string.c
;	COMDAT _strrchr
_TEXT	SEGMENT
tv70 = -12						; size = 4
tv69 = -8						; size = 4
_p$ = -4						; size = 4
_str$ = 8						; size = 4
_ch$ = 12						; size = 4
_strrchr PROC						; COMDAT

; 276  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 277  : 	char *p = (char *)str;

  00006	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax
$LN2@strrchr:

; 278  : 	while (*str) str++;

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0000f	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00012	85 d2		 test	 edx, edx
  00014	74 0b		 je	 SHORT $LN4@strrchr
  00016	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00019	83 c0 01	 add	 eax, 1
  0001c	89 45 08	 mov	 DWORD PTR _str$[ebp], eax
  0001f	eb eb		 jmp	 SHORT $LN2@strrchr
$LN4@strrchr:

; 279  : 	while (str-- != p && *str != (char)ch);

  00021	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  00024	89 4d f8	 mov	 DWORD PTR tv69[ebp], ecx
  00027	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  0002a	89 55 f4	 mov	 DWORD PTR tv70[ebp], edx
  0002d	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00030	83 e8 01	 sub	 eax, 1
  00033	89 45 08	 mov	 DWORD PTR _str$[ebp], eax
  00036	8b 4d f8	 mov	 ecx, DWORD PTR tv69[ebp]
  00039	3b 4d f4	 cmp	 ecx, DWORD PTR tv70[ebp]
  0003c	74 10		 je	 SHORT $LN5@strrchr
  0003e	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00041	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00044	0f be 4d 0c	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00048	3b c1		 cmp	 eax, ecx
  0004a	74 02		 je	 SHORT $LN5@strrchr
  0004c	eb d3		 jmp	 SHORT $LN4@strrchr
$LN5@strrchr:

; 280  : 	if (*str == (char)ch)

  0004e	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00051	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00054	0f be 4d 0c	 movsx	 ecx, BYTE PTR _ch$[ebp]
  00058	3b c1		 cmp	 eax, ecx
  0005a	75 05		 jne	 SHORT $LN6@strrchr

; 281  : 	{
; 282  : 		return( (char *)str );

  0005c	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  0005f	eb 02		 jmp	 SHORT $LN1@strrchr
$LN6@strrchr:

; 283  : 	}
; 284  : 	return(NULL);

  00061	33 c0		 xor	 eax, eax
$LN1@strrchr:

; 285  : }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
_strrchr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\string.c
;	COMDAT _strchr
_TEXT	SEGMENT
tv72 = -32						; size = 4
_longword_ptr$ = -28					; size = 4
_longword$ = -24					; size = 4
_magic_bits$ = -20					; size = 4
_char_ptr$ = -16					; size = 4
_charmask$ = -12					; size = 4
_cp$1 = -8						; size = 4
_c$ = -1						; size = 1
_s$ = 8							; size = 4
_c_in$ = 12						; size = 4
_strchr	PROC						; COMDAT

; 431  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 432  :   const unsigned char *char_ptr;
; 433  :   const unsigned long int *longword_ptr;
; 434  :   unsigned long int longword, magic_bits, charmask;
; 435  :   unsigned char c;
; 436  : 
; 437  :   c = (unsigned char) c_in;

  00006	8a 45 0c	 mov	 al, BYTE PTR _c_in$[ebp]
  00009	88 45 ff	 mov	 BYTE PTR _c$[ebp], al

; 438  : 
; 439  :   /* Handle the first few characters by reading one character at a time.
; 440  :      Do this until CHAR_PTR is aligned on a longword boundary.  */
; 441  :   for (char_ptr = (const unsigned char *) s;

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0000f	89 4d f0	 mov	 DWORD PTR _char_ptr$[ebp], ecx
  00012	eb 09		 jmp	 SHORT $LN4@strchr
$LN2@strchr:

; 443  :        ++char_ptr)

  00014	8b 55 f0	 mov	 edx, DWORD PTR _char_ptr$[ebp]
  00017	83 c2 01	 add	 edx, 1
  0001a	89 55 f0	 mov	 DWORD PTR _char_ptr$[ebp], edx
$LN4@strchr:

; 442  :        ((unsigned long int) char_ptr & (sizeof (longword) - 1)) != 0;

  0001d	8b 45 f0	 mov	 eax, DWORD PTR _char_ptr$[ebp]
  00020	83 e0 03	 and	 eax, 3
  00023	74 2b		 je	 SHORT $LN3@strchr

; 444  :     if (*char_ptr == c)

  00025	8b 4d f0	 mov	 ecx, DWORD PTR _char_ptr$[ebp]
  00028	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR _c$[ebp]
  0002f	3b d0		 cmp	 edx, eax
  00031	75 0a		 jne	 SHORT $LN10@strchr

; 445  :       return (void *) char_ptr;

  00033	8b 45 f0	 mov	 eax, DWORD PTR _char_ptr$[ebp]
  00036	e9 53 02 00 00	 jmp	 $LN1@strchr
  0003b	eb 11		 jmp	 SHORT $LN11@strchr
$LN10@strchr:

; 446  :     else if (*char_ptr == '\0')

  0003d	8b 4d f0	 mov	 ecx, DWORD PTR _char_ptr$[ebp]
  00040	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00043	85 d2		 test	 edx, edx
  00045	75 07		 jne	 SHORT $LN11@strchr

; 447  :       return NULL;

  00047	33 c0		 xor	 eax, eax
  00049	e9 40 02 00 00	 jmp	 $LN1@strchr
$LN11@strchr:
  0004e	eb c4		 jmp	 SHORT $LN2@strchr
$LN3@strchr:

; 448  : 
; 449  :   /* All these elucidatory comments refer to 4-byte longwords,
; 450  :      but the theory applies equally well to 8-byte longwords.  */
; 451  : 
; 452  :   longword_ptr = (unsigned long int *) char_ptr;

  00050	8b 45 f0	 mov	 eax, DWORD PTR _char_ptr$[ebp]
  00053	89 45 e4	 mov	 DWORD PTR _longword_ptr$[ebp], eax

; 453  : 
; 454  :   /* Bits 31, 24, 16, and 8 of this number are zero.  Call these bits
; 455  :      the "holes."  Note that there is a hole just to the left of
; 456  :      each byte, with an extra at the end:
; 457  : 
; 458  :      bits:  01111110 11111110 11111110 11111111
; 459  :      bytes: AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD
; 460  : 
; 461  :      The 1-bits make sure that carries propagate to the next 0-bit.
; 462  :      The 0-bits provide holes for carries to fall into.  */
; 463  :   switch (sizeof (longword))

  00056	c7 45 e0 04 00
	00 00		 mov	 DWORD PTR tv72[ebp], 4
  0005d	83 7d e0 04	 cmp	 DWORD PTR tv72[ebp], 4
  00061	74 08		 je	 SHORT $LN13@strchr
  00063	83 7d e0 08	 cmp	 DWORD PTR tv72[ebp], 8
  00067	74 0b		 je	 SHORT $LN14@strchr
  00069	eb 12		 jmp	 SHORT $LN15@strchr
$LN13@strchr:

; 464  :     {
; 465  :     case 4: magic_bits = 0x7efefeffL; break;

  0006b	c7 45 ec ff fe
	fe 7e		 mov	 DWORD PTR _magic_bits$[ebp], 2130640639 ; 7efefeffH
  00072	eb 0e		 jmp	 SHORT $LN5@strchr
$LN14@strchr:

; 466  :     case 8: magic_bits = ((0x7efefefeL << 16) << 16) | 0xfefefeffL; break;

  00074	c7 45 ec ff fe
	fe fe		 mov	 DWORD PTR _magic_bits$[ebp], -16843009 ; fefefeffH
  0007b	eb 05		 jmp	 SHORT $LN5@strchr
$LN15@strchr:

; 467  :     default:
; 468  :       abort ();

  0007d	e8 00 00 00 00	 call	 _abort
$LN5@strchr:

; 469  :     }
; 470  : 
; 471  :   /* Set up a longword, each of whose bytes is C.  */
; 472  :   charmask = c | (c << 8);

  00082	0f b6 4d ff	 movzx	 ecx, BYTE PTR _c$[ebp]
  00086	0f b6 55 ff	 movzx	 edx, BYTE PTR _c$[ebp]
  0008a	c1 e2 08	 shl	 edx, 8
  0008d	0b ca		 or	 ecx, edx
  0008f	89 4d f4	 mov	 DWORD PTR _charmask$[ebp], ecx

; 473  :   charmask |= charmask << 16;

  00092	8b 45 f4	 mov	 eax, DWORD PTR _charmask$[ebp]
  00095	c1 e0 10	 shl	 eax, 16			; 00000010H
  00098	0b 45 f4	 or	 eax, DWORD PTR _charmask$[ebp]
  0009b	89 45 f4	 mov	 DWORD PTR _charmask$[ebp], eax

; 474  :   if (sizeof (longword) > 4)

  0009e	33 c9		 xor	 ecx, ecx
  000a0	74 0f		 je	 SHORT $LN16@strchr

; 475  :     /* Do the shift in two steps to avoid a warning if long has 32 bits.  */
; 476  :     charmask |= (charmask << 16) << 16;

  000a2	8b 55 f4	 mov	 edx, DWORD PTR _charmask$[ebp]
  000a5	c1 e2 10	 shl	 edx, 16			; 00000010H
  000a8	c1 e2 10	 shl	 edx, 16			; 00000010H
  000ab	0b 55 f4	 or	 edx, DWORD PTR _charmask$[ebp]
  000ae	89 55 f4	 mov	 DWORD PTR _charmask$[ebp], edx
$LN16@strchr:

; 477  :   if (sizeof (longword) > 8)

  000b1	33 c0		 xor	 eax, eax
  000b3	74 05		 je	 SHORT $LN9@strchr

; 478  :     abort ();

  000b5	e8 00 00 00 00	 call	 _abort
$LN9@strchr:

; 479  : 
; 480  :   /* Instead of the traditional loop which tests each character,
; 481  :      we will test a longword at a time.  The tricky part is testing
; 482  :      if *any of the four* bytes in the longword in question are zero.  */
; 483  :   for (;;)
; 484  :     {
; 485  :       /* We tentatively exit the loop if adding MAGIC_BITS to
; 486  : 	 LONGWORD fails to change any of the hole bits of LONGWORD.
; 487  : 
; 488  : 	 1) Is this safe?  Will it catch all the zero bytes?
; 489  : 	 Suppose there is a byte with all zeros.  Any carry bits
; 490  : 	 propagating from its left will fall into the hole at its
; 491  : 	 least significant bit and stop.  Since there will be no
; 492  : 	 carry from its most significant bit, the LSB of the
; 493  : 	 byte to the left will be unchanged, and the zero will be
; 494  : 	 detected.
; 495  : 
; 496  : 	 2) Is this worthwhile?  Will it ignore everything except
; 497  : 	 zero bytes?  Suppose every byte of LONGWORD has a bit set
; 498  : 	 somewhere.  There will be a carry into bit 8.  If bit 8
; 499  : 	 is set, this will carry into bit 16.  If bit 8 is clear,
; 500  : 	 one of bits 9-15 must be set, so there will be a carry
; 501  : 	 into bit 16.  Similarly, there will be a carry into bit
; 502  : 	 24.  If one of bits 24-30 is set, there will be a carry
; 503  : 	 into bit 31, so all of the hole bits will be changed.
; 504  : 
; 505  : 	 The one misfire occurs when bits 24-30 are clear and bit
; 506  : 	 31 is set; in this case, the hole at bit 31 is not
; 507  : 	 changed.  If we had access to the processor carry flag,
; 508  : 	 we could close this loophole by putting the fourth hole
; 509  : 	 at bit 32!
; 510  : 
; 511  : 	 So it ignores everything except 128's, when they're aligned
; 512  : 	 properly.
; 513  : 
; 514  : 	 3) But wait!  Aren't we looking for C as well as zero?
; 515  : 	 Good point.  So what we do is XOR LONGWORD with a longword,
; 516  : 	 each of whose bytes is C.  This turns each byte that is C
; 517  : 	 into a zero.  */
; 518  : 
; 519  :       longword = *longword_ptr++;

  000ba	8b 4d e4	 mov	 ecx, DWORD PTR _longword_ptr$[ebp]
  000bd	8b 11		 mov	 edx, DWORD PTR [ecx]
  000bf	89 55 e8	 mov	 DWORD PTR _longword$[ebp], edx
  000c2	8b 45 e4	 mov	 eax, DWORD PTR _longword_ptr$[ebp]
  000c5	83 c0 04	 add	 eax, 4
  000c8	89 45 e4	 mov	 DWORD PTR _longword_ptr$[ebp], eax

; 520  : 
; 521  :       /* Add MAGIC_BITS to LONGWORD.  */
; 522  :       if ((((longword + magic_bits)
; 523  : 
; 524  : 	    /* Set those bits that were unchanged by the addition.  */
; 525  : 	    ^ ~longword)
; 526  : 
; 527  : 	   /* Look at only the hole bits.  If any of the hole bits
; 528  : 	      are unchanged, most likely one of the bytes was a
; 529  : 	      zero.  */
; 530  : 	   & ~magic_bits) != 0 ||

  000cb	8b 4d e8	 mov	 ecx, DWORD PTR _longword$[ebp]
  000ce	03 4d ec	 add	 ecx, DWORD PTR _magic_bits$[ebp]
  000d1	8b 55 e8	 mov	 edx, DWORD PTR _longword$[ebp]
  000d4	f7 d2		 not	 edx
  000d6	33 ca		 xor	 ecx, edx
  000d8	8b 45 ec	 mov	 eax, DWORD PTR _magic_bits$[ebp]
  000db	f7 d0		 not	 eax
  000dd	23 c8		 and	 ecx, eax
  000df	75 20		 jne	 SHORT $LN19@strchr
  000e1	8b 4d e8	 mov	 ecx, DWORD PTR _longword$[ebp]
  000e4	33 4d f4	 xor	 ecx, DWORD PTR _charmask$[ebp]
  000e7	03 4d ec	 add	 ecx, DWORD PTR _magic_bits$[ebp]
  000ea	8b 55 e8	 mov	 edx, DWORD PTR _longword$[ebp]
  000ed	33 55 f4	 xor	 edx, DWORD PTR _charmask$[ebp]
  000f0	f7 d2		 not	 edx
  000f2	33 ca		 xor	 ecx, edx
  000f4	8b 45 ec	 mov	 eax, DWORD PTR _magic_bits$[ebp]
  000f7	f7 d0		 not	 eax
  000f9	23 c8		 and	 ecx, eax
  000fb	0f 84 86 01 00
	00		 je	 $LN18@strchr
$LN19@strchr:

; 531  : 
; 532  : 	  /* That caught zeroes.  Now test for C.  */
; 533  : 	  ((((longword ^ charmask) + magic_bits) ^ ~(longword ^ charmask))
; 534  : 	   & ~magic_bits) != 0)
; 535  : 	{
; 536  : 	  /* Which of the bytes was C or zero?
; 537  : 	     If none of them were, it was a misfire; continue the search.  */
; 538  : 
; 539  : 	  const unsigned char *cp = (const unsigned char *) (longword_ptr - 1);

  00101	8b 4d e4	 mov	 ecx, DWORD PTR _longword_ptr$[ebp]
  00104	83 e9 04	 sub	 ecx, 4
  00107	89 4d f8	 mov	 DWORD PTR _cp$1[ebp], ecx

; 540  : 
; 541  : 	  if (*cp == c)

  0010a	8b 55 f8	 mov	 edx, DWORD PTR _cp$1[ebp]
  0010d	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00110	0f b6 4d ff	 movzx	 ecx, BYTE PTR _c$[ebp]
  00114	3b c1		 cmp	 eax, ecx
  00116	75 0a		 jne	 SHORT $LN20@strchr

; 542  : 	    return (char *) cp;

  00118	8b 45 f8	 mov	 eax, DWORD PTR _cp$1[ebp]
  0011b	e9 6e 01 00 00	 jmp	 $LN1@strchr
  00120	eb 11		 jmp	 SHORT $LN21@strchr
$LN20@strchr:

; 543  : 	  else if (*cp == '\0')

  00122	8b 55 f8	 mov	 edx, DWORD PTR _cp$1[ebp]
  00125	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00128	85 c0		 test	 eax, eax
  0012a	75 07		 jne	 SHORT $LN21@strchr

; 544  : 	    return NULL;

  0012c	33 c0		 xor	 eax, eax
  0012e	e9 5b 01 00 00	 jmp	 $LN1@strchr
$LN21@strchr:

; 545  : 	  if (*++cp == c)

  00133	8b 4d f8	 mov	 ecx, DWORD PTR _cp$1[ebp]
  00136	83 c1 01	 add	 ecx, 1
  00139	89 4d f8	 mov	 DWORD PTR _cp$1[ebp], ecx
  0013c	8b 55 f8	 mov	 edx, DWORD PTR _cp$1[ebp]
  0013f	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00142	0f b6 4d ff	 movzx	 ecx, BYTE PTR _c$[ebp]
  00146	3b c1		 cmp	 eax, ecx
  00148	75 0a		 jne	 SHORT $LN23@strchr

; 546  : 	    return (char *) cp;

  0014a	8b 45 f8	 mov	 eax, DWORD PTR _cp$1[ebp]
  0014d	e9 3c 01 00 00	 jmp	 $LN1@strchr
  00152	eb 11		 jmp	 SHORT $LN24@strchr
$LN23@strchr:

; 547  : 	  else if (*cp == '\0')

  00154	8b 55 f8	 mov	 edx, DWORD PTR _cp$1[ebp]
  00157	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0015a	85 c0		 test	 eax, eax
  0015c	75 07		 jne	 SHORT $LN24@strchr

; 548  : 	    return NULL;

  0015e	33 c0		 xor	 eax, eax
  00160	e9 29 01 00 00	 jmp	 $LN1@strchr
$LN24@strchr:

; 549  : 	  if (*++cp == c)

  00165	8b 4d f8	 mov	 ecx, DWORD PTR _cp$1[ebp]
  00168	83 c1 01	 add	 ecx, 1
  0016b	89 4d f8	 mov	 DWORD PTR _cp$1[ebp], ecx
  0016e	8b 55 f8	 mov	 edx, DWORD PTR _cp$1[ebp]
  00171	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00174	0f b6 4d ff	 movzx	 ecx, BYTE PTR _c$[ebp]
  00178	3b c1		 cmp	 eax, ecx
  0017a	75 0a		 jne	 SHORT $LN26@strchr

; 550  : 	    return (char *) cp;

  0017c	8b 45 f8	 mov	 eax, DWORD PTR _cp$1[ebp]
  0017f	e9 0a 01 00 00	 jmp	 $LN1@strchr
  00184	eb 11		 jmp	 SHORT $LN27@strchr
$LN26@strchr:

; 551  : 	  else if (*cp == '\0')

  00186	8b 55 f8	 mov	 edx, DWORD PTR _cp$1[ebp]
  00189	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0018c	85 c0		 test	 eax, eax
  0018e	75 07		 jne	 SHORT $LN27@strchr

; 552  : 	    return NULL;

  00190	33 c0		 xor	 eax, eax
  00192	e9 f7 00 00 00	 jmp	 $LN1@strchr
$LN27@strchr:

; 553  : 	  if (*++cp == c)

  00197	8b 4d f8	 mov	 ecx, DWORD PTR _cp$1[ebp]
  0019a	83 c1 01	 add	 ecx, 1
  0019d	89 4d f8	 mov	 DWORD PTR _cp$1[ebp], ecx
  001a0	8b 55 f8	 mov	 edx, DWORD PTR _cp$1[ebp]
  001a3	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  001a6	0f b6 4d ff	 movzx	 ecx, BYTE PTR _c$[ebp]
  001aa	3b c1		 cmp	 eax, ecx
  001ac	75 0a		 jne	 SHORT $LN29@strchr

; 554  : 	    return (char *) cp;

  001ae	8b 45 f8	 mov	 eax, DWORD PTR _cp$1[ebp]
  001b1	e9 d8 00 00 00	 jmp	 $LN1@strchr
  001b6	eb 11		 jmp	 SHORT $LN30@strchr
$LN29@strchr:

; 555  : 	  else if (*cp == '\0')

  001b8	8b 55 f8	 mov	 edx, DWORD PTR _cp$1[ebp]
  001bb	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  001be	85 c0		 test	 eax, eax
  001c0	75 07		 jne	 SHORT $LN30@strchr

; 556  : 	    return NULL;

  001c2	33 c0		 xor	 eax, eax
  001c4	e9 c5 00 00 00	 jmp	 $LN1@strchr
$LN30@strchr:

; 557  : 	  if (sizeof (longword) > 4)

  001c9	33 c9		 xor	 ecx, ecx
  001cb	0f 84 b6 00 00
	00		 je	 $LN18@strchr

; 558  : 	    {
; 559  : 	      if (*++cp == c)

  001d1	8b 55 f8	 mov	 edx, DWORD PTR _cp$1[ebp]
  001d4	83 c2 01	 add	 edx, 1
  001d7	89 55 f8	 mov	 DWORD PTR _cp$1[ebp], edx
  001da	8b 45 f8	 mov	 eax, DWORD PTR _cp$1[ebp]
  001dd	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001e0	0f b6 55 ff	 movzx	 edx, BYTE PTR _c$[ebp]
  001e4	3b ca		 cmp	 ecx, edx
  001e6	75 0a		 jne	 SHORT $LN33@strchr

; 560  : 		return (char *) cp;

  001e8	8b 45 f8	 mov	 eax, DWORD PTR _cp$1[ebp]
  001eb	e9 9e 00 00 00	 jmp	 $LN1@strchr
  001f0	eb 11		 jmp	 SHORT $LN34@strchr
$LN33@strchr:

; 561  : 	      else if (*cp == '\0')

  001f2	8b 45 f8	 mov	 eax, DWORD PTR _cp$1[ebp]
  001f5	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  001f8	85 c9		 test	 ecx, ecx
  001fa	75 07		 jne	 SHORT $LN34@strchr

; 562  : 		return NULL;

  001fc	33 c0		 xor	 eax, eax
  001fe	e9 8b 00 00 00	 jmp	 $LN1@strchr
$LN34@strchr:

; 563  : 	      if (*++cp == c)

  00203	8b 55 f8	 mov	 edx, DWORD PTR _cp$1[ebp]
  00206	83 c2 01	 add	 edx, 1
  00209	89 55 f8	 mov	 DWORD PTR _cp$1[ebp], edx
  0020c	8b 45 f8	 mov	 eax, DWORD PTR _cp$1[ebp]
  0020f	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00212	0f b6 55 ff	 movzx	 edx, BYTE PTR _c$[ebp]
  00216	3b ca		 cmp	 ecx, edx
  00218	75 07		 jne	 SHORT $LN36@strchr

; 564  : 		return (char *) cp;

  0021a	8b 45 f8	 mov	 eax, DWORD PTR _cp$1[ebp]
  0021d	eb 6f		 jmp	 SHORT $LN1@strchr
  0021f	eb 0e		 jmp	 SHORT $LN37@strchr
$LN36@strchr:

; 565  : 	      else if (*cp == '\0')

  00221	8b 45 f8	 mov	 eax, DWORD PTR _cp$1[ebp]
  00224	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00227	85 c9		 test	 ecx, ecx
  00229	75 04		 jne	 SHORT $LN37@strchr

; 566  : 		return NULL;

  0022b	33 c0		 xor	 eax, eax
  0022d	eb 5f		 jmp	 SHORT $LN1@strchr
$LN37@strchr:

; 567  : 	      if (*++cp == c)

  0022f	8b 55 f8	 mov	 edx, DWORD PTR _cp$1[ebp]
  00232	83 c2 01	 add	 edx, 1
  00235	89 55 f8	 mov	 DWORD PTR _cp$1[ebp], edx
  00238	8b 45 f8	 mov	 eax, DWORD PTR _cp$1[ebp]
  0023b	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0023e	0f b6 55 ff	 movzx	 edx, BYTE PTR _c$[ebp]
  00242	3b ca		 cmp	 ecx, edx
  00244	75 07		 jne	 SHORT $LN39@strchr

; 568  : 		return (char *) cp;

  00246	8b 45 f8	 mov	 eax, DWORD PTR _cp$1[ebp]
  00249	eb 43		 jmp	 SHORT $LN1@strchr
  0024b	eb 0e		 jmp	 SHORT $LN40@strchr
$LN39@strchr:

; 569  : 	      else if (*cp == '\0')

  0024d	8b 45 f8	 mov	 eax, DWORD PTR _cp$1[ebp]
  00250	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00253	85 c9		 test	 ecx, ecx
  00255	75 04		 jne	 SHORT $LN40@strchr

; 570  : 		return NULL;

  00257	33 c0		 xor	 eax, eax
  00259	eb 33		 jmp	 SHORT $LN1@strchr
$LN40@strchr:

; 571  : 	      if (*++cp == c)

  0025b	8b 55 f8	 mov	 edx, DWORD PTR _cp$1[ebp]
  0025e	83 c2 01	 add	 edx, 1
  00261	89 55 f8	 mov	 DWORD PTR _cp$1[ebp], edx
  00264	8b 45 f8	 mov	 eax, DWORD PTR _cp$1[ebp]
  00267	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0026a	0f b6 55 ff	 movzx	 edx, BYTE PTR _c$[ebp]
  0026e	3b ca		 cmp	 ecx, edx
  00270	75 07		 jne	 SHORT $LN42@strchr

; 572  : 		return (char *) cp;

  00272	8b 45 f8	 mov	 eax, DWORD PTR _cp$1[ebp]
  00275	eb 17		 jmp	 SHORT $LN1@strchr
  00277	eb 0e		 jmp	 SHORT $LN18@strchr
$LN42@strchr:

; 573  : 	      else if (*cp == '\0')

  00279	8b 45 f8	 mov	 eax, DWORD PTR _cp$1[ebp]
  0027c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0027f	85 c9		 test	 ecx, ecx
  00281	75 04		 jne	 SHORT $LN18@strchr

; 574  : 		return NULL;

  00283	33 c0		 xor	 eax, eax
  00285	eb 07		 jmp	 SHORT $LN1@strchr
$LN18@strchr:

; 575  : 	    }
; 576  : 	}
; 577  :     }

  00287	e9 2e fe ff ff	 jmp	 $LN9@strchr

; 578  : 
; 579  :   return NULL;

  0028c	33 c0		 xor	 eax, eax
$LN1@strchr:

; 580  : }

  0028e	8b e5		 mov	 esp, ebp
  00290	5d		 pop	 ebp
  00291	c3		 ret	 0
_strchr	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\string.c
;	COMDAT _strcpy
_TEXT	SEGMENT
tv68 = -8						; size = 4
_cp$ = -4						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_strcpy	PROC						; COMDAT

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 48   :     char * cp = dst;

  00006	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _cp$[ebp], eax
$LN2@strcpy:

; 49   :     while( *cp++ = *src++ )

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _cp$[ebp]
  0000f	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00012	8a 02		 mov	 al, BYTE PTR [edx]
  00014	88 01		 mov	 BYTE PTR [ecx], al
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _cp$[ebp]
  00019	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0001c	89 55 f8	 mov	 DWORD PTR tv68[ebp], edx
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _cp$[ebp]
  00022	83 c0 01	 add	 eax, 1
  00025	89 45 fc	 mov	 DWORD PTR _cp$[ebp], eax
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  0002b	83 c1 01	 add	 ecx, 1
  0002e	89 4d 0c	 mov	 DWORD PTR _src$[ebp], ecx
  00031	83 7d f8 00	 cmp	 DWORD PTR tv68[ebp], 0
  00035	74 02		 je	 SHORT $LN3@strcpy

; 50   :             ;               /* Copy src over dst */

  00037	eb d3		 jmp	 SHORT $LN2@strcpy
$LN3@strcpy:

; 51   :     return( dst );

  00039	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]

; 52   : }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
_strcpy	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\string.c
;	COMDAT _strcat
_TEXT	SEGMENT
tv71 = -8						; size = 4
_cp$ = -4						; size = 4
_dst$ = 8						; size = 4
_src$ = 12						; size = 4
_strcat	PROC						; COMDAT

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 59   :         char * cp = dst;

  00006	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _cp$[ebp], eax
$LN2@strcat:

; 60   :  
; 61   :         while( *cp )

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _cp$[ebp]
  0000f	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00012	85 d2		 test	 edx, edx
  00014	74 0b		 je	 SHORT $LN4@strcat

; 62   :                 cp++;                   /* find end of dst */

  00016	8b 45 fc	 mov	 eax, DWORD PTR _cp$[ebp]
  00019	83 c0 01	 add	 eax, 1
  0001c	89 45 fc	 mov	 DWORD PTR _cp$[ebp], eax
  0001f	eb eb		 jmp	 SHORT $LN2@strcat
$LN4@strcat:

; 63   :  
; 64   :         while( *cp++ = *src++ ) ;       /* Copy src to end of dst */

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _cp$[ebp]
  00024	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
  00027	8a 02		 mov	 al, BYTE PTR [edx]
  00029	88 01		 mov	 BYTE PTR [ecx], al
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _cp$[ebp]
  0002e	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00031	89 55 f8	 mov	 DWORD PTR tv71[ebp], edx
  00034	8b 45 fc	 mov	 eax, DWORD PTR _cp$[ebp]
  00037	83 c0 01	 add	 eax, 1
  0003a	89 45 fc	 mov	 DWORD PTR _cp$[ebp], eax
  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00040	83 c1 01	 add	 ecx, 1
  00043	89 4d 0c	 mov	 DWORD PTR _src$[ebp], ecx
  00046	83 7d f8 00	 cmp	 DWORD PTR tv71[ebp], 0
  0004a	74 02		 je	 SHORT $LN5@strcat
  0004c	eb d3		 jmp	 SHORT $LN4@strcat
$LN5@strcat:

; 65   :  
; 66   :         return( dst );                  /* return dst */

  0004e	8b 45 08	 mov	 eax, DWORD PTR _dst$[ebp]

; 67   :  
; 68   : }

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
_strcat	ENDP
_TEXT	ENDS
END
