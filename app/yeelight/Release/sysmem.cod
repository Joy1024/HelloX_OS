; Listing generated by Microsoft (R) Optimizing Compiler Version 19.13.26128.0 

	TITLE	C:\HelloX\personal\HelloX_OS\app\yeelight\hxlib\sysmem.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG4769	DB	'c:\hellox\personal\hellox_os\app\yeelight\hxlib\sysmem.c'
	DB	00H
	ORG $+3
$SG4831	DB	'c:\hellox\personal\hellox_os\app\yeelight\hxlib\sysmem.c'
	DB	00H
	ORG $+3
$SG4833	DB	'c:\hellox\personal\hellox_os\app\yeelight\hxlib\sysmem.c'
	DB	00H
_DATA	ENDS
PUBLIC	__hx_malloc
PUBLIC	__hx_free
PUBLIC	__hx_calloc
PUBLIC	__hx_alloca
PUBLIC	_mmap
PUBLIC	_munmap
PUBLIC	__hx_aligned_malloc
EXTRN	_KMemAlloc:PROC
EXTRN	_KMemFree:PROC
EXTRN	___BUG:PROC
EXTRN	_memset:PROC
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\sysmem.c
;	COMDAT __hx_aligned_free
_TEXT	SEGMENT
_mem_ptr$ = -4						; size = 4
_block_ptr$ = 8						; size = 4
__hx_aligned_free PROC					; COMDAT

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 128  : 	unsigned long* mem_ptr = block_ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR _block_ptr$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _mem_ptr$[ebp], eax

; 129  : 	if (NULL == mem_ptr)

  0000a	83 7d fc 00	 cmp	 DWORD PTR _mem_ptr$[ebp], 0
  0000e	75 02		 jne	 SHORT $LN2@hx_aligned

; 130  : 	{
; 131  : 		return;

  00010	eb 60		 jmp	 SHORT $LN1@hx_aligned
$LN2@hx_aligned:

; 132  : 	}
; 133  : 	//Validate the memory block's type.
; 134  : 	if (mem_ptr[-1] != MEMORY_BLOCK_TYPE_ALIGNED)

  00012	b9 04 00 00 00	 mov	 ecx, 4
  00017	6b d1 ff	 imul	 edx, ecx, -1
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _mem_ptr$[ebp]
  0001d	83 3c 10 08	 cmp	 DWORD PTR [eax+edx], 8
  00021	74 12		 je	 SHORT $LN3@hx_aligned

; 135  : 	{
; 136  : 		BUG();

  00023	68 88 00 00 00	 push	 136			; 00000088H
  00028	68 00 00 00 00	 push	 OFFSET $SG4831
  0002d	e8 00 00 00 00	 call	 ___BUG
  00032	83 c4 08	 add	 esp, 8
$LN3@hx_aligned:

; 137  : 	}
; 138  : 	//Validate the memory block's signature.
; 139  : 	if (mem_ptr[-3] != KERNEL_OBJECT_SIGNATURE)

  00035	b9 04 00 00 00	 mov	 ecx, 4
  0003a	6b d1 fd	 imul	 edx, ecx, -3
  0003d	8b 45 fc	 mov	 eax, DWORD PTR _mem_ptr$[ebp]
  00040	81 3c 10 aa 55
	55 aa		 cmp	 DWORD PTR [eax+edx], -1437248086 ; aa5555aaH
  00047	74 12		 je	 SHORT $LN4@hx_aligned

; 140  : 	{
; 141  : 		BUG();

  00049	68 8d 00 00 00	 push	 141			; 0000008dH
  0004e	68 00 00 00 00	 push	 OFFSET $SG4833
  00053	e8 00 00 00 00	 call	 ___BUG
  00058	83 c4 08	 add	 esp, 8
$LN4@hx_aligned:

; 142  : 	}
; 143  : 	//Release the corresponding normal memory block.
; 144  : 	_hx_free((LPVOID)mem_ptr[-2]);

  0005b	b9 04 00 00 00	 mov	 ecx, 4
  00060	6b d1 fe	 imul	 edx, ecx, -2
  00063	8b 45 fc	 mov	 eax, DWORD PTR _mem_ptr$[ebp]
  00066	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 __hx_free
  0006f	83 c4 04	 add	 esp, 4
$LN1@hx_aligned:

; 145  : }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
__hx_aligned_free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\sysmem.c
;	COMDAT __hx_aligned_malloc
_TEXT	SEGMENT
_alloc_size$ = -12					; size = 4
_mem_ptr$ = -8						; size = 4
_block_ptr$ = -4					; size = 4
_size$ = 8						; size = 4
_align$ = 12						; size = 4
__hx_aligned_malloc PROC				; COMDAT

; 107  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 108  : 	void* mem_ptr = NULL;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _mem_ptr$[ebp], 0

; 109  : 	unsigned char* block_ptr = NULL;

  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _block_ptr$[ebp], 0

; 110  : 	unsigned long alloc_size = size + align + 2 * sizeof(unsigned long) + sizeof(void*);

  00014	8b 45 0c	 mov	 eax, DWORD PTR _align$[ebp]
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  0001a	8d 54 01 0c	 lea	 edx, DWORD PTR [ecx+eax+12]
  0001e	89 55 f4	 mov	 DWORD PTR _alloc_size$[ebp], edx

; 111  : 	//Allocate memory from kernel pool.
; 112  : 	mem_ptr = _hx_malloc(alloc_size);

  00021	8b 45 f4	 mov	 eax, DWORD PTR _alloc_size$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 __hx_malloc
  0002a	83 c4 04	 add	 esp, 4
  0002d	89 45 f8	 mov	 DWORD PTR _mem_ptr$[ebp], eax

; 113  : 	if (NULL == mem_ptr)

  00030	83 7d f8 00	 cmp	 DWORD PTR _mem_ptr$[ebp], 0
  00034	75 04		 jne	 SHORT $LN2@hx_aligned

; 114  : 	{
; 115  : 		return NULL;

  00036	33 c0		 xor	 eax, eax
  00038	eb 59		 jmp	 SHORT $LN1@hx_aligned
$LN2@hx_aligned:

; 116  : 	}
; 117  : 	block_ptr = mem_ptr;

  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _mem_ptr$[ebp]
  0003d	89 4d fc	 mov	 DWORD PTR _block_ptr$[ebp], ecx

; 118  : 	block_ptr += (sizeof(void*) + 2 * sizeof(unsigned long) + align);

  00040	8b 55 0c	 mov	 edx, DWORD PTR _align$[ebp]
  00043	8b 45 fc	 mov	 eax, DWORD PTR _block_ptr$[ebp]
  00046	8d 4c 10 0c	 lea	 ecx, DWORD PTR [eax+edx+12]
  0004a	89 4d fc	 mov	 DWORD PTR _block_ptr$[ebp], ecx

; 119  : 	block_ptr = (unsigned char*)(((long)block_ptr) & (~(align - 1)));

  0004d	8b 55 0c	 mov	 edx, DWORD PTR _align$[ebp]
  00050	83 ea 01	 sub	 edx, 1
  00053	f7 d2		 not	 edx
  00055	23 55 fc	 and	 edx, DWORD PTR _block_ptr$[ebp]
  00058	89 55 fc	 mov	 DWORD PTR _block_ptr$[ebp], edx

; 120  : 	((unsigned long*)block_ptr)[-1] = MEMORY_BLOCK_TYPE_ALIGNED;

  0005b	b8 04 00 00 00	 mov	 eax, 4
  00060	6b c8 ff	 imul	 ecx, eax, -1
  00063	8b 55 fc	 mov	 edx, DWORD PTR _block_ptr$[ebp]
  00066	c7 04 0a 08 00
	00 00		 mov	 DWORD PTR [edx+ecx], 8

; 121  : 	((unsigned long*)block_ptr)[-2] = (unsigned long)mem_ptr;

  0006d	b8 04 00 00 00	 mov	 eax, 4
  00072	6b c8 fe	 imul	 ecx, eax, -2
  00075	8b 55 fc	 mov	 edx, DWORD PTR _block_ptr$[ebp]
  00078	8b 45 f8	 mov	 eax, DWORD PTR _mem_ptr$[ebp]
  0007b	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 122  : 	((unsigned long*)block_ptr)[-3] = KERNEL_OBJECT_SIGNATURE;

  0007e	b9 04 00 00 00	 mov	 ecx, 4
  00083	6b d1 fd	 imul	 edx, ecx, -3
  00086	8b 45 fc	 mov	 eax, DWORD PTR _block_ptr$[ebp]
  00089	c7 04 10 aa 55
	55 aa		 mov	 DWORD PTR [eax+edx], -1437248086 ; aa5555aaH

; 123  : 	return block_ptr;

  00090	8b 45 fc	 mov	 eax, DWORD PTR _block_ptr$[ebp]
$LN1@hx_aligned:

; 124  : }

  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
__hx_aligned_malloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\sysmem.c
;	COMDAT _munmap
_TEXT	SEGMENT
_start$ = 8						; size = 4
_length$ = 12						; size = 4
_munmap	PROC						; COMDAT

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 95   : 	KMemFree(start,KMEM_SIZE_TYPE_ANY,0);

  00003	6a 00		 push	 0
  00005	6a 01		 push	 1
  00007	8b 45 08	 mov	 eax, DWORD PTR _start$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _KMemFree
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH

; 96   : 	return 0;

  00013	33 c0		 xor	 eax, eax

; 97   : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
_munmap	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\sysmem.c
;	COMDAT _mmap
_TEXT	SEGMENT
_start$ = 8						; size = 4
_length$ = 12						; size = 4
_prot$ = 16						; size = 4
_flags$ = 20						; size = 4
_fd$ = 24						; size = 4
_offset$ = 28						; size = 4
_mmap	PROC						; COMDAT

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   : 	return KMemAlloc(length,KMEM_SIZE_TYPE_ANY);

  00003	6a 01		 push	 1
  00005	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 _KMemAlloc
  0000e	83 c4 08	 add	 esp, 8

; 90   : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_mmap	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\sysmem.c
;	COMDAT __hx_alloca
_TEXT	SEGMENT
_size$ = 8						; size = 4
__hx_alloca PROC					; COMDAT

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 102  : 	return NULL;

  00003	33 c0		 xor	 eax, eax

; 103  : }

  00005	5d		 pop	 ebp
  00006	c3		 ret	 0
__hx_alloca ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\sysmem.c
;	COMDAT __hx_calloc
_TEXT	SEGMENT
_p$ = -4						; size = 4
_n$ = 8							; size = 4
_s$ = 12						; size = 4
__hx_calloc PROC					; COMDAT

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 77   : 	void*    p = _hx_malloc(n * s);

  00004	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00007	0f af 45 0c	 imul	 eax, DWORD PTR _s$[ebp]
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 __hx_malloc
  00011	83 c4 04	 add	 esp, 4
  00014	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 78   : 	if(NULL == p)

  00017	83 7d fc 00	 cmp	 DWORD PTR _p$[ebp], 0
  0001b	75 05		 jne	 SHORT $LN2@hx_calloc

; 79   : 	{
; 80   : 		return p;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00020	eb 19		 jmp	 SHORT $LN1@hx_calloc
$LN2@hx_calloc:

; 81   : 	}
; 82   : 	memset(p,0,n * s);

  00022	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  00025	0f af 4d 0c	 imul	 ecx, DWORD PTR _s$[ebp]
  00029	51		 push	 ecx
  0002a	6a 00		 push	 0
  0002c	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 _memset
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 83   : 	return p;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
$LN1@hx_calloc:

; 84   : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
__hx_calloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\sysmem.c
;	COMDAT __hx_free
_TEXT	SEGMENT
_mem_ptr$ = -4						; size = 4
_p$ = 8							; size = 4
__hx_free PROC						; COMDAT

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 52   : 	unsigned long* mem_ptr = (unsigned long*)p;

  00004	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _mem_ptr$[ebp], eax

; 53   : 	if (NULL == mem_ptr)

  0000a	83 7d fc 00	 cmp	 DWORD PTR _mem_ptr$[ebp], 0
  0000e	75 02		 jne	 SHORT $LN2@hx_free

; 54   : 	{
; 55   : 		return;

  00010	eb 5a		 jmp	 SHORT $LN1@hx_free
$LN2@hx_free:

; 56   : 	}
; 57   : 	//Check the memory block types.
; 58   : 	mem_ptr -= 1;

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _mem_ptr$[ebp]
  00015	83 e9 04	 sub	 ecx, 4
  00018	89 4d fc	 mov	 DWORD PTR _mem_ptr$[ebp], ecx

; 59   : 	if (MEMORY_BLOCK_TYPE_NORMAL == mem_ptr[0])

  0001b	ba 04 00 00 00	 mov	 edx, 4
  00020	6b c2 00	 imul	 eax, edx, 0
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _mem_ptr$[ebp]
  00026	83 3c 01 00	 cmp	 DWORD PTR [ecx+eax], 0
  0002a	75 12		 jne	 SHORT $LN3@hx_free

; 60   : 	{
; 61   : 		KMemFree(mem_ptr, KMEM_SIZE_TYPE_ANY, 0);

  0002c	6a 00		 push	 0
  0002e	6a 01		 push	 1
  00030	8b 55 fc	 mov	 edx, DWORD PTR _mem_ptr$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 _KMemFree
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 62   : 		return;

  0003c	eb 2e		 jmp	 SHORT $LN1@hx_free
$LN3@hx_free:

; 63   : 	}
; 64   : 	if (MEMORY_BLOCK_TYPE_ALIGNED == mem_ptr[0])  //Aligned block.

  0003e	b8 04 00 00 00	 mov	 eax, 4
  00043	6b c8 00	 imul	 ecx, eax, 0
  00046	8b 55 fc	 mov	 edx, DWORD PTR _mem_ptr$[ebp]
  00049	83 3c 0a 08	 cmp	 DWORD PTR [edx+ecx], 8
  0004d	75 0e		 jne	 SHORT $LN4@hx_free

; 65   : 	{
; 66   : 		_hx_aligned_free(p);

  0004f	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 __hx_aligned_free
  00058	83 c4 04	 add	 esp, 4

; 67   : 		return;

  0005b	eb 0f		 jmp	 SHORT $LN1@hx_free
$LN4@hx_free:

; 68   : 	}
; 69   : 	//Other value of memory type is invalid.
; 70   : 	BUG();

  0005d	6a 46		 push	 70			; 00000046H
  0005f	68 00 00 00 00	 push	 OFFSET $SG4769
  00064	e8 00 00 00 00	 call	 ___BUG
  00069	83 c4 08	 add	 esp, 8
$LN1@hx_free:

; 71   : 	return;
; 72   : }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
__hx_free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\hxlib\sysmem.c
;	COMDAT __hx_malloc
_TEXT	SEGMENT
_mem_ptr$ = -4						; size = 4
_size$ = 8						; size = 4
__hx_malloc PROC					; COMDAT

; 32   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 33   : 	unsigned long* mem_ptr = NULL;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _mem_ptr$[ebp], 0

; 34   : 
; 35   : 	//Allocate one long space to store the memory block type value.
; 36   : 	mem_ptr = (unsigned long*)KMemAlloc((size + sizeof(unsigned long)), KMEM_SIZE_TYPE_ANY);

  0000b	6a 01		 push	 1
  0000d	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00010	83 c0 04	 add	 eax, 4
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _KMemAlloc
  00019	83 c4 08	 add	 esp, 8
  0001c	89 45 fc	 mov	 DWORD PTR _mem_ptr$[ebp], eax

; 37   : 	if (NULL == mem_ptr)

  0001f	83 7d fc 00	 cmp	 DWORD PTR _mem_ptr$[ebp], 0
  00023	75 04		 jne	 SHORT $LN2@hx_malloc

; 38   : 	{
; 39   : 		return NULL;

  00025	33 c0		 xor	 eax, eax
  00027	eb 18		 jmp	 SHORT $LN1@hx_malloc
$LN2@hx_malloc:

; 40   : 	}
; 41   : 	//Set the memory block type value.
; 42   : 	mem_ptr[0] = MEMORY_BLOCK_TYPE_NORMAL;

  00029	b9 04 00 00 00	 mov	 ecx, 4
  0002e	6b d1 00	 imul	 edx, ecx, 0
  00031	8b 45 fc	 mov	 eax, DWORD PTR _mem_ptr$[ebp]
  00034	c7 04 10 00 00
	00 00		 mov	 DWORD PTR [eax+edx], 0

; 43   : 
; 44   : 	//Return the memory pointer can be used by caller,it skips the long of original block.
; 45   : 	return (void*)(mem_ptr + 1);

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _mem_ptr$[ebp]
  0003e	83 c0 04	 add	 eax, 4
$LN1@hx_malloc:

; 46   : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
__hx_malloc ENDP
_TEXT	ENDS
END
