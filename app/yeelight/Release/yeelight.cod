; Listing generated by Microsoft (R) Optimizing Compiler Version 19.13.26128.0 

	TITLE	C:\HelloX\personal\HelloX_OS\app\yeelight\src\yeelight.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_okmsg
PUBLIC	??_C@_0BA@DNNGICBF@HTTP?11?41?5200?5OK?$AA@	; `string'
_BSS	SEGMENT
_pLightObject DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BA@DNNGICBF@HTTP?11?41?5200?5OK?$AA@
CONST	SEGMENT
??_C@_0BA@DNNGICBF@HTTP?11?41?5200?5OK?$AA@ DB 'HTTP/1.1 200 OK', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
_okmsg	DD	FLAT:??_C@_0BA@DNNGICBF@HTTP?11?41?5200?5OK?$AA@
_DATA	ENDS
PUBLIC	__hx_main
PUBLIC	??_C@_0DJ@DLILGIOL@c?3?2hellox?2personal?2hellox_os?2app@ ; `string'
PUBLIC	??_C@_08EEABGAIP@yeelight?$AA@			; `string'
PUBLIC	??_C@_0BH@HGHOBMCE@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_08DELEFJBK@id?3?5?$CFs?$AN?6?$AA@		; `string'
PUBLIC	??_C@_08MMEFGGML@ip?3?5?$CFs?$AN?6?$AA@		; `string'
PUBLIC	??_C@_0L@PIBEHDPH@port?3?5?$CFd?$AN?6?$AA@	; `string'
PUBLIC	??_C@_0CM@NIFJBDJE@?$HL?$CCid?$CC?3?$CC?$CFs?$CC?0?$CCmethod?$CC?3?$CCtoggle?$CC?0?$CCpa@ ; `string'
PUBLIC	??_C@_0CA@KLBIHOJL@Can?5not?5create?5socket?5object?4?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@OAKNKFDD@Can?5not?5connect?5to?5light?5object?$FL@ ; `string'
PUBLIC	??_C@_0BO@NPJCALFH@Connect?5to?5light?5object?5OK?4?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@DDIPKHPP@Failed?5to?5send?5toggle?5command?4?$AN?6@ ; `string'
PUBLIC	??_C@_0CB@MBPHKCID@Failed?5to?5recv?5resp?$FLret?5?$DN?5?$CFd?$FN?4?$AN?6@ ; `string'
PUBLIC	??_C@_0CN@PHCHOKIN@Received?5status?5update?5message?$FLs@ ; `string'
PUBLIC	??_C@_0BD@PCKCGHAM@Status?5update?3?$CFs?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_02PCIJFNDE@?$AN?6?$AA@			; `string'
PUBLIC	??_C@_08KDOEBHGA@Location?$AA@			; `string'
PUBLIC	??_C@_02EGCJHIOB@id?$AA@			; `string'
PUBLIC	??_C@_04MEMAJGDJ@name?$AA@			; `string'
PUBLIC	??_C@_0CA@JMCBIEPM@?$AN?6A?5new?5light?5found?$FLid?5?$DN?5?$CFs?$FN?4?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CH@CPEAOEE@Failed?5to?5set?5periodic?5timer?5obj@ ; `string'
PUBLIC	??_C@_0O@NGDBLNOO@ylight_search?$AA@		; `string'
PUBLIC	??_C@_0BO@IGAGLHOP@?$CFs?3failed?5to?5create?5socket?4?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CD@GKFDFANO@?$CFs?3failed?5to?5set?5sock?8s?5timeout?4@ ; `string'
PUBLIC	??_C@_0O@DPNDNAHN@192?4168?4169?41?$AA@		; `string'
PUBLIC	??_C@_0CI@KJBPHAMN@?$CFs?3failed?5to?5set?5out?5going?5inter@ ; `string'
PUBLIC	??_C@_0BA@CBMJEEJH@239?4255?4255?4250?$AA@	; `string'
PUBLIC	??_C@_0CO@KGNPGLJH@?$CFs?3failed?5to?5join?5multicast?5grou@ ; `string'
PUBLIC	??_C@_0CI@PENFDHGF@?$CFs?3failed?5to?5bind?5to?5local?5inter@ ; `string'
PUBLIC	??_C@_0FF@FBGGPKPL@M?9SEARCH?5?$CK?5HTTP?11?41?$AN?6HOST?3?5239?42@ ; `string'
PUBLIC	??_C@_0BN@FNGCAHAH@?$CFs?3failed?5to?5send?5request?4?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CK@PBKIGACE@Yeelight?5controller?5for?5HelloX?$FLv@ ; `string'
PUBLIC	??_C@_08DLKNFOKI@YEELIGHT?$AA@			; `string'
PUBLIC	??_C@_0CF@HBGJCFMO@Failed?5to?5create?5searching?5threa@ ; `string'
PUBLIC	??_C@_04DONFEANM@list?$AA@			; `string'
PUBLIC	??_C@_04MKNBDEPB@exit?$AA@			; `string'
PUBLIC	??_C@_06MBEFLBGA@turnon?$AA@			; `string'
PUBLIC	??_C@_07HAMHLJHA@turnoff?$AA@			; `string'
PUBLIC	??_C@_04PCJFHION@help?$AA@			; `string'
PUBLIC	??_C@_0CK@NGFOKCMD@?5?5list?5?5?5?5?3?5Show?5out?5all?5found?5b@ ; `string'
PUBLIC	??_C@_0CI@BDNJHNCO@?5?5turnon?5?5?3?5Turn?5on?5a?5specified?5@ ; `string'
PUBLIC	??_C@_0CJ@LLFNANIG@?5?5turnoff?5?3?5Turn?5off?5a?5specified@ ; `string'
PUBLIC	??_C@_0CE@OOIGHMBB@?5?5exit?5?5?5?5?3?5Exit?5the?5application@ ; `string'
PUBLIC	??_C@_0BF@MJDKECEM@?5?5Unknown?5command?4?$AN?6?$AA@ ; `string'
EXTRN	_CreateKernelThread:PROC
EXTRN	_DestroyKernelThread:PROC
EXTRN	_GetMessage:PROC
EXTRN	_SendMessage:PROC
EXTRN	_SetTimer:PROC
EXTRN	_CancelTimer:PROC
EXTRN	_WaitForThisObject:PROC
EXTRN	_getcmd:PROC
EXTRN	___BUG:PROC
EXTRN	_LogHeader:PROC
EXTRN	__hx_printf:PROC
EXTRN	__hx_sprintf:PROC
EXTRN	__hx_malloc:PROC
EXTRN	__hx_free:PROC
EXTRN	_atol:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	_strtok:PROC
EXTRN	_ipaddr_addr:PROC
EXTRN	_ipaddr_ntoa:PROC
EXTRN	__hx_htonl:PROC
EXTRN	__hx_htons:PROC
EXTRN	__hx_ntohs:PROC
EXTRN	_bind:PROC
EXTRN	_setsockopt:PROC
EXTRN	_close:PROC
EXTRN	_connect:PROC
EXTRN	_recv:PROC
EXTRN	_recvfrom:PROC
EXTRN	_send:PROC
EXTRN	_sendto:PROC
EXTRN	_socket:PROC
;	COMDAT ??_C@_0BF@MJDKECEM@?5?5Unknown?5command?4?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BF@MJDKECEM@?5?5Unknown?5command?4?$AN?6?$AA@ DB '  Unknown comman'
	DB	'd.', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OOIGHMBB@?5?5exit?5?5?5?5?3?5Exit?5the?5application@
CONST	SEGMENT
??_C@_0CE@OOIGHMBB@?5?5exit?5?5?5?5?3?5Exit?5the?5application@ DB '  exit'
	DB	'    : Exit the application.', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@LLFNANIG@?5?5turnoff?5?3?5Turn?5off?5a?5specified@
CONST	SEGMENT
??_C@_0CJ@LLFNANIG@?5?5turnoff?5?3?5Turn?5off?5a?5specified@ DB '  turnof'
	DB	'f : Turn off a specified bulb.', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@BDNJHNCO@?5?5turnon?5?5?3?5Turn?5on?5a?5specified?5@
CONST	SEGMENT
??_C@_0CI@BDNJHNCO@?5?5turnon?5?5?3?5Turn?5on?5a?5specified?5@ DB '  turn'
	DB	'on  : Turn on a specified bulb.', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@NGFOKCMD@?5?5list?5?5?5?5?3?5Show?5out?5all?5found?5b@
CONST	SEGMENT
??_C@_0CK@NGFOKCMD@?5?5list?5?5?5?5?3?5Show?5out?5all?5found?5b@ DB '  li'
	DB	'st    : Show out all found bulb(s).', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04PCJFHION@help?$AA@
CONST	SEGMENT
??_C@_04PCJFHION@help?$AA@ DB 'help', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HAMHLJHA@turnoff?$AA@
CONST	SEGMENT
??_C@_07HAMHLJHA@turnoff?$AA@ DB 'turnoff', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MBEFLBGA@turnon?$AA@
CONST	SEGMENT
??_C@_06MBEFLBGA@turnon?$AA@ DB 'turnon', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKNBDEPB@exit?$AA@
CONST	SEGMENT
??_C@_04MKNBDEPB@exit?$AA@ DB 'exit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DONFEANM@list?$AA@
CONST	SEGMENT
??_C@_04DONFEANM@list?$AA@ DB 'list', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@HBGJCFMO@Failed?5to?5create?5searching?5threa@
CONST	SEGMENT
??_C@_0CF@HBGJCFMO@Failed?5to?5create?5searching?5threa@ DB 'Failed to cr'
	DB	'eate searching thread.', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DLKNFOKI@YEELIGHT?$AA@
CONST	SEGMENT
??_C@_08DLKNFOKI@YEELIGHT?$AA@ DB 'YEELIGHT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PBKIGACE@Yeelight?5controller?5for?5HelloX?$FLv@
CONST	SEGMENT
??_C@_0CK@PBKIGACE@Yeelight?5controller?5for?5HelloX?$FLv@ DB 'Yeelight c'
	DB	'ontroller for HelloX[v%d.%d].', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FNGCAHAH@?$CFs?3failed?5to?5send?5request?4?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BN@FNGCAHAH@?$CFs?3failed?5to?5send?5request?4?$AN?6?$AA@ DB '%s:f'
	DB	'ailed to send request.', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@FBGGPKPL@M?9SEARCH?5?$CK?5HTTP?11?41?$AN?6HOST?3?5239?42@
CONST	SEGMENT
??_C@_0FF@FBGGPKPL@M?9SEARCH?5?$CK?5HTTP?11?41?$AN?6HOST?3?5239?42@ DB 'M'
	DB	'-SEARCH * HTTP/1.1', 0dH, 0aH, 'HOST: 239.255.255.250:1982', 0dH
	DB	0aH, 'MAN: "ssdp:discover"', 0dH, 0aH, 'ST: wifi_bulb', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PENFDHGF@?$CFs?3failed?5to?5bind?5to?5local?5inter@
CONST	SEGMENT
??_C@_0CI@PENFDHGF@?$CFs?3failed?5to?5bind?5to?5local?5inter@ DB '%s:fail'
	DB	'ed to bind to local interface.', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@KGNPGLJH@?$CFs?3failed?5to?5join?5multicast?5grou@
CONST	SEGMENT
??_C@_0CO@KGNPGLJH@?$CFs?3failed?5to?5join?5multicast?5grou@ DB '%s:faile'
	DB	'd to join multicast group,err = %d.', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CBMJEEJH@239?4255?4255?4250?$AA@
CONST	SEGMENT
??_C@_0BA@CBMJEEJH@239?4255?4255?4250?$AA@ DB '239.255.255.250', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KJBPHAMN@?$CFs?3failed?5to?5set?5out?5going?5inter@
CONST	SEGMENT
??_C@_0CI@KJBPHAMN@?$CFs?3failed?5to?5set?5out?5going?5inter@ DB '%s:fail'
	DB	'ed to set out going interface.', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DPNDNAHN@192?4168?4169?41?$AA@
CONST	SEGMENT
??_C@_0O@DPNDNAHN@192?4168?4169?41?$AA@ DB '192.168.169.1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GKFDFANO@?$CFs?3failed?5to?5set?5sock?8s?5timeout?4@
CONST	SEGMENT
??_C@_0CD@GKFDFANO@?$CFs?3failed?5to?5set?5sock?8s?5timeout?4@ DB '%s:fai'
	DB	'led to set sock''s timeout.', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IGAGLHOP@?$CFs?3failed?5to?5create?5socket?4?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BO@IGAGLHOP@?$CFs?3failed?5to?5create?5socket?4?$AN?6?$AA@ DB '%s:'
	DB	'failed to create socket.', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NGDBLNOO@ylight_search?$AA@
CONST	SEGMENT
??_C@_0O@NGDBLNOO@ylight_search?$AA@ DB 'ylight_search', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CPEAOEE@Failed?5to?5set?5periodic?5timer?5obj@
CONST	SEGMENT
??_C@_0CH@CPEAOEE@Failed?5to?5set?5periodic?5timer?5obj@ DB 'Failed to se'
	DB	't periodic timer object.', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JMCBIEPM@?$AN?6A?5new?5light?5found?$FLid?5?$DN?5?$CFs?$FN?4?$AN?6?$AA@
CONST	SEGMENT
??_C@_0CA@JMCBIEPM@?$AN?6A?5new?5light?5found?$FLid?5?$DN?5?$CFs?$FN?4?$AN?6?$AA@ DB 0dH
	DB	0aH, 'A new light found[id = %s].', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name?$AA@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name?$AA@ DB 'name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGCJHIOB@id?$AA@
CONST	SEGMENT
??_C@_02EGCJHIOB@id?$AA@ DB 'id', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08KDOEBHGA@Location?$AA@
CONST	SEGMENT
??_C@_08KDOEBHGA@Location?$AA@ DB 'Location', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6?$AA@
CONST	SEGMENT
??_C@_02PCIJFNDE@?$AN?6?$AA@ DB 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PCKCGHAM@Status?5update?3?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@PCKCGHAM@Status?5update?3?$CFs?$AN?6?$AA@ DB 'Status update:%s', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@PHCHOKIN@Received?5status?5update?5message?$FLs@
CONST	SEGMENT
??_C@_0CN@PHCHOKIN@Received?5status?5update?5message?$FLs@ DB 'Received s'
	DB	'tatus update message[size = %d].', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MBPHKCID@Failed?5to?5recv?5resp?$FLret?5?$DN?5?$CFd?$FN?4?$AN?6@
CONST	SEGMENT
??_C@_0CB@MBPHKCID@Failed?5to?5recv?5resp?$FLret?5?$DN?5?$CFd?$FN?4?$AN?6@ DB 'F'
	DB	'ailed to recv resp[ret = %d].', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DDIPKHPP@Failed?5to?5send?5toggle?5command?4?$AN?6@
CONST	SEGMENT
??_C@_0CB@DDIPKHPP@Failed?5to?5send?5toggle?5command?4?$AN?6@ DB 'Failed '
	DB	'to send toggle command.', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NPJCALFH@Connect?5to?5light?5object?5OK?4?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BO@NPJCALFH@Connect?5to?5light?5object?5OK?4?$AN?6?$AA@ DB 'Connec'
	DB	't to light object OK.', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@OAKNKFDD@Can?5not?5connect?5to?5light?5object?$FL@
CONST	SEGMENT
??_C@_0CN@OAKNKFDD@Can?5not?5connect?5to?5light?5object?$FL@ DB 'Can not '
	DB	'connect to light object[ret = %d].', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KLBIHOJL@Can?5not?5create?5socket?5object?4?$AN?6?$AA@
CONST	SEGMENT
??_C@_0CA@KLBIHOJL@Can?5not?5create?5socket?5object?4?$AN?6?$AA@ DB 'Can '
	DB	'not create socket object.', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@NIFJBDJE@?$HL?$CCid?$CC?3?$CC?$CFs?$CC?0?$CCmethod?$CC?3?$CCtoggle?$CC?0?$CCpa@
CONST	SEGMENT
??_C@_0CM@NIFJBDJE@?$HL?$CCid?$CC?3?$CC?$CFs?$CC?0?$CCmethod?$CC?3?$CCtoggle?$CC?0?$CCpa@ DB '{'
	DB	'"id":"%s","method":"toggle","params":[]}', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PIBEHDPH@port?3?5?$CFd?$AN?6?$AA@
CONST	SEGMENT
??_C@_0L@PIBEHDPH@port?3?5?$CFd?$AN?6?$AA@ DB 'port: %d', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MMEFGGML@ip?3?5?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_08MMEFGGML@ip?3?5?$CFs?$AN?6?$AA@ DB 'ip: %s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DELEFJBK@id?3?5?$CFs?$AN?6?$AA@
CONST	SEGMENT
??_C@_08DELEFJBK@id?3?5?$CFs?$AN?6?$AA@ DB 'id: %s', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HGHOBMCE@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BH@HGHOBMCE@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?$AN?6?$AA@ DB '-'
	DB	'-------------------', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EEABGAIP@yeelight?$AA@
CONST	SEGMENT
??_C@_08EEABGAIP@yeelight?$AA@ DB 'yeelight', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@DLILGIOL@c?3?2hellox?2personal?2hellox_os?2app@
CONST	SEGMENT
??_C@_0DJ@DLILGIOL@c?3?2hellox?2personal?2hellox_os?2app@ DB 'c:\hellox\p'
	DB	'ersonal\hellox_os\app\yeelight\src\yeelight.c', 00H ; `string'
CONST	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\src\yeelight.c
;	COMDAT __hx_main
_TEXT	SEGMENT
_cmd_array$ = -40					; size = 16
_msg$ = -24						; size = 8
_i$ = -16						; size = 4
_cmd_num$ = -12						; size = 4
_pLight$ = -8						; size = 4
_hSearchThread$ = -4					; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
__hx_main PROC						; COMDAT

; 504  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 505  : 	char* cmd_array[4];
; 506  : 	int cmd_num = 0, i = 0;

  00006	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _cmd_num$[ebp], 0
  0000d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 507  : 	struct yeelight_object* pLight = NULL;

  00014	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pLight$[ebp], 0

; 508  : 	HANDLE hSearchThread = NULL;

  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hSearchThread$[ebp], 0

; 509  : 	MSG msg;
; 510  : 
; 511  : 	/* Show version info. */
; 512  : 	_hx_printf("Yeelight controller for HelloX[v%d.%d].\r\n", __MAJOR_VER, __MINNOR_VER);

  00022	6a 00		 push	 0
  00024	6a 01		 push	 1
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PBKIGACE@Yeelight?5controller?5for?5HelloX?$FLv@
  0002b	e8 00 00 00 00	 call	 __hx_printf
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 513  : 
; 514  : 	/* 
; 515  : 	 * A dedicated kernel thread is running in background, to search and 
; 516  : 	 * manages all bulb(s) in LAN.
; 517  : 	 * Bring up this kernel thread first.
; 518  : 	 */
; 519  : 	hSearchThread = CreateKernelThread(

  00033	68 00 00 00 00	 push	 OFFSET ??_C@_08DLKNFOKI@YEELIGHT?$AA@
  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	68 00 00 00 00	 push	 OFFSET _ylight_search
  00041	6a 08		 push	 8
  00043	6a 02		 push	 2
  00045	6a 00		 push	 0
  00047	e8 00 00 00 00	 call	 _CreateKernelThread
  0004c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0004f	89 45 fc	 mov	 DWORD PTR _hSearchThread$[ebp], eax

; 520  : 		0,
; 521  : 		KERNEL_THREAD_STATUS_READY,
; 522  : 		PRIORITY_LEVEL_NORMAL,
; 523  : 		ylight_search,
; 524  : 		NULL,
; 525  : 		NULL,
; 526  : 		"YEELIGHT");
; 527  : 	if (NULL == hSearchThread)

  00052	83 7d fc 00	 cmp	 DWORD PTR _hSearchThread$[ebp], 0
  00056	75 1c		 jne	 SHORT $LN2@hx_main

; 528  : 	{
; 529  : 		__LOG("Failed to create searching thread.\r\n");

  00058	6a 00		 push	 0
  0005a	e8 00 00 00 00	 call	 _LogHeader
  0005f	83 c4 04	 add	 esp, 4
  00062	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@HBGJCFMO@Failed?5to?5create?5searching?5threa@
  00067	e8 00 00 00 00	 call	 __hx_printf
  0006c	83 c4 04	 add	 esp, 4

; 530  : 		goto __TERMINAL;

  0006f	e9 56 01 00 00	 jmp	 $__TERMINAL$23
$LN2@hx_main:

; 531  : 	}
; 532  : 
; 533  : 	/* Interactive with user. */
; 534  : 	while (TRUE)

  00074	83 c8 ff	 or	 eax, -1
  00077	0f 84 4d 01 00
	00		 je	 $__TERMINAL$23

; 535  : 	{
; 536  : 		cmd_num = getcmd(cmd_array, 4);

  0007d	6a 04		 push	 4
  0007f	8d 4d d8	 lea	 ecx, DWORD PTR _cmd_array$[ebp]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 _getcmd
  00088	83 c4 08	 add	 esp, 8
  0008b	89 45 f4	 mov	 DWORD PTR _cmd_num$[ebp], eax

; 537  : 		if (cmd_num > 0)

  0008e	83 7d f4 00	 cmp	 DWORD PTR _cmd_num$[ebp], 0
  00092	0f 8e 2d 01 00
	00		 jle	 $LN7@hx_main

; 538  : 		{
; 539  : 			if (strcmp(cmd_array[0], "list") == 0)

  00098	68 00 00 00 00	 push	 OFFSET ??_C@_04DONFEANM@list?$AA@
  0009d	ba 04 00 00 00	 mov	 edx, 4
  000a2	6b c2 00	 imul	 eax, edx, 0
  000a5	8b 4c 05 d8	 mov	 ecx, DWORD PTR _cmd_array$[ebp+eax]
  000a9	51		 push	 ecx
  000aa	e8 00 00 00 00	 call	 _strcmp
  000af	83 c4 08	 add	 esp, 8
  000b2	85 c0		 test	 eax, eax
  000b4	75 14		 jne	 SHORT $LN8@hx_main

; 540  : 			{
; 541  : 				/* Show all found bulb(s). */
; 542  : 				ShowLight(pLightObject);

  000b6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pLightObject
  000bc	52		 push	 edx
  000bd	e8 00 00 00 00	 call	 _ShowLight
  000c2	83 c4 04	 add	 esp, 4

; 543  : 			}

  000c5	e9 fb 00 00 00	 jmp	 $LN7@hx_main
$LN8@hx_main:

; 544  : 			else if (strcmp(cmd_array[0], "exit") == 0)

  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_04MKNBDEPB@exit?$AA@
  000cf	b8 04 00 00 00	 mov	 eax, 4
  000d4	6b c8 00	 imul	 ecx, eax, 0
  000d7	8b 54 0d d8	 mov	 edx, DWORD PTR _cmd_array$[ebp+ecx]
  000db	52		 push	 edx
  000dc	e8 00 00 00 00	 call	 _strcmp
  000e1	83 c4 08	 add	 esp, 8
  000e4	85 c0		 test	 eax, eax
  000e6	75 0a		 jne	 SHORT $LN10@hx_main

; 545  : 			{
; 546  : 				/* Exit the application. */
; 547  : 				goto __TERMINAL;

  000e8	e9 dd 00 00 00	 jmp	 $__TERMINAL$23

; 548  : 			}

  000ed	e9 d3 00 00 00	 jmp	 $LN7@hx_main
$LN10@hx_main:

; 549  : 			else if (strcmp(cmd_array[0], "turnon") == 0)

  000f2	68 00 00 00 00	 push	 OFFSET ??_C@_06MBEFLBGA@turnon?$AA@
  000f7	b8 04 00 00 00	 mov	 eax, 4
  000fc	6b c8 00	 imul	 ecx, eax, 0
  000ff	8b 54 0d d8	 mov	 edx, DWORD PTR _cmd_array$[ebp+ecx]
  00103	52		 push	 edx
  00104	e8 00 00 00 00	 call	 _strcmp
  00109	83 c4 08	 add	 esp, 8
  0010c	85 c0		 test	 eax, eax
  0010e	75 1c		 jne	 SHORT $LN12@hx_main

; 550  : 			{
; 551  : 				/* 
; 552  : 				 * Turn on the specified light,but we just turn on 
; 553  : 				 * the first light in list,for simplicity.
; 554  : 				 */
; 555  : 				if (pLightObject)

  00110	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _pLightObject, 0
  00117	74 0e		 je	 SHORT $LN14@hx_main

; 556  : 				{
; 557  : 					ToggleYlight(pLightObject);

  00119	a1 00 00 00 00	 mov	 eax, DWORD PTR _pLightObject
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 _ToggleYlight
  00124	83 c4 04	 add	 esp, 4
$LN14@hx_main:

; 558  : 				}
; 559  : 			}

  00127	e9 99 00 00 00	 jmp	 $LN7@hx_main
$LN12@hx_main:

; 560  : 			else if (strcmp(cmd_array[0], "turnoff") == 0)

  0012c	68 00 00 00 00	 push	 OFFSET ??_C@_07HAMHLJHA@turnoff?$AA@
  00131	b9 04 00 00 00	 mov	 ecx, 4
  00136	6b d1 00	 imul	 edx, ecx, 0
  00139	8b 44 15 d8	 mov	 eax, DWORD PTR _cmd_array$[ebp+edx]
  0013d	50		 push	 eax
  0013e	e8 00 00 00 00	 call	 _strcmp
  00143	83 c4 08	 add	 esp, 8
  00146	85 c0		 test	 eax, eax
  00148	75 1a		 jne	 SHORT $LN15@hx_main

; 561  : 			{
; 562  : 				/* Turn off the first light. */
; 563  : 				if (pLightObject)

  0014a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _pLightObject, 0
  00151	74 0f		 je	 SHORT $LN17@hx_main

; 564  : 				{
; 565  : 					ToggleYlight(pLightObject);

  00153	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pLightObject
  00159	51		 push	 ecx
  0015a	e8 00 00 00 00	 call	 _ToggleYlight
  0015f	83 c4 04	 add	 esp, 4
$LN17@hx_main:

; 566  : 				}
; 567  : 			}

  00162	eb 61		 jmp	 SHORT $LN7@hx_main
$LN15@hx_main:

; 568  : 			else if (strcmp(cmd_array[0], "help") == 0)

  00164	68 00 00 00 00	 push	 OFFSET ??_C@_04PCJFHION@help?$AA@
  00169	ba 04 00 00 00	 mov	 edx, 4
  0016e	6b c2 00	 imul	 eax, edx, 0
  00171	8b 4c 05 d8	 mov	 ecx, DWORD PTR _cmd_array$[ebp+eax]
  00175	51		 push	 ecx
  00176	e8 00 00 00 00	 call	 _strcmp
  0017b	83 c4 08	 add	 esp, 8
  0017e	85 c0		 test	 eax, eax
  00180	75 36		 jne	 SHORT $LN18@hx_main

; 569  : 			{
; 570  : 				/* Show help information. */
; 571  : 				_hx_printf("  list    : Show out all found bulb(s).\r\n");

  00182	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@NGFOKCMD@?5?5list?5?5?5?5?3?5Show?5out?5all?5found?5b@
  00187	e8 00 00 00 00	 call	 __hx_printf
  0018c	83 c4 04	 add	 esp, 4

; 572  : 				_hx_printf("  turnon  : Turn on a specified bulb.\r\n");

  0018f	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@BDNJHNCO@?5?5turnon?5?5?3?5Turn?5on?5a?5specified?5@
  00194	e8 00 00 00 00	 call	 __hx_printf
  00199	83 c4 04	 add	 esp, 4

; 573  : 				_hx_printf("  turnoff : Turn off a specified bulb.\r\n");

  0019c	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@LLFNANIG@?5?5turnoff?5?3?5Turn?5off?5a?5specified@
  001a1	e8 00 00 00 00	 call	 __hx_printf
  001a6	83 c4 04	 add	 esp, 4

; 574  : 				_hx_printf("  exit    : Exit the application.\r\n");

  001a9	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@OOIGHMBB@?5?5exit?5?5?5?5?3?5Exit?5the?5application@
  001ae	e8 00 00 00 00	 call	 __hx_printf
  001b3	83 c4 04	 add	 esp, 4

; 575  : 			}

  001b6	eb 0d		 jmp	 SHORT $LN7@hx_main
$LN18@hx_main:

; 576  : 			else
; 577  : 			{
; 578  : 				/* Unknown command. */
; 579  : 				_hx_printf("  Unknown command.\r\n");

  001b8	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MJDKECEM@?5?5Unknown?5command?4?$AN?6?$AA@
  001bd	e8 00 00 00 00	 call	 __hx_printf
  001c2	83 c4 04	 add	 esp, 4
$LN7@hx_main:

; 580  : 			}
; 581  : 		}
; 582  : 	}

  001c5	e9 aa fe ff ff	 jmp	 $LN2@hx_main
$__TERMINAL$23:

; 583  : __TERMINAL:
; 584  : 	if (hSearchThread)

  001ca	83 7d fc 00	 cmp	 DWORD PTR _hSearchThread$[ebp], 0
  001ce	74 31		 je	 SHORT $LN4@hx_main

; 585  : 	{
; 586  : 		/* Notify the searching thread to exit. */
; 587  : 		msg.wCommand = KERNEL_MESSAGE_TERMINAL;

  001d0	ba 05 00 00 00	 mov	 edx, 5
  001d5	66 89 55 e8	 mov	 WORD PTR _msg$[ebp], dx

; 588  : 		SendMessage(hSearchThread, &msg);

  001d9	8d 45 e8	 lea	 eax, DWORD PTR _msg$[ebp]
  001dc	50		 push	 eax
  001dd	8b 4d fc	 mov	 ecx, DWORD PTR _hSearchThread$[ebp]
  001e0	51		 push	 ecx
  001e1	e8 00 00 00 00	 call	 _SendMessage
  001e6	83 c4 08	 add	 esp, 8

; 589  : 		/* Wait for the searching thread run over. */
; 590  : 		WaitForThisObject(hSearchThread);

  001e9	8b 55 fc	 mov	 edx, DWORD PTR _hSearchThread$[ebp]
  001ec	52		 push	 edx
  001ed	e8 00 00 00 00	 call	 _WaitForThisObject
  001f2	83 c4 04	 add	 esp, 4

; 591  : 		/* Destroy it. */
; 592  : 		DestroyKernelThread(hSearchThread);

  001f5	8b 45 fc	 mov	 eax, DWORD PTR _hSearchThread$[ebp]
  001f8	50		 push	 eax
  001f9	e8 00 00 00 00	 call	 _DestroyKernelThread
  001fe	83 c4 04	 add	 esp, 4
$LN4@hx_main:

; 593  : 	}
; 594  : 
; 595  : 	/* Destroy all light object(s). */
; 596  : 	while (pLightObject)

  00201	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _pLightObject, 0
  00208	74 3d		 je	 SHORT $LN5@hx_main

; 597  : 	{
; 598  : 		pLight = pLightObject;

  0020a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pLightObject
  00210	89 4d f8	 mov	 DWORD PTR _pLight$[ebp], ecx

; 599  : 		pLightObject = pLightObject->pNext;

  00213	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pLightObject
  00219	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0021c	a3 00 00 00 00	 mov	 DWORD PTR _pLightObject, eax

; 600  : 		/* Close socket if open. */
; 601  : 		if (pLight->sock >= 0)

  00221	8b 4d f8	 mov	 ecx, DWORD PTR _pLight$[ebp]
  00224	83 79 2c 00	 cmp	 DWORD PTR [ecx+44], 0
  00228	7c 0f		 jl	 SHORT $LN21@hx_main

; 602  : 		{
; 603  : 			close(pLight->sock);

  0022a	8b 55 f8	 mov	 edx, DWORD PTR _pLight$[ebp]
  0022d	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00230	50		 push	 eax
  00231	e8 00 00 00 00	 call	 _close
  00236	83 c4 04	 add	 esp, 4
$LN21@hx_main:

; 604  : 		}
; 605  : 		_hx_free(pLight);

  00239	8b 4d f8	 mov	 ecx, DWORD PTR _pLight$[ebp]
  0023c	51		 push	 ecx
  0023d	e8 00 00 00 00	 call	 __hx_free
  00242	83 c4 04	 add	 esp, 4

; 606  : 	}

  00245	eb ba		 jmp	 SHORT $LN4@hx_main
$LN5@hx_main:

; 607  : 	
; 608  : 	return 0;

  00247	33 c0		 xor	 eax, eax

; 609  : }

  00249	8b e5		 mov	 esp, ebp
  0024b	5d		 pop	 ebp
  0024c	c3		 ret	 0
__hx_main ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\src\yeelight.c
;	COMDAT _ylight_search
_TEXT	SEGMENT
_gaddr$ = -64						; size = 16
_msg$ = -48						; size = 8
_mreq$ = -40						; size = 8
_ifaddr$ = -32						; size = 4
_timeout$ = -28						; size = 4
tv173 = -24						; size = 4
_len$ = -20						; size = 4
_hTimer$ = -16						; size = 4
_buf$ = -12						; size = 4
_s$ = -8						; size = 4
_ret$ = -4						; size = 4
_pData$ = 8						; size = 4
_ylight_search PROC					; COMDAT

; 362  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 363  : 	int s = -1, ret = -1, len = 0;

  00006	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _s$[ebp], -1
  0000d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -1
  00014	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 364  : 	int timeout = SSDP_WAIT_TIMEOUT;

  0001b	c7 45 e4 d0 07
	00 00		 mov	 DWORD PTR _timeout$[ebp], 2000 ; 000007d0H

; 365  : 	char* buf = NULL;

  00022	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _buf$[ebp], 0

; 366  : 	struct sockaddr_in gaddr;
; 367  : 	struct in_addr ifaddr;
; 368  : 	HANDLE hTimer = NULL;

  00029	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _hTimer$[ebp], 0

; 369  : 	MSG msg;
; 370  : 
; 371  : 	/* Create the periodic timer that trigger light searching. */
; 372  : 	hTimer = SetTimer(YLIGHT_PERIODIC_ID, SSDP_PERIODIC_TIME, NULL, NULL, TIMER_FLAGS_ALWAYS);

  00030	6a 02		 push	 2
  00032	6a 00		 push	 0
  00034	6a 00		 push	 0
  00036	68 b8 0b 00 00	 push	 3000			; 00000bb8H
  0003b	68 e8 03 00 00	 push	 1000			; 000003e8H
  00040	e8 00 00 00 00	 call	 _SetTimer
  00045	83 c4 14	 add	 esp, 20			; 00000014H
  00048	89 45 f0	 mov	 DWORD PTR _hTimer$[ebp], eax

; 373  : 	if (NULL == hTimer)

  0004b	83 7d f0 00	 cmp	 DWORD PTR _hTimer$[ebp], 0
  0004f	75 1c		 jne	 SHORT $LN6@ylight_sea

; 374  : 	{
; 375  : 		__LOG("Failed to set periodic timer object.\r\n");

  00051	6a 00		 push	 0
  00053	e8 00 00 00 00	 call	 _LogHeader
  00058	83 c4 04	 add	 esp, 4
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@CPEAOEE@Failed?5to?5set?5periodic?5timer?5obj@
  00060	e8 00 00 00 00	 call	 __hx_printf
  00065	83 c4 04	 add	 esp, 4

; 376  : 		goto __TERMINAL;

  00068	e9 d8 02 00 00	 jmp	 $__TERMINAL$25
$LN6@ylight_sea:

; 377  : 	}
; 378  : 
; 379  : 	/* Create socket to receive multicast data. */
; 380  : 	s = socket(AF_INET, SOCK_DGRAM, 0);

  0006d	6a 00		 push	 0
  0006f	6a 02		 push	 2
  00071	6a 02		 push	 2
  00073	e8 00 00 00 00	 call	 _socket
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007b	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax

; 381  : 	if (s < 0)

  0007e	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  00082	7d 21		 jge	 SHORT $LN7@ylight_sea

; 382  : 	{
; 383  : 		__LOG("%s:failed to create socket.\r\n", __FUNCTION__);

  00084	6a 00		 push	 0
  00086	e8 00 00 00 00	 call	 _LogHeader
  0008b	83 c4 04	 add	 esp, 4
  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NGDBLNOO@ylight_search?$AA@
  00093	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@IGAGLHOP@?$CFs?3failed?5to?5create?5socket?4?$AN?6?$AA@
  00098	e8 00 00 00 00	 call	 __hx_printf
  0009d	83 c4 08	 add	 esp, 8

; 384  : 		goto __TERMINAL;

  000a0	e9 a0 02 00 00	 jmp	 $__TERMINAL$25
$LN7@ylight_sea:

; 385  : 	}
; 386  : 
; 387  : 	/* Set timeout value for this socket. */
; 388  : 	ret = setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));

  000a5	6a 04		 push	 4
  000a7	8d 45 e4	 lea	 eax, DWORD PTR _timeout$[ebp]
  000aa	50		 push	 eax
  000ab	68 06 10 00 00	 push	 4102			; 00001006H
  000b0	68 ff 0f 00 00	 push	 4095			; 00000fffH
  000b5	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000b8	51		 push	 ecx
  000b9	e8 00 00 00 00	 call	 _setsockopt
  000be	83 c4 14	 add	 esp, 20			; 00000014H
  000c1	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 389  : 	if (ret < 0)

  000c4	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  000c8	7d 21		 jge	 SHORT $LN8@ylight_sea

; 390  : 	{
; 391  : 		__LOG("%s:failed to set sock's timeout.\r\n", __FUNCTION__);

  000ca	6a 00		 push	 0
  000cc	e8 00 00 00 00	 call	 _LogHeader
  000d1	83 c4 04	 add	 esp, 4
  000d4	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NGDBLNOO@ylight_search?$AA@
  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@GKFDFANO@?$CFs?3failed?5to?5set?5sock?8s?5timeout?4@
  000de	e8 00 00 00 00	 call	 __hx_printf
  000e3	83 c4 08	 add	 esp, 8

; 392  : 		goto __TERMINAL;

  000e6	e9 5a 02 00 00	 jmp	 $__TERMINAL$25
$LN8@ylight_sea:

; 393  : 	}
; 394  : 
; 395  : 	/* Set out going interface of this multicast socket. */
; 396  : 	ifaddr.s_addr = inet_addr(SSDP_LAN_ADDR);

  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DPNDNAHN@192?4168?4169?41?$AA@
  000f0	e8 00 00 00 00	 call	 _ipaddr_addr
  000f5	83 c4 04	 add	 esp, 4
  000f8	89 45 e0	 mov	 DWORD PTR _ifaddr$[ebp], eax

; 397  : 	ret = setsockopt(s, IPPROTO_IP, IP_MULTICAST_IF, &ifaddr, sizeof(ifaddr));

  000fb	6a 04		 push	 4
  000fd	8d 55 e0	 lea	 edx, DWORD PTR _ifaddr$[ebp]
  00100	52		 push	 edx
  00101	6a 06		 push	 6
  00103	6a 00		 push	 0
  00105	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _setsockopt
  0010e	83 c4 14	 add	 esp, 20			; 00000014H
  00111	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 398  : 	if (ret < 0)

  00114	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00118	7d 21		 jge	 SHORT $LN9@ylight_sea

; 399  : 	{
; 400  : 		__LOG("%s:failed to set out going interface.\r\n", __FUNCTION__);

  0011a	6a 00		 push	 0
  0011c	e8 00 00 00 00	 call	 _LogHeader
  00121	83 c4 04	 add	 esp, 4
  00124	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NGDBLNOO@ylight_search?$AA@
  00129	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@KJBPHAMN@?$CFs?3failed?5to?5set?5out?5going?5inter@
  0012e	e8 00 00 00 00	 call	 __hx_printf
  00133	83 c4 08	 add	 esp, 8

; 401  : 		goto __TERMINAL;

  00136	e9 0a 02 00 00	 jmp	 $__TERMINAL$25
$LN9@ylight_sea:

; 402  : 	}
; 403  : 
; 404  : 	/* Join the multicase group. */
; 405  : 	struct ip_mreq mreq;
; 406  : 	mreq.imr_interface.s_addr = _hx_htonl(INADDR_ANY);

  0013b	6a 00		 push	 0
  0013d	e8 00 00 00 00	 call	 __hx_htonl
  00142	83 c4 04	 add	 esp, 4
  00145	89 45 dc	 mov	 DWORD PTR _mreq$[ebp+4], eax

; 407  : 	mreq.imr_multiaddr.s_addr = inet_addr(SSDP_DEST_ADDR);

  00148	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@CBMJEEJH@239?4255?4255?4250?$AA@
  0014d	e8 00 00 00 00	 call	 _ipaddr_addr
  00152	83 c4 04	 add	 esp, 4
  00155	89 45 d8	 mov	 DWORD PTR _mreq$[ebp], eax

; 408  : 	ret = setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(struct ip_mreq));

  00158	6a 08		 push	 8
  0015a	8d 4d d8	 lea	 ecx, DWORD PTR _mreq$[ebp]
  0015d	51		 push	 ecx
  0015e	6a 03		 push	 3
  00160	6a 00		 push	 0
  00162	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00165	52		 push	 edx
  00166	e8 00 00 00 00	 call	 _setsockopt
  0016b	83 c4 14	 add	 esp, 20			; 00000014H
  0016e	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 409  : 	if (ret < 0)

  00171	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00175	7d 25		 jge	 SHORT $LN10@ylight_sea

; 410  : 	{
; 411  : 		__LOG("%s:failed to join multicast group,err = %d.\r\n", __FUNCTION__, ret);

  00177	6a 00		 push	 0
  00179	e8 00 00 00 00	 call	 _LogHeader
  0017e	83 c4 04	 add	 esp, 4
  00181	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]
  00184	50		 push	 eax
  00185	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NGDBLNOO@ylight_search?$AA@
  0018a	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@KGNPGLJH@?$CFs?3failed?5to?5join?5multicast?5grou@
  0018f	e8 00 00 00 00	 call	 __hx_printf
  00194	83 c4 0c	 add	 esp, 12			; 0000000cH

; 412  : 		goto __TERMINAL;

  00197	e9 a9 01 00 00	 jmp	 $__TERMINAL$25
$LN10@ylight_sea:

; 413  : 	}
; 414  : 
; 415  : 	/* Bind to multicast group address. */
; 416  : 	gaddr.sin_family = AF_INET;

  0019c	c6 45 c1 02	 mov	 BYTE PTR _gaddr$[ebp+1], 2

; 417  : 	gaddr.sin_port = _hx_htons(SSDP_DEST_PORT);

  001a0	68 be 07 00 00	 push	 1982			; 000007beH
  001a5	e8 00 00 00 00	 call	 __hx_htons
  001aa	83 c4 04	 add	 esp, 4
  001ad	66 89 45 c2	 mov	 WORD PTR _gaddr$[ebp+2], ax

; 418  : 	gaddr.sin_addr.s_addr = _hx_htonl(INADDR_ANY);

  001b1	6a 00		 push	 0
  001b3	e8 00 00 00 00	 call	 __hx_htonl
  001b8	83 c4 04	 add	 esp, 4
  001bb	89 45 c4	 mov	 DWORD PTR _gaddr$[ebp+4], eax

; 419  : 	memset(gaddr.sin_zero, 0, sizeof(gaddr.sin_zero));

  001be	6a 08		 push	 8
  001c0	6a 00		 push	 0
  001c2	8d 4d c8	 lea	 ecx, DWORD PTR _gaddr$[ebp+8]
  001c5	51		 push	 ecx
  001c6	e8 00 00 00 00	 call	 _memset
  001cb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 420  : 	ret = bind(s, (struct sockaddr*)&gaddr, sizeof(gaddr));

  001ce	6a 10		 push	 16			; 00000010H
  001d0	8d 55 c0	 lea	 edx, DWORD PTR _gaddr$[ebp]
  001d3	52		 push	 edx
  001d4	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  001d7	50		 push	 eax
  001d8	e8 00 00 00 00	 call	 _bind
  001dd	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e0	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 421  : 	if (ret < 0)

  001e3	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  001e7	7d 21		 jge	 SHORT $LN11@ylight_sea

; 422  : 	{
; 423  : 		__LOG("%s:failed to bind to local interface.\r\n", __FUNCTION__);

  001e9	6a 00		 push	 0
  001eb	e8 00 00 00 00	 call	 _LogHeader
  001f0	83 c4 04	 add	 esp, 4
  001f3	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NGDBLNOO@ylight_search?$AA@
  001f8	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@PENFDHGF@?$CFs?3failed?5to?5bind?5to?5local?5inter@
  001fd	e8 00 00 00 00	 call	 __hx_printf
  00202	83 c4 08	 add	 esp, 8

; 424  : 		goto __TERMINAL;

  00205	e9 3b 01 00 00	 jmp	 $__TERMINAL$25
$LN11@ylight_sea:

; 425  : 	}
; 426  : 
; 427  : 	/* Allocate data buffer for this socket. */
; 428  : 	buf = _hx_malloc(1500);

  0020a	68 dc 05 00 00	 push	 1500			; 000005dcH
  0020f	e8 00 00 00 00	 call	 __hx_malloc
  00214	83 c4 04	 add	 esp, 4
  00217	89 45 f4	 mov	 DWORD PTR _buf$[ebp], eax

; 429  : 	if (NULL == buf)

  0021a	83 7d f4 00	 cmp	 DWORD PTR _buf$[ebp], 0
  0021e	75 05		 jne	 SHORT $LN2@ylight_sea

; 430  : 	{
; 431  : 		goto __TERMINAL;

  00220	e9 20 01 00 00	 jmp	 $__TERMINAL$25
$LN2@ylight_sea:

; 432  : 	}
; 433  : 	/* Main message loop. */
; 434  : 	while (TRUE)

  00225	83 c9 ff	 or	 ecx, -1
  00228	0f 84 17 01 00
	00		 je	 $__TERMINAL$25

; 435  : 	{
; 436  : 		if (GetMessage(&msg))

  0022e	8d 55 d0	 lea	 edx, DWORD PTR _msg$[ebp]
  00231	52		 push	 edx
  00232	e8 00 00 00 00	 call	 _GetMessage
  00237	83 c4 04	 add	 esp, 4
  0023a	85 c0		 test	 eax, eax
  0023c	0f 84 fe 00 00
	00		 je	 $LN13@ylight_sea

; 437  : 		{
; 438  : 			switch (msg.wCommand)

  00242	0f b7 45 d0	 movzx	 eax, WORD PTR _msg$[ebp]
  00246	89 45 e8	 mov	 DWORD PTR tv173[ebp], eax
  00249	83 7d e8 05	 cmp	 DWORD PTR tv173[ebp], 5
  0024d	0f 84 eb 00 00
	00		 je	 $LN19@ylight_sea
  00253	83 7d e8 06	 cmp	 DWORD PTR tv173[ebp], 6
  00257	74 05		 je	 SHORT $LN14@ylight_sea
  00259	e9 e2 00 00 00	 jmp	 $LN13@ylight_sea
$LN14@ylight_sea:

; 439  : 			{
; 440  : 			case KERNEL_MESSAGE_TIMER:
; 441  : 				/*
; 442  : 				* Search all WiFi bulbs in local network,send out a request to
; 443  : 				* multicast address to trigger the bulbs to response our request.
; 444  : 				*/
; 445  : 				len = sizeof(gaddr);

  0025e	c7 45 ec 10 00
	00 00		 mov	 DWORD PTR _len$[ebp], 16 ; 00000010H

; 446  : 				gaddr.sin_family = AF_INET;

  00265	c6 45 c1 02	 mov	 BYTE PTR _gaddr$[ebp+1], 2

; 447  : 				gaddr.sin_port = _hx_htons(SSDP_DEST_PORT);

  00269	68 be 07 00 00	 push	 1982			; 000007beH
  0026e	e8 00 00 00 00	 call	 __hx_htons
  00273	83 c4 04	 add	 esp, 4
  00276	66 89 45 c2	 mov	 WORD PTR _gaddr$[ebp+2], ax

; 448  : 				gaddr.sin_addr.s_addr = inet_addr(SSDP_DEST_ADDR);

  0027a	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@CBMJEEJH@239?4255?4255?4250?$AA@
  0027f	e8 00 00 00 00	 call	 _ipaddr_addr
  00284	83 c4 04	 add	 esp, 4
  00287	89 45 c4	 mov	 DWORD PTR _gaddr$[ebp+4], eax

; 449  : 				memset(gaddr.sin_zero, 0, sizeof(gaddr.sin_zero));

  0028a	6a 08		 push	 8
  0028c	6a 00		 push	 0
  0028e	8d 4d c8	 lea	 ecx, DWORD PTR _gaddr$[ebp+8]
  00291	51		 push	 ecx
  00292	e8 00 00 00 00	 call	 _memset
  00297	83 c4 0c	 add	 esp, 12			; 0000000cH

; 450  : 				strcpy(buf, SSDP_REQ_CMD);

  0029a	68 00 00 00 00	 push	 OFFSET ??_C@_0FF@FBGGPKPL@M?9SEARCH?5?$CK?5HTTP?11?41?$AN?6HOST?3?5239?42@
  0029f	8b 55 f4	 mov	 edx, DWORD PTR _buf$[ebp]
  002a2	52		 push	 edx
  002a3	e8 00 00 00 00	 call	 _strcpy
  002a8	83 c4 08	 add	 esp, 8

; 451  : 				ret = sendto(s, buf, strlen(buf), 0, (struct sockaddr*)&gaddr, len);

  002ab	8b 45 ec	 mov	 eax, DWORD PTR _len$[ebp]
  002ae	50		 push	 eax
  002af	8d 4d c0	 lea	 ecx, DWORD PTR _gaddr$[ebp]
  002b2	51		 push	 ecx
  002b3	6a 00		 push	 0
  002b5	8b 55 f4	 mov	 edx, DWORD PTR _buf$[ebp]
  002b8	52		 push	 edx
  002b9	e8 00 00 00 00	 call	 _strlen
  002be	83 c4 04	 add	 esp, 4
  002c1	50		 push	 eax
  002c2	8b 45 f4	 mov	 eax, DWORD PTR _buf$[ebp]
  002c5	50		 push	 eax
  002c6	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  002c9	51		 push	 ecx
  002ca	e8 00 00 00 00	 call	 _sendto
  002cf	83 c4 18	 add	 esp, 24			; 00000018H
  002d2	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 452  : 				if (ret < 0)

  002d5	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  002d9	7d 1e		 jge	 SHORT $LN16@ylight_sea

; 453  : 				{
; 454  : 					__LOG("%s:failed to send request.\r\n", __FUNCTION__);

  002db	6a 00		 push	 0
  002dd	e8 00 00 00 00	 call	 _LogHeader
  002e2	83 c4 04	 add	 esp, 4
  002e5	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NGDBLNOO@ylight_search?$AA@
  002ea	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@FNGCAHAH@?$CFs?3failed?5to?5send?5request?4?$AN?6?$AA@
  002ef	e8 00 00 00 00	 call	 __hx_printf
  002f4	83 c4 08	 add	 esp, 8

; 455  : 					goto __TERMINAL;

  002f7	eb 4c		 jmp	 SHORT $__TERMINAL$25
$LN16@ylight_sea:

; 456  : 				}
; 457  : 				else
; 458  : 				{
; 459  : 					//_hx_printf("%s:send %d bytes out with multicast.\r\n", __FUNCTION__, ret);
; 460  : 				}
; 461  : 				ret = recvfrom(s, buf, 1500, 0, (struct sockaddr*)&gaddr, &len);

  002f9	8d 55 ec	 lea	 edx, DWORD PTR _len$[ebp]
  002fc	52		 push	 edx
  002fd	8d 45 c0	 lea	 eax, DWORD PTR _gaddr$[ebp]
  00300	50		 push	 eax
  00301	6a 00		 push	 0
  00303	68 dc 05 00 00	 push	 1500			; 000005dcH
  00308	8b 4d f4	 mov	 ecx, DWORD PTR _buf$[ebp]
  0030b	51		 push	 ecx
  0030c	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  0030f	52		 push	 edx
  00310	e8 00 00 00 00	 call	 _recvfrom
  00315	83 c4 18	 add	 esp, 24			; 00000018H
  00318	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 462  : 				if (ret < 0)

  0031b	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0031f	7d 02		 jge	 SHORT $LN17@ylight_sea

; 463  : 				{
; 464  : 					//_hx_printf("%s:failed to receive data from socket[ret=%d].\r\n", __FUNCTION__,
; 465  : 					//	ret);
; 466  : 				}

  00321	eb 19		 jmp	 SHORT $LN18@ylight_sea
$LN17@ylight_sea:

; 467  : 				else
; 468  : 				{
; 469  : 					//_hx_printf("Recived [%d] byte(s) data from[%s:%d].\r\n", ret,
; 470  : 					//	inet_ntoa(gaddr.sin_addr.s_addr),
; 471  : 					//	_hx_htons(gaddr.sin_port));
; 472  : 					buf[ret] = 0; /* Set terminator of the string. */

  00323	8b 45 f4	 mov	 eax, DWORD PTR _buf$[ebp]
  00326	03 45 fc	 add	 eax, DWORD PTR _ret$[ebp]
  00329	c6 00 00	 mov	 BYTE PTR [eax], 0

; 473  : 					ParseResponse(buf, ret);

  0032c	8b 4d fc	 mov	 ecx, DWORD PTR _ret$[ebp]
  0032f	51		 push	 ecx
  00330	8b 55 f4	 mov	 edx, DWORD PTR _buf$[ebp]
  00333	52		 push	 edx
  00334	e8 00 00 00 00	 call	 _ParseResponse
  00339	83 c4 08	 add	 esp, 8
$LN18@ylight_sea:

; 474  : 				}
; 475  : 				break;

  0033c	eb 02		 jmp	 SHORT $LN13@ylight_sea
$LN19@ylight_sea:

; 476  : 			case KERNEL_MESSAGE_TERMINAL:
; 477  : 				goto __TERMINAL;

  0033e	eb 05		 jmp	 SHORT $__TERMINAL$25
$LN13@ylight_sea:

; 478  : 			default:
; 479  : 				break;
; 480  : 			}
; 481  : 		}
; 482  : 	}

  00340	e9 e0 fe ff ff	 jmp	 $LN2@ylight_sea
$__TERMINAL$25:

; 483  : 
; 484  : __TERMINAL:
; 485  : 	{
; 486  : 		if (hTimer)

  00345	83 7d f0 00	 cmp	 DWORD PTR _hTimer$[ebp], 0
  00349	74 0c		 je	 SHORT $LN21@ylight_sea

; 487  : 		{
; 488  : 			CancelTimer(hTimer);

  0034b	8b 45 f0	 mov	 eax, DWORD PTR _hTimer$[ebp]
  0034e	50		 push	 eax
  0034f	e8 00 00 00 00	 call	 _CancelTimer
  00354	83 c4 04	 add	 esp, 4
$LN21@ylight_sea:

; 489  : 		}
; 490  : 		if (s > 0)

  00357	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  0035b	7e 0c		 jle	 SHORT $LN22@ylight_sea

; 491  : 		{
; 492  : 			close(s);

  0035d	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00360	51		 push	 ecx
  00361	e8 00 00 00 00	 call	 _close
  00366	83 c4 04	 add	 esp, 4
$LN22@ylight_sea:

; 493  : 		}
; 494  : 		if (buf)

  00369	83 7d f4 00	 cmp	 DWORD PTR _buf$[ebp], 0
  0036d	74 0c		 je	 SHORT $LN23@ylight_sea

; 495  : 		{
; 496  : 			_hx_free(buf);

  0036f	8b 55 f4	 mov	 edx, DWORD PTR _buf$[ebp]
  00372	52		 push	 edx
  00373	e8 00 00 00 00	 call	 __hx_free
  00378	83 c4 04	 add	 esp, 4
$LN23@ylight_sea:

; 497  : 		}
; 498  : 	}
; 499  : 	return 0;

  0037b	33 c0		 xor	 eax, eax

; 500  : }

  0037d	8b e5		 mov	 esp, ebp
  0037f	5d		 pop	 ebp
  00380	c3		 ret	 0
_ylight_search ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\src\yeelight.c
;	COMDAT _ParseResponse
_TEXT	SEGMENT
_bResult$ = -24						; size = 4
_charbuff$ = -20					; size = 4
_pTmpLight$1 = -16					; size = 4
_line$ = -12						; size = 4
_value$ = -8						; size = 4
_pLight$ = -4						; size = 4
_pRespMsg$ = 8						; size = 4
_msglen$ = 12						; size = 4
_ParseResponse PROC					; COMDAT

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 262  : 	char* charbuff = NULL;

  00006	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _charbuff$[ebp], 0

; 263  : 	struct yeelight_object* pLight = NULL;

  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pLight$[ebp], 0

; 264  : 	BOOL bResult = FALSE;

  00014	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 0

; 265  : 
; 266  : 	charbuff = _hx_malloc(msglen + 1);

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _msglen$[ebp]
  0001e	83 c0 01	 add	 eax, 1
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 __hx_malloc
  00027	83 c4 04	 add	 esp, 4
  0002a	89 45 ec	 mov	 DWORD PTR _charbuff$[ebp], eax

; 267  : 	if (NULL == charbuff)

  0002d	83 7d ec 00	 cmp	 DWORD PTR _charbuff$[ebp], 0
  00031	75 05		 jne	 SHORT $LN6@ParseRespo

; 268  : 	{
; 269  : 		goto __TERMINAL;

  00033	e9 ae 01 00 00	 jmp	 $__TERMINAL$19
$LN6@ParseRespo:

; 270  : 	}
; 271  : 	strcpy(charbuff, pRespMsg);

  00038	8b 4d 08	 mov	 ecx, DWORD PTR _pRespMsg$[ebp]
  0003b	51		 push	 ecx
  0003c	8b 55 ec	 mov	 edx, DWORD PTR _charbuff$[ebp]
  0003f	52		 push	 edx
  00040	e8 00 00 00 00	 call	 _strcpy
  00045	83 c4 08	 add	 esp, 8

; 272  : 	char* line = strtok(charbuff, "\r\n");

  00048	68 00 00 00 00	 push	 OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
  0004d	8b 45 ec	 mov	 eax, DWORD PTR _charbuff$[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 _strtok
  00056	83 c4 08	 add	 esp, 8
  00059	89 45 f4	 mov	 DWORD PTR _line$[ebp], eax

; 273  : 	char* value = NULL;

  0005c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _value$[ebp], 0

; 274  : 	if (line && (0 == strcmp(line, okmsg)))

  00063	83 7d f4 00	 cmp	 DWORD PTR _line$[ebp], 0
  00067	0f 84 ef 00 00
	00		 je	 $LN7@ParseRespo
  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _okmsg
  00073	51		 push	 ecx
  00074	8b 55 f4	 mov	 edx, DWORD PTR _line$[ebp]
  00077	52		 push	 edx
  00078	e8 00 00 00 00	 call	 _strcmp
  0007d	83 c4 08	 add	 esp, 8
  00080	85 c0		 test	 eax, eax
  00082	0f 85 d4 00 00
	00		 jne	 $LN7@ParseRespo

; 275  : 	{
; 276  : 		/*
; 277  : 		* Got a valid response,create a new light object
; 278  : 		* to hold values derived from this response.
; 279  : 		*/
; 280  : 		pLight = (struct yeelight_object*)_hx_malloc(sizeof(struct yeelight_object));

  00088	6a 34		 push	 52			; 00000034H
  0008a	e8 00 00 00 00	 call	 __hx_malloc
  0008f	83 c4 04	 add	 esp, 4
  00092	89 45 fc	 mov	 DWORD PTR _pLight$[ebp], eax

; 281  : 		memset(pLight, 0, sizeof(struct yeelight_object));

  00095	6a 34		 push	 52			; 00000034H
  00097	6a 00		 push	 0
  00099	8b 45 fc	 mov	 eax, DWORD PTR _pLight$[ebp]
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 _memset
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 282  : 		pLight->sock = -1; /* No socket opened yet. */

  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _pLight$[ebp]
  000a8	c7 41 2c ff ff
	ff ff		 mov	 DWORD PTR [ecx+44], -1

; 283  : 		if (NULL == pLight)

  000af	83 7d fc 00	 cmp	 DWORD PTR _pLight$[ebp], 0
  000b3	75 05		 jne	 SHORT $LN2@ParseRespo

; 284  : 		{
; 285  : 			goto __TERMINAL;

  000b5	e9 2c 01 00 00	 jmp	 $__TERMINAL$19
$LN2@ParseRespo:

; 286  : 		}
; 287  : 		while (line)

  000ba	83 7d f4 00	 cmp	 DWORD PTR _line$[ebp], 0
  000be	0f 84 98 00 00
	00		 je	 $LN7@ParseRespo

; 288  : 		{
; 289  : 			value = getvalue(line, "Location");

  000c4	68 00 00 00 00	 push	 OFFSET ??_C@_08KDOEBHGA@Location?$AA@
  000c9	8b 55 f4	 mov	 edx, DWORD PTR _line$[ebp]
  000cc	52		 push	 edx
  000cd	e8 00 00 00 00	 call	 _getvalue
  000d2	83 c4 08	 add	 esp, 8
  000d5	89 45 f8	 mov	 DWORD PTR _value$[ebp], eax

; 290  : 			if (value)

  000d8	83 7d f8 00	 cmp	 DWORD PTR _value$[ebp], 0
  000dc	74 13		 je	 SHORT $LN9@ParseRespo

; 291  : 			{
; 292  : 				/* Obtain the light's IP address and port,fill into light object. */
; 293  : 				GetSocketFromLocation(value, &pLight->socket);

  000de	8b 45 fc	 mov	 eax, DWORD PTR _pLight$[ebp]
  000e1	83 c0 18	 add	 eax, 24			; 00000018H
  000e4	50		 push	 eax
  000e5	8b 4d f8	 mov	 ecx, DWORD PTR _value$[ebp]
  000e8	51		 push	 ecx
  000e9	e8 00 00 00 00	 call	 _GetSocketFromLocation
  000ee	83 c4 08	 add	 esp, 8
$LN9@ParseRespo:

; 294  : 			}
; 295  : 			value = getvalue(line, "id");

  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_02EGCJHIOB@id?$AA@
  000f6	8b 55 f4	 mov	 edx, DWORD PTR _line$[ebp]
  000f9	52		 push	 edx
  000fa	e8 00 00 00 00	 call	 _getvalue
  000ff	83 c4 08	 add	 esp, 8
  00102	89 45 f8	 mov	 DWORD PTR _value$[ebp], eax

; 296  : 			if (value)

  00105	83 7d f8 00	 cmp	 DWORD PTR _value$[ebp], 0
  00109	74 26		 je	 SHORT $LN10@ParseRespo

; 297  : 			{
; 298  : 				if (strlen(value) > LIGHT_ID_LENGTH) /* Invalid ID value. */

  0010b	8b 45 f8	 mov	 eax, DWORD PTR _value$[ebp]
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 _strlen
  00114	83 c4 04	 add	 esp, 4
  00117	83 f8 14	 cmp	 eax, 20			; 00000014H
  0011a	7e 05		 jle	 SHORT $LN11@ParseRespo

; 299  : 				{
; 300  : 					goto __TERMINAL;

  0011c	e9 c5 00 00 00	 jmp	 $__TERMINAL$19
$LN11@ParseRespo:

; 301  : 				}
; 302  : 				/* Save ID to light object. */
; 303  : 				strcpy(pLight->id, value);

  00121	8b 4d f8	 mov	 ecx, DWORD PTR _value$[ebp]
  00124	51		 push	 ecx
  00125	8b 55 fc	 mov	 edx, DWORD PTR _pLight$[ebp]
  00128	52		 push	 edx
  00129	e8 00 00 00 00	 call	 _strcpy
  0012e	83 c4 08	 add	 esp, 8
$LN10@ParseRespo:

; 304  : 			}
; 305  : 			value = getvalue(line, "name");

  00131	68 00 00 00 00	 push	 OFFSET ??_C@_04MEMAJGDJ@name?$AA@
  00136	8b 45 f4	 mov	 eax, DWORD PTR _line$[ebp]
  00139	50		 push	 eax
  0013a	e8 00 00 00 00	 call	 _getvalue
  0013f	83 c4 08	 add	 esp, 8
  00142	89 45 f8	 mov	 DWORD PTR _value$[ebp], eax

; 306  : 			if (value)
; 307  : 			{
; 308  : 				/* Save bulb name. */
; 309  : 			}
; 310  : 			line = strtok(NULL, "\r\n");

  00145	68 00 00 00 00	 push	 OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
  0014a	6a 00		 push	 0
  0014c	e8 00 00 00 00	 call	 _strtok
  00151	83 c4 08	 add	 esp, 8
  00154	89 45 f4	 mov	 DWORD PTR _line$[ebp], eax

; 311  : 		}

  00157	e9 5e ff ff ff	 jmp	 $LN2@ParseRespo
$LN7@ParseRespo:

; 312  : 	}
; 313  : 	/* Check if the response is from a known light. */
; 314  : 	if (pLight)

  0015c	83 7d fc 00	 cmp	 DWORD PTR _pLight$[ebp], 0
  00160	0f 84 80 00 00
	00		 je	 $__TERMINAL$19

; 315  : 	{
; 316  : 		struct yeelight_object* pTmpLight = pLightObject;

  00166	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pLightObject
  0016c	89 4d f0	 mov	 DWORD PTR _pTmpLight$1[ebp], ecx
$LN4@ParseRespo:

; 317  : 		while (pTmpLight)

  0016f	83 7d f0 00	 cmp	 DWORD PTR _pTmpLight$1[ebp], 0
  00173	74 3f		 je	 SHORT $LN5@ParseRespo

; 318  : 		{
; 319  : 			/*
; 320  : 			* The light object is already in list of their
; 321  : 			* IDs are same.
; 322  : 			*/
; 323  : 			if (0 == strcmp(pLight->id, pTmpLight->id))

  00175	8b 55 f0	 mov	 edx, DWORD PTR _pTmpLight$1[ebp]
  00178	52		 push	 edx
  00179	8b 45 fc	 mov	 eax, DWORD PTR _pLight$[ebp]
  0017c	50		 push	 eax
  0017d	e8 00 00 00 00	 call	 _strcmp
  00182	83 c4 08	 add	 esp, 8
  00185	85 c0		 test	 eax, eax
  00187	75 20		 jne	 SHORT $LN14@ParseRespo

; 324  : 			{
; 325  : 				/*
; 326  : 				* Replace old light object's attributes by the
; 327  : 				* newly one.
; 328  : 				* May lead issue in multi-thread environment here,
; 329  : 				* since the global light list is reachable from
; 330  : 				* all threads,and no mutex is applied here for easy.
; 331  : 				*/
; 332  : 				pLight->pNext = pTmpLight->pNext;

  00189	8b 4d fc	 mov	 ecx, DWORD PTR _pLight$[ebp]
  0018c	8b 55 f0	 mov	 edx, DWORD PTR _pTmpLight$1[ebp]
  0018f	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00192	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 333  : 				memcpy(pTmpLight, pLight, sizeof(*pLight));

  00195	6a 34		 push	 52			; 00000034H
  00197	8b 4d fc	 mov	 ecx, DWORD PTR _pLight$[ebp]
  0019a	51		 push	 ecx
  0019b	8b 55 f0	 mov	 edx, DWORD PTR _pTmpLight$1[ebp]
  0019e	52		 push	 edx
  0019f	e8 00 00 00 00	 call	 _memcpy
  001a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 334  : 				break;

  001a7	eb 0b		 jmp	 SHORT $LN5@ParseRespo
$LN14@ParseRespo:

; 335  : 			}
; 336  : 			pTmpLight = pTmpLight->pNext;

  001a9	8b 45 f0	 mov	 eax, DWORD PTR _pTmpLight$1[ebp]
  001ac	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  001af	89 4d f0	 mov	 DWORD PTR _pTmpLight$1[ebp], ecx

; 337  : 		}

  001b2	eb bb		 jmp	 SHORT $LN4@ParseRespo
$LN5@ParseRespo:

; 338  : 		if (NULL == pTmpLight) /* A new light. */

  001b4	83 7d f0 00	 cmp	 DWORD PTR _pTmpLight$1[ebp], 0
  001b8	75 2c		 jne	 SHORT $__TERMINAL$19

; 339  : 		{
; 340  : 			/* Just link the new found light into global list. */
; 341  : 			pLight->pNext = pLightObject;

  001ba	8b 55 fc	 mov	 edx, DWORD PTR _pLight$[ebp]
  001bd	a1 00 00 00 00	 mov	 eax, DWORD PTR _pLightObject
  001c2	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 342  : 			pLightObject = pLight;

  001c5	8b 4d fc	 mov	 ecx, DWORD PTR _pLight$[ebp]
  001c8	89 0d 00 00 00
	00		 mov	 DWORD PTR _pLightObject, ecx

; 343  : 			_hx_printf("\r\nA new light found[id = %s].\r\n",

  001ce	8b 55 fc	 mov	 edx, DWORD PTR _pLight$[ebp]
  001d1	52		 push	 edx
  001d2	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@JMCBIEPM@?$AN?6A?5new?5light?5found?$FLid?5?$DN?5?$CFs?$FN?4?$AN?6?$AA@
  001d7	e8 00 00 00 00	 call	 __hx_printf
  001dc	83 c4 08	 add	 esp, 8

; 344  : 				pLight->id);
; 345  : 			bResult = TRUE;

  001df	c7 45 e8 ff ff
	ff ff		 mov	 DWORD PTR _bResult$[ebp], -1
$__TERMINAL$19:

; 346  : 		}
; 347  : 	}
; 348  : __TERMINAL:
; 349  : 	if (!bResult)

  001e6	83 7d e8 00	 cmp	 DWORD PTR _bResult$[ebp], 0
  001ea	75 12		 jne	 SHORT $LN16@ParseRespo

; 350  : 	{
; 351  : 		if (pLight)

  001ec	83 7d fc 00	 cmp	 DWORD PTR _pLight$[ebp], 0
  001f0	74 0c		 je	 SHORT $LN16@ParseRespo

; 352  : 		{
; 353  : 			_hx_free(pLight);

  001f2	8b 45 fc	 mov	 eax, DWORD PTR _pLight$[ebp]
  001f5	50		 push	 eax
  001f6	e8 00 00 00 00	 call	 __hx_free
  001fb	83 c4 04	 add	 esp, 4
$LN16@ParseRespo:

; 354  : 		}
; 355  : 	}
; 356  : 	_hx_free(charbuff);

  001fe	8b 4d ec	 mov	 ecx, DWORD PTR _charbuff$[ebp]
  00201	51		 push	 ecx
  00202	e8 00 00 00 00	 call	 __hx_free
  00207	83 c4 04	 add	 esp, 4

; 357  : 	return bResult;

  0020a	8b 45 e8	 mov	 eax, DWORD PTR _bResult$[ebp]

; 358  : }

  0020d	8b e5		 mov	 esp, ebp
  0020f	5d		 pop	 ebp
  00210	c3		 ret	 0
_ParseResponse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\src\yeelight.c
;	COMDAT _ToggleYlight
_TEXT	SEGMENT
_sa$ = -32						; size = 16
_bResult$ = -16						; size = 4
_sock$ = -12						; size = 4
_cmd$ = -8						; size = 4
_ret$ = -4						; size = 4
_light$ = 8						; size = 4
_ToggleYlight PROC					; COMDAT

; 177  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 178  : 	int sock = -1;

  00006	c7 45 f4 ff ff
	ff ff		 mov	 DWORD PTR _sock$[ebp], -1

; 179  : 	BOOL bResult = FALSE;

  0000d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 0

; 180  : 	char* cmd = NULL;

  00014	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _cmd$[ebp], 0

; 181  : 	int ret = -1;

  0001b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -1

; 182  : 	struct sockaddr_in sa;
; 183  : 
; 184  : 	BUG_ON(NULL == light);

  00022	83 7d 08 00	 cmp	 DWORD PTR _light$[ebp], 0
  00026	75 12		 jne	 SHORT $LN2@ToggleYlig
  00028	68 b8 00 00 00	 push	 184			; 000000b8H
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@DLILGIOL@c?3?2hellox?2personal?2hellox_os?2app@
  00032	e8 00 00 00 00	 call	 ___BUG
  00037	83 c4 08	 add	 esp, 8
$LN2@ToggleYlig:
  0003a	33 c0		 xor	 eax, eax
  0003c	74 02		 je	 SHORT $LN3@ToggleYlig
  0003e	eb fa		 jmp	 SHORT $LN2@ToggleYlig
$LN3@ToggleYlig:

; 185  : 	if (light->sock < 0)

  00040	8b 4d 08	 mov	 ecx, DWORD PTR _light$[ebp]
  00043	83 79 2c 00	 cmp	 DWORD PTR [ecx+44], 0
  00047	0f 8d b6 00 00
	00		 jge	 $LN5@ToggleYlig

; 186  : 	{
; 187  : 		/* No socket created yet,create a new one. */
; 188  : 		sock = socket(AF_INET, SOCK_STREAM, 0);

  0004d	6a 00		 push	 0
  0004f	6a 01		 push	 1
  00051	6a 02		 push	 2
  00053	e8 00 00 00 00	 call	 _socket
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005b	89 45 f4	 mov	 DWORD PTR _sock$[ebp], eax

; 189  : 		if (sock < 0)

  0005e	83 7d f4 00	 cmp	 DWORD PTR _sock$[ebp], 0
  00062	7d 1c		 jge	 SHORT $LN6@ToggleYlig

; 190  : 		{
; 191  : 			__LOG("Can not create socket object.\r\n");

  00064	6a 00		 push	 0
  00066	e8 00 00 00 00	 call	 _LogHeader
  0006b	83 c4 04	 add	 esp, 4
  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@KLBIHOJL@Can?5not?5create?5socket?5object?4?$AN?6?$AA@
  00073	e8 00 00 00 00	 call	 __hx_printf
  00078	83 c4 04	 add	 esp, 4

; 192  : 			goto __TERMINAL;

  0007b	e9 6d 01 00 00	 jmp	 $__TERMINAL$18
$LN6@ToggleYlig:

; 193  : 		}
; 194  : 		/* Save to use next time,the connection is keeping open. */
; 195  : 		light->sock = sock;

  00080	8b 55 08	 mov	 edx, DWORD PTR _light$[ebp]
  00083	8b 45 f4	 mov	 eax, DWORD PTR _sock$[ebp]
  00086	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 196  : 
; 197  : 		/* Connect to yeelight object. */
; 198  : 		sa.sin_family = AF_INET;

  00089	c6 45 e1 02	 mov	 BYTE PTR _sa$[ebp+1], 2

; 199  : 		sa.sin_addr = light->socket.sin_addr;

  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _light$[ebp]
  00090	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00093	89 55 e4	 mov	 DWORD PTR _sa$[ebp+4], edx

; 200  : 		sa.sin_port = light->socket.sin_port;

  00096	8b 45 08	 mov	 eax, DWORD PTR _light$[ebp]
  00099	66 8b 48 1a	 mov	 cx, WORD PTR [eax+26]
  0009d	66 89 4d e2	 mov	 WORD PTR _sa$[ebp+2], cx

; 201  : 		memset(sa.sin_zero, 0, sizeof(sa.sin_zero));

  000a1	6a 08		 push	 8
  000a3	6a 00		 push	 0
  000a5	8d 55 e8	 lea	 edx, DWORD PTR _sa$[ebp+8]
  000a8	52		 push	 edx
  000a9	e8 00 00 00 00	 call	 _memset
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH

; 202  : 		ret = connect(sock, (struct sockaddr*)&sa, sizeof(sa));

  000b1	6a 10		 push	 16			; 00000010H
  000b3	8d 45 e0	 lea	 eax, DWORD PTR _sa$[ebp]
  000b6	50		 push	 eax
  000b7	8b 4d f4	 mov	 ecx, DWORD PTR _sock$[ebp]
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 _connect
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c3	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 203  : 		if (ret < 0)

  000c6	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  000ca	7d 20		 jge	 SHORT $LN7@ToggleYlig

; 204  : 		{
; 205  : 			__LOG("Can not connect to light object[ret = %d].\r\n", ret);

  000cc	6a 00		 push	 0
  000ce	e8 00 00 00 00	 call	 _LogHeader
  000d3	83 c4 04	 add	 esp, 4
  000d6	8b 55 fc	 mov	 edx, DWORD PTR _ret$[ebp]
  000d9	52		 push	 edx
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@OAKNKFDD@Can?5not?5connect?5to?5light?5object?$FL@
  000df	e8 00 00 00 00	 call	 __hx_printf
  000e4	83 c4 08	 add	 esp, 8

; 206  : 			goto __TERMINAL;

  000e7	e9 01 01 00 00	 jmp	 $__TERMINAL$18
$LN7@ToggleYlig:

; 207  : 		}
; 208  : 		__LOG("Connect to light object OK.\r\n");

  000ec	6a 00		 push	 0
  000ee	e8 00 00 00 00	 call	 _LogHeader
  000f3	83 c4 04	 add	 esp, 4
  000f6	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@NPJCALFH@Connect?5to?5light?5object?5OK?4?$AN?6?$AA@
  000fb	e8 00 00 00 00	 call	 __hx_printf
  00100	83 c4 04	 add	 esp, 4
$LN5@ToggleYlig:

; 209  : 	}
; 210  : 	cmd = (char*)_hx_malloc(1500);

  00103	68 dc 05 00 00	 push	 1500			; 000005dcH
  00108	e8 00 00 00 00	 call	 __hx_malloc
  0010d	83 c4 04	 add	 esp, 4
  00110	89 45 f8	 mov	 DWORD PTR _cmd$[ebp], eax

; 211  : 	if (NULL == cmd)

  00113	83 7d f8 00	 cmp	 DWORD PTR _cmd$[ebp], 0
  00117	75 05		 jne	 SHORT $LN8@ToggleYlig

; 212  : 	{
; 213  : 		goto __TERMINAL;

  00119	e9 cf 00 00 00	 jmp	 $__TERMINAL$18
$LN8@ToggleYlig:

; 214  : 	}
; 215  : 	/* Construct toggle command. */
; 216  : 	if (!ConstructToggleCmd(light, cmd, 1500))

  0011e	68 dc 05 00 00	 push	 1500			; 000005dcH
  00123	8b 45 f8	 mov	 eax, DWORD PTR _cmd$[ebp]
  00126	50		 push	 eax
  00127	8b 4d 08	 mov	 ecx, DWORD PTR _light$[ebp]
  0012a	51		 push	 ecx
  0012b	e8 00 00 00 00	 call	 _ConstructToggleCmd
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH
  00133	85 c0		 test	 eax, eax
  00135	75 05		 jne	 SHORT $LN9@ToggleYlig

; 217  : 	{
; 218  : 		goto __TERMINAL;

  00137	e9 b1 00 00 00	 jmp	 $__TERMINAL$18
$LN9@ToggleYlig:

; 219  : 	}
; 220  : 	ret = send(sock,cmd,strlen(cmd),0);

  0013c	6a 00		 push	 0
  0013e	8b 55 f8	 mov	 edx, DWORD PTR _cmd$[ebp]
  00141	52		 push	 edx
  00142	e8 00 00 00 00	 call	 _strlen
  00147	83 c4 04	 add	 esp, 4
  0014a	50		 push	 eax
  0014b	8b 45 f8	 mov	 eax, DWORD PTR _cmd$[ebp]
  0014e	50		 push	 eax
  0014f	8b 4d f4	 mov	 ecx, DWORD PTR _sock$[ebp]
  00152	51		 push	 ecx
  00153	e8 00 00 00 00	 call	 _send
  00158	83 c4 10	 add	 esp, 16			; 00000010H
  0015b	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 221  : 	if(ret < 0)

  0015e	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00162	7d 0f		 jge	 SHORT $LN10@ToggleYlig

; 222  : 	{
; 223  : 		_hx_printf("Failed to send toggle command.\r\n");

  00164	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@DDIPKHPP@Failed?5to?5send?5toggle?5command?4?$AN?6@
  00169	e8 00 00 00 00	 call	 __hx_printf
  0016e	83 c4 04	 add	 esp, 4

; 224  : 		goto __TERMINAL;

  00171	eb 7a		 jmp	 SHORT $__TERMINAL$18
$LN10@ToggleYlig:

; 225  : 	}
; 226  : 	ret = recv(sock, cmd, 1500, 0);

  00173	6a 00		 push	 0
  00175	68 dc 05 00 00	 push	 1500			; 000005dcH
  0017a	8b 55 f8	 mov	 edx, DWORD PTR _cmd$[ebp]
  0017d	52		 push	 edx
  0017e	8b 45 f4	 mov	 eax, DWORD PTR _sock$[ebp]
  00181	50		 push	 eax
  00182	e8 00 00 00 00	 call	 _recv
  00187	83 c4 10	 add	 esp, 16			; 00000010H
  0018a	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 227  : 	if (ret < 0)

  0018d	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00191	7d 1d		 jge	 SHORT $LN11@ToggleYlig

; 228  : 	{
; 229  : 		__LOG("Failed to recv resp[ret = %d].\r\n", ret);

  00193	6a 00		 push	 0
  00195	e8 00 00 00 00	 call	 _LogHeader
  0019a	83 c4 04	 add	 esp, 4
  0019d	8b 4d fc	 mov	 ecx, DWORD PTR _ret$[ebp]
  001a0	51		 push	 ecx
  001a1	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MBPHKCID@Failed?5to?5recv?5resp?$FLret?5?$DN?5?$CFd?$FN?4?$AN?6@
  001a6	e8 00 00 00 00	 call	 __hx_printf
  001ab	83 c4 08	 add	 esp, 8

; 230  : 		goto __TERMINAL;

  001ae	eb 3d		 jmp	 SHORT $__TERMINAL$18
$LN11@ToggleYlig:

; 231  : 	}
; 232  : 	/* Show out the status info received. */
; 233  : 	if (ret > 128)

  001b0	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _ret$[ebp], 128 ; 00000080H
  001b7	7e 13		 jle	 SHORT $LN12@ToggleYlig

; 234  : 	{
; 235  : 		_hx_printf("Received status update message[size = %d].\r\n", ret);

  001b9	8b 55 fc	 mov	 edx, DWORD PTR _ret$[ebp]
  001bc	52		 push	 edx
  001bd	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@PHCHOKIN@Received?5status?5update?5message?$FLs@
  001c2	e8 00 00 00 00	 call	 __hx_printf
  001c7	83 c4 08	 add	 esp, 8

; 236  : 	}

  001ca	eb 1a		 jmp	 SHORT $LN13@ToggleYlig
$LN12@ToggleYlig:

; 237  : 	else
; 238  : 	{
; 239  : 		cmd[ret] = 0;

  001cc	8b 45 f8	 mov	 eax, DWORD PTR _cmd$[ebp]
  001cf	03 45 fc	 add	 eax, DWORD PTR _ret$[ebp]
  001d2	c6 00 00	 mov	 BYTE PTR [eax], 0

; 240  : 		_hx_printf("Status update:%s\r\n", cmd);

  001d5	8b 4d f8	 mov	 ecx, DWORD PTR _cmd$[ebp]
  001d8	51		 push	 ecx
  001d9	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@PCKCGHAM@Status?5update?3?$CFs?$AN?6?$AA@
  001de	e8 00 00 00 00	 call	 __hx_printf
  001e3	83 c4 08	 add	 esp, 8
$LN13@ToggleYlig:

; 241  : 	}
; 242  : 
; 243  : 	bResult = TRUE;

  001e6	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _bResult$[ebp], -1
$__TERMINAL$18:

; 244  : __TERMINAL:
; 245  : 	if (!bResult)

  001ed	83 7d f0 00	 cmp	 DWORD PTR _bResult$[ebp], 0
  001f1	75 22		 jne	 SHORT $LN14@ToggleYlig

; 246  : 	{
; 247  : 		if (light->sock >= 0)

  001f3	8b 55 08	 mov	 edx, DWORD PTR _light$[ebp]
  001f6	83 7a 2c 00	 cmp	 DWORD PTR [edx+44], 0
  001fa	7c 19		 jl	 SHORT $LN14@ToggleYlig

; 248  : 		{
; 249  : 			close(light->sock);

  001fc	8b 45 08	 mov	 eax, DWORD PTR _light$[ebp]
  001ff	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00202	51		 push	 ecx
  00203	e8 00 00 00 00	 call	 _close
  00208	83 c4 04	 add	 esp, 4

; 250  : 			light->sock = -1;

  0020b	8b 55 08	 mov	 edx, DWORD PTR _light$[ebp]
  0020e	c7 42 2c ff ff
	ff ff		 mov	 DWORD PTR [edx+44], -1
$LN14@ToggleYlig:

; 251  : 		}
; 252  : 	}
; 253  : 	if (cmd)

  00215	83 7d f8 00	 cmp	 DWORD PTR _cmd$[ebp], 0
  00219	74 0c		 je	 SHORT $LN16@ToggleYlig

; 254  : 	{
; 255  : 		_hx_free(cmd);

  0021b	8b 45 f8	 mov	 eax, DWORD PTR _cmd$[ebp]
  0021e	50		 push	 eax
  0021f	e8 00 00 00 00	 call	 __hx_free
  00224	83 c4 04	 add	 esp, 4
$LN16@ToggleYlig:

; 256  : 	}
; 257  : 	return bResult;

  00227	8b 45 f0	 mov	 eax, DWORD PTR _bResult$[ebp]

; 258  : }

  0022a	8b e5		 mov	 esp, ebp
  0022c	5d		 pop	 ebp
  0022d	c3		 ret	 0
_ToggleYlight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\src\yeelight.c
;	COMDAT _ConstructToggleCmd
_TEXT	SEGMENT
_cmd_len$ = -4						; size = 4
_pLight$ = 8						; size = 4
_pCmdBuff$ = 12						; size = 4
_length$ = 16						; size = 4
_ConstructToggleCmd PROC				; COMDAT

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 161  : 	int cmd_len = 0;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _cmd_len$[ebp], 0

; 162  : 	BUG_ON(NULL == pCmdBuff);

  0000b	83 7d 0c 00	 cmp	 DWORD PTR _pCmdBuff$[ebp], 0
  0000f	75 12		 jne	 SHORT $LN2@ConstructT
  00011	68 a2 00 00 00	 push	 162			; 000000a2H
  00016	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@DLILGIOL@c?3?2hellox?2personal?2hellox_os?2app@
  0001b	e8 00 00 00 00	 call	 ___BUG
  00020	83 c4 08	 add	 esp, 8
$LN2@ConstructT:
  00023	33 c0		 xor	 eax, eax
  00025	74 02		 je	 SHORT $LN3@ConstructT
  00027	eb fa		 jmp	 SHORT $LN2@ConstructT
$LN3@ConstructT:

; 163  : 	BUG_ON(0 == length);

  00029	83 7d 10 00	 cmp	 DWORD PTR _length$[ebp], 0
  0002d	75 12		 jne	 SHORT $LN4@ConstructT
  0002f	68 a3 00 00 00	 push	 163			; 000000a3H
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@DLILGIOL@c?3?2hellox?2personal?2hellox_os?2app@
  00039	e8 00 00 00 00	 call	 ___BUG
  0003e	83 c4 08	 add	 esp, 8
$LN4@ConstructT:
  00041	33 c9		 xor	 ecx, ecx
  00043	74 02		 je	 SHORT $LN5@ConstructT
  00045	eb fa		 jmp	 SHORT $LN4@ConstructT
$LN5@ConstructT:

; 164  : 	BUG_ON(NULL == pLight);

  00047	83 7d 08 00	 cmp	 DWORD PTR _pLight$[ebp], 0
  0004b	75 12		 jne	 SHORT $LN6@ConstructT
  0004d	68 a4 00 00 00	 push	 164			; 000000a4H
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@DLILGIOL@c?3?2hellox?2personal?2hellox_os?2app@
  00057	e8 00 00 00 00	 call	 ___BUG
  0005c	83 c4 08	 add	 esp, 8
$LN6@ConstructT:
  0005f	33 d2		 xor	 edx, edx
  00061	74 02		 je	 SHORT $LN7@ConstructT
  00063	eb fa		 jmp	 SHORT $LN6@ConstructT
$LN7@ConstructT:

; 165  : 	cmd_len = strlen(YLIGHT_TOGGLE_CMD + strlen(pLight->id));

  00065	8b 45 08	 mov	 eax, DWORD PTR _pLight$[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 _strlen
  0006e	83 c4 04	 add	 esp, 4
  00071	05 00 00 00 00	 add	 eax, OFFSET ??_C@_0CM@NIFJBDJE@?$HL?$CCid?$CC?3?$CC?$CFs?$CC?0?$CCmethod?$CC?3?$CCtoggle?$CC?0?$CCpa@
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 _strlen
  0007c	83 c4 04	 add	 esp, 4
  0007f	89 45 fc	 mov	 DWORD PTR _cmd_len$[ebp], eax

; 166  : 	if (cmd_len > length) /* Command buffer too short. */

  00082	8b 4d fc	 mov	 ecx, DWORD PTR _cmd_len$[ebp]
  00085	3b 4d 10	 cmp	 ecx, DWORD PTR _length$[ebp]
  00088	7e 04		 jle	 SHORT $LN11@ConstructT

; 167  : 	{
; 168  : 		return FALSE;

  0008a	33 c0		 xor	 eax, eax
  0008c	eb 24		 jmp	 SHORT $LN1@ConstructT
$LN11@ConstructT:

; 169  : 	}
; 170  : 	_hx_sprintf(pCmdBuff, YLIGHT_TOGGLE_CMD, pLight->id);

  0008e	8b 55 08	 mov	 edx, DWORD PTR _pLight$[ebp]
  00091	52		 push	 edx
  00092	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@NIFJBDJE@?$HL?$CCid?$CC?3?$CC?$CFs?$CC?0?$CCmethod?$CC?3?$CCtoggle?$CC?0?$CCpa@
  00097	8b 45 0c	 mov	 eax, DWORD PTR _pCmdBuff$[ebp]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 __hx_sprintf
  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 171  : 	_hx_printf(pCmdBuff); //Debugging.

  000a3	8b 4d 0c	 mov	 ecx, DWORD PTR _pCmdBuff$[ebp]
  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 __hx_printf
  000ac	83 c4 04	 add	 esp, 4

; 172  : 	return TRUE;

  000af	83 c8 ff	 or	 eax, -1
$LN1@ConstructT:

; 173  : }

  000b2	8b e5		 mov	 esp, ebp
  000b4	5d		 pop	 ebp
  000b5	c3		 ret	 0
_ConstructToggleCmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\src\yeelight.c
;	COMDAT _ShowLight
_TEXT	SEGMENT
_pLight$ = 8						; size = 4
_ShowLight PROC						; COMDAT

; 147  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$LN2@ShowLight:

; 148  : 	while (pLight)

  00003	83 7d 08 00	 cmp	 DWORD PTR _pLight$[ebp], 0
  00007	74 67		 je	 SHORT $LN1@ShowLight

; 149  : 	{
; 150  : 		_hx_printf("--------------------\r\n");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@HGHOBMCE@?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?9?$AN?6?$AA@
  0000e	e8 00 00 00 00	 call	 __hx_printf
  00013	83 c4 04	 add	 esp, 4

; 151  : 		_hx_printf("id: %s\r\n", pLight->id);

  00016	8b 45 08	 mov	 eax, DWORD PTR _pLight$[ebp]
  00019	50		 push	 eax
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_08DELEFJBK@id?3?5?$CFs?$AN?6?$AA@
  0001f	e8 00 00 00 00	 call	 __hx_printf
  00024	83 c4 08	 add	 esp, 8

; 152  : 		_hx_printf("ip: %s\r\n", inet_ntoa(pLight->socket.sin_addr));

  00027	8b 4d 08	 mov	 ecx, DWORD PTR _pLight$[ebp]
  0002a	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 _ipaddr_ntoa
  00033	83 c4 04	 add	 esp, 4
  00036	50		 push	 eax
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_08MMEFGGML@ip?3?5?$CFs?$AN?6?$AA@
  0003c	e8 00 00 00 00	 call	 __hx_printf
  00041	83 c4 08	 add	 esp, 8

; 153  : 		_hx_printf("port: %d\r\n", _hx_ntohs(pLight->socket.sin_port));

  00044	8b 55 08	 mov	 edx, DWORD PTR _pLight$[ebp]
  00047	0f b7 42 1a	 movzx	 eax, WORD PTR [edx+26]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 __hx_ntohs
  00051	83 c4 04	 add	 esp, 4
  00054	0f b7 c8	 movzx	 ecx, ax
  00057	51		 push	 ecx
  00058	68 00 00 00 00	 push	 OFFSET ??_C@_0L@PIBEHDPH@port?3?5?$CFd?$AN?6?$AA@
  0005d	e8 00 00 00 00	 call	 __hx_printf
  00062	83 c4 08	 add	 esp, 8

; 154  : 		pLight = pLight->pNext;

  00065	8b 55 08	 mov	 edx, DWORD PTR _pLight$[ebp]
  00068	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0006b	89 45 08	 mov	 DWORD PTR _pLight$[ebp], eax

; 155  : 	}

  0006e	eb 93		 jmp	 SHORT $LN2@ShowLight
$LN1@ShowLight:

; 156  : }

  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
_ShowLight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\src\yeelight.c
;	COMDAT _GetSocketFromLocation
_TEXT	SEGMENT
_addr$ = -48						; size = 32
_bResult$ = -16						; size = 4
_sock_str$ = -12					; size = 4
_len$ = -8						; size = 4
_port$ = -4						; size = 2
_location$ = 8						; size = 4
_pSock$ = 12						; size = 4
_GetSocketFromLocation PROC				; COMDAT

; 78   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H

; 79   : 	char* sock_str = NULL;

  00006	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _sock_str$[ebp], 0

; 80   : 	BOOL bResult = FALSE;

  0000d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 0

; 81   : 	char addr[32];
; 82   : 	int len = 0;

  00014	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 83   : 	unsigned short port = 0;

  0001b	33 c0		 xor	 eax, eax
  0001d	66 89 45 fc	 mov	 WORD PTR _port$[ebp], ax

; 84   : 
; 85   : 	BUG_ON(NULL == location);

  00021	83 7d 08 00	 cmp	 DWORD PTR _location$[ebp], 0
  00025	75 0f		 jne	 SHORT $LN2@GetSocketF
  00027	6a 55		 push	 85			; 00000055H
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@DLILGIOL@c?3?2hellox?2personal?2hellox_os?2app@
  0002e	e8 00 00 00 00	 call	 ___BUG
  00033	83 c4 08	 add	 esp, 8
$LN2@GetSocketF:
  00036	33 c9		 xor	 ecx, ecx
  00038	74 02		 je	 SHORT $LN3@GetSocketF
  0003a	eb fa		 jmp	 SHORT $LN2@GetSocketF
$LN3@GetSocketF:

; 86   : 	BUG_ON(NULL == pSock);

  0003c	83 7d 0c 00	 cmp	 DWORD PTR _pSock$[ebp], 0
  00040	75 0f		 jne	 SHORT $LN4@GetSocketF
  00042	6a 56		 push	 86			; 00000056H
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@DLILGIOL@c?3?2hellox?2personal?2hellox_os?2app@
  00049	e8 00 00 00 00	 call	 ___BUG
  0004e	83 c4 08	 add	 esp, 8
$LN4@GetSocketF:
  00051	33 d2		 xor	 edx, edx
  00053	74 02		 je	 SHORT $LN5@GetSocketF
  00055	eb fa		 jmp	 SHORT $LN4@GetSocketF
$LN5@GetSocketF:

; 87   : 
; 88   : 	/* Get socket string(IP and port) from string. */
; 89   : 	sock_str = getvalue(location, "yeelight");

  00057	68 00 00 00 00	 push	 OFFSET ??_C@_08EEABGAIP@yeelight?$AA@
  0005c	8b 45 08	 mov	 eax, DWORD PTR _location$[ebp]
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 _getvalue
  00065	83 c4 08	 add	 esp, 8
  00068	89 45 f4	 mov	 DWORD PTR _sock_str$[ebp], eax

; 90   : 	if (NULL == sock_str)

  0006b	83 7d f4 00	 cmp	 DWORD PTR _sock_str$[ebp], 0
  0006f	75 05		 jne	 SHORT $LN6@GetSocketF

; 91   : 	{
; 92   : 		goto __TERMINAL;

  00071	e9 4f 01 00 00	 jmp	 $__TERMINAL$23
$LN6@GetSocketF:

; 93   : 	}
; 94   : 	/* skip all slash line. */
; 95   : 	while (*sock_str == '/')

  00076	8b 4d f4	 mov	 ecx, DWORD PTR _sock_str$[ebp]
  00079	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0007c	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  0007f	75 0b		 jne	 SHORT $LN7@GetSocketF

; 96   : 	{
; 97   : 		sock_str++;

  00081	8b 45 f4	 mov	 eax, DWORD PTR _sock_str$[ebp]
  00084	83 c0 01	 add	 eax, 1
  00087	89 45 f4	 mov	 DWORD PTR _sock_str$[ebp], eax

; 98   : 	}

  0008a	eb ea		 jmp	 SHORT $LN6@GetSocketF
$LN7@GetSocketF:

; 99   : 	//_hx_printf("sock_str = %s.\r\n", sock_str);
; 100  : 	len = 0;

  0008c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
$LN8@GetSocketF:

; 101  : 	while (sock_str[len] && (sock_str[len] != ':') && (len < 31))

  00093	8b 4d f4	 mov	 ecx, DWORD PTR _sock_str$[ebp]
  00096	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  00099	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0009c	85 d2		 test	 edx, edx
  0009e	74 2e		 je	 SHORT $LN9@GetSocketF
  000a0	8b 45 f4	 mov	 eax, DWORD PTR _sock_str$[ebp]
  000a3	03 45 f8	 add	 eax, DWORD PTR _len$[ebp]
  000a6	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000a9	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  000ac	74 20		 je	 SHORT $LN9@GetSocketF
  000ae	83 7d f8 1f	 cmp	 DWORD PTR _len$[ebp], 31 ; 0000001fH
  000b2	7d 1a		 jge	 SHORT $LN9@GetSocketF

; 102  : 	{
; 103  : 		addr[len] = sock_str[len];

  000b4	8b 55 f4	 mov	 edx, DWORD PTR _sock_str$[ebp]
  000b7	03 55 f8	 add	 edx, DWORD PTR _len$[ebp]
  000ba	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  000bd	8a 0a		 mov	 cl, BYTE PTR [edx]
  000bf	88 4c 05 d0	 mov	 BYTE PTR _addr$[ebp+eax], cl

; 104  : 		len++;

  000c3	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  000c6	83 c2 01	 add	 edx, 1
  000c9	89 55 f8	 mov	 DWORD PTR _len$[ebp], edx

; 105  : 	}

  000cc	eb c5		 jmp	 SHORT $LN8@GetSocketF
$LN9@GetSocketF:

; 106  : 	if (len >= 31) /* Can not obtain IP address from location string. */

  000ce	83 7d f8 1f	 cmp	 DWORD PTR _len$[ebp], 31 ; 0000001fH
  000d2	7c 05		 jl	 SHORT $LN17@GetSocketF

; 107  : 	{
; 108  : 		goto __TERMINAL;

  000d4	e9 ec 00 00 00	 jmp	 $__TERMINAL$23
$LN17@GetSocketF:

; 109  : 	}
; 110  : 	addr[len] = 0;

  000d9	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  000dc	c6 44 05 d0 00	 mov	 BYTE PTR _addr$[ebp+eax], 0

; 111  : 	sock_str += len;

  000e1	8b 4d f4	 mov	 ecx, DWORD PTR _sock_str$[ebp]
  000e4	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  000e7	89 4d f4	 mov	 DWORD PTR _sock_str$[ebp], ecx

; 112  : 	//_hx_printf("IP addr = %s\r\n", addr);
; 113  : 	pSock->sin_addr.s_addr = inet_addr(addr);

  000ea	8d 55 d0	 lea	 edx, DWORD PTR _addr$[ebp]
  000ed	52		 push	 edx
  000ee	e8 00 00 00 00	 call	 _ipaddr_addr
  000f3	83 c4 04	 add	 esp, 4
  000f6	8b 4d 0c	 mov	 ecx, DWORD PTR _pSock$[ebp]
  000f9	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 114  : 	if (0 == pSock->sin_addr.s_addr)

  000fc	8b 55 0c	 mov	 edx, DWORD PTR _pSock$[ebp]
  000ff	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00103	75 05		 jne	 SHORT $LN10@GetSocketF

; 115  : 	{
; 116  : 		goto __TERMINAL;

  00105	e9 bb 00 00 00	 jmp	 $__TERMINAL$23
$LN10@GetSocketF:

; 117  : 	}
; 118  : 	//_hx_printf("IP addr: %s.\r\n", inet_ntoa(pSock->sin_addr));
; 119  : 	/* skip all space and colon. */
; 120  : 	while (*sock_str && ((*sock_str == ' ') || (*sock_str == ':')))

  0010a	8b 45 f4	 mov	 eax, DWORD PTR _sock_str$[ebp]
  0010d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00110	85 c9		 test	 ecx, ecx
  00112	74 21		 je	 SHORT $LN11@GetSocketF
  00114	8b 55 f4	 mov	 edx, DWORD PTR _sock_str$[ebp]
  00117	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0011a	83 f8 20	 cmp	 eax, 32			; 00000020H
  0011d	74 0b		 je	 SHORT $LN19@GetSocketF
  0011f	8b 4d f4	 mov	 ecx, DWORD PTR _sock_str$[ebp]
  00122	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00125	83 fa 3a	 cmp	 edx, 58			; 0000003aH
  00128	75 0b		 jne	 SHORT $LN11@GetSocketF
$LN19@GetSocketF:

; 121  : 	{
; 122  : 		sock_str++;

  0012a	8b 45 f4	 mov	 eax, DWORD PTR _sock_str$[ebp]
  0012d	83 c0 01	 add	 eax, 1
  00130	89 45 f4	 mov	 DWORD PTR _sock_str$[ebp], eax

; 123  : 	}

  00133	eb d5		 jmp	 SHORT $LN10@GetSocketF
$LN11@GetSocketF:

; 124  : 	len = 0;

  00135	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
$LN12@GetSocketF:

; 125  : 	while (sock_str[len] && (sock_str[len] != '\r') && (sock_str[len] != '\n') && len < 31)

  0013c	8b 4d f4	 mov	 ecx, DWORD PTR _sock_str$[ebp]
  0013f	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  00142	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00145	85 d2		 test	 edx, edx
  00147	74 3c		 je	 SHORT $LN13@GetSocketF
  00149	8b 45 f4	 mov	 eax, DWORD PTR _sock_str$[ebp]
  0014c	03 45 f8	 add	 eax, DWORD PTR _len$[ebp]
  0014f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00152	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  00155	74 2e		 je	 SHORT $LN13@GetSocketF
  00157	8b 55 f4	 mov	 edx, DWORD PTR _sock_str$[ebp]
  0015a	03 55 f8	 add	 edx, DWORD PTR _len$[ebp]
  0015d	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00160	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00163	74 20		 je	 SHORT $LN13@GetSocketF
  00165	83 7d f8 1f	 cmp	 DWORD PTR _len$[ebp], 31 ; 0000001fH
  00169	7d 1a		 jge	 SHORT $LN13@GetSocketF

; 126  : 	{
; 127  : 		addr[len] = sock_str[len];

  0016b	8b 4d f4	 mov	 ecx, DWORD PTR _sock_str$[ebp]
  0016e	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  00171	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  00174	8a 01		 mov	 al, BYTE PTR [ecx]
  00176	88 44 15 d0	 mov	 BYTE PTR _addr$[ebp+edx], al

; 128  : 		len++;

  0017a	8b 4d f8	 mov	 ecx, DWORD PTR _len$[ebp]
  0017d	83 c1 01	 add	 ecx, 1
  00180	89 4d f8	 mov	 DWORD PTR _len$[ebp], ecx

; 129  : 	}

  00183	eb b7		 jmp	 SHORT $LN12@GetSocketF
$LN13@GetSocketF:

; 130  : 	if (len >= 31)

  00185	83 7d f8 1f	 cmp	 DWORD PTR _len$[ebp], 31 ; 0000001fH
  00189	7c 02		 jl	 SHORT $LN20@GetSocketF

; 131  : 	{
; 132  : 		goto __TERMINAL;

  0018b	eb 38		 jmp	 SHORT $__TERMINAL$23
$LN20@GetSocketF:

; 133  : 	}
; 134  : 	addr[len] = 0;

  0018d	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  00190	c6 44 15 d0 00	 mov	 BYTE PTR _addr$[ebp+edx], 0

; 135  : 	//_hx_printf("port = %s\r\n", addr);
; 136  : 	pSock->sin_port = _hx_htons((__u16)atol(addr));

  00195	8d 45 d0	 lea	 eax, DWORD PTR _addr$[ebp]
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 _atol
  0019e	83 c4 04	 add	 esp, 4
  001a1	50		 push	 eax
  001a2	e8 00 00 00 00	 call	 __hx_htons
  001a7	83 c4 04	 add	 esp, 4
  001aa	8b 4d 0c	 mov	 ecx, DWORD PTR _pSock$[ebp]
  001ad	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 137  : 	if (0 == pSock->sin_port)

  001b1	8b 55 0c	 mov	 edx, DWORD PTR _pSock$[ebp]
  001b4	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  001b8	85 c0		 test	 eax, eax
  001ba	75 02		 jne	 SHORT $LN21@GetSocketF

; 138  : 	{
; 139  : 		goto __TERMINAL;

  001bc	eb 07		 jmp	 SHORT $__TERMINAL$23
$LN21@GetSocketF:

; 140  : 	}
; 141  : 	bResult = TRUE;

  001be	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _bResult$[ebp], -1
$__TERMINAL$23:

; 142  : __TERMINAL:
; 143  : 	return bResult;

  001c5	8b 45 f0	 mov	 eax, DWORD PTR _bResult$[ebp]

; 144  : }

  001c8	8b e5		 mov	 esp, ebp
  001ca	5d		 pop	 ebp
  001cb	c3		 ret	 0
_GetSocketFromLocation ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\src\yeelight.c
;	COMDAT _getvalue
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_i$ = -4						; size = 4
_str$ = 8						; size = 4
_key$ = 12						; size = 4
_getvalue PROC						; COMDAT

; 42   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 43   : 	char* ret = NULL;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 44   : 	int i = 0;

  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 45   : 
; 46   : 	if ((NULL == str) || (NULL == key))

  00014	83 7d 08 00	 cmp	 DWORD PTR _str$[ebp], 0
  00018	74 06		 je	 SHORT $LN8@getvalue
  0001a	83 7d 0c 00	 cmp	 DWORD PTR _key$[ebp], 0
  0001e	75 05		 jne	 SHORT $LN7@getvalue
$LN8@getvalue:

; 47   : 	{
; 48   : 		goto __TERMINAL;

  00020	e9 ae 00 00 00	 jmp	 $__TERMINAL$15
$LN7@getvalue:

; 49   : 	}
; 50   : 	for (i = 0; str[i] && key[i]; i++)

  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002c	eb 09		 jmp	 SHORT $LN4@getvalue
$LN2@getvalue:
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00031	83 c0 01	 add	 eax, 1
  00034	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@getvalue:
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0003a	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  0003d	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00040	85 d2		 test	 edx, edx
  00042	74 27		 je	 SHORT $LN3@getvalue
  00044	8b 45 0c	 mov	 eax, DWORD PTR _key$[ebp]
  00047	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0004a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0004d	85 c9		 test	 ecx, ecx
  0004f	74 1a		 je	 SHORT $LN3@getvalue

; 51   : 	{
; 52   : 		if (str[i] != key[i])

  00051	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00054	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00057	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0005a	8b 4d 0c	 mov	 ecx, DWORD PTR _key$[ebp]
  0005d	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00060	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00063	3b c2		 cmp	 eax, edx
  00065	74 02		 je	 SHORT $LN9@getvalue

; 53   : 		{
; 54   : 			break;

  00067	eb 02		 jmp	 SHORT $LN3@getvalue
$LN9@getvalue:

; 55   : 		}
; 56   : 	}

  00069	eb c3		 jmp	 SHORT $LN2@getvalue
$LN3@getvalue:

; 57   : 	/* Key can not match the proceeding part of str? */
; 58   : 	if ((0 == str[i]) || (key[i]))

  0006b	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  0006e	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00071	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00074	85 c9		 test	 ecx, ecx
  00076	74 0d		 je	 SHORT $LN11@getvalue
  00078	8b 55 0c	 mov	 edx, DWORD PTR _key$[ebp]
  0007b	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  0007e	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00081	85 c0		 test	 eax, eax
  00083	74 02		 je	 SHORT $LN5@getvalue
$LN11@getvalue:

; 59   : 	{
; 60   : 		goto __TERMINAL;

  00085	eb 4c		 jmp	 SHORT $__TERMINAL$15
$LN5@getvalue:

; 61   : 	}
; 62   : 	/* Skip all spaces and colons. */
; 63   : 	while (str[i] && ((' ' == str[i]) || (':' == str[i])))

  00087	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0008a	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  0008d	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00090	85 d2		 test	 edx, edx
  00092	74 27		 je	 SHORT $LN6@getvalue
  00094	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00097	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0009a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0009d	83 f9 20	 cmp	 ecx, 32			; 00000020H
  000a0	74 0e		 je	 SHORT $LN12@getvalue
  000a2	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  000a5	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000a8	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000ab	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  000ae	75 0b		 jne	 SHORT $LN6@getvalue
$LN12@getvalue:

; 64   : 	{
; 65   : 		i++;

  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000b3	83 c1 01	 add	 ecx, 1
  000b6	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx

; 66   : 	}

  000b9	eb cc		 jmp	 SHORT $LN5@getvalue
$LN6@getvalue:

; 67   : 	if (0 == str[i])

  000bb	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  000be	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000c1	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000c4	85 c0		 test	 eax, eax
  000c6	75 02		 jne	 SHORT $LN13@getvalue

; 68   : 	{
; 69   : 		goto __TERMINAL;

  000c8	eb 09		 jmp	 SHORT $__TERMINAL$15
$LN13@getvalue:

; 70   : 	}
; 71   : 	ret = &str[i];

  000ca	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  000cd	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  000d0	89 4d f8	 mov	 DWORD PTR _ret$[ebp], ecx
$__TERMINAL$15:

; 72   : __TERMINAL:
; 73   : 	return ret;

  000d3	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]

; 74   : }

  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c3		 ret	 0
_getvalue ENDP
_TEXT	ENDS
END
