; Listing generated by Microsoft (R) Optimizing Compiler Version 19.13.26128.0 

	TITLE	C:\HelloX\personal\HelloX_OS\app\yeelight\src\yeelight.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_okmsg
_BSS	SEGMENT
_pLightObject DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_okmsg	DD	FLAT:$SG5006
$SG5006	DB	'HTTP/1.1 200 OK', 00H
$SG5077	DB	'c:\hellox\personal\hellox_os\app\yeelight\src\yeelight.c'
	DB	00H
	ORG $+3
$SG5079	DB	'c:\hellox\personal\hellox_os\app\yeelight\src\yeelight.c'
	DB	00H
	ORG $+3
$SG5080	DB	'yeelight', 00H
	ORG $+3
$SG5094	DB	'--------------------', 0dH, 0aH, 00H
	ORG $+1
$SG5095	DB	'id: %s', 0dH, 0aH, 00H
	ORG $+3
$SG5096	DB	'ip: %s', 0dH, 0aH, 00H
	ORG $+3
$SG5097	DB	'port: %d', 0dH, 0aH, 00H
	ORG $+1
$SG5126	DB	0dH, 0aH, 00H
	ORG $+1
$SG5129	DB	'Location', 00H
	ORG $+3
$SG5131	DB	'id', 00H
	ORG $+1
$SG5134	DB	'name', 00H
	ORG $+3
$SG5136	DB	0dH, 0aH, 00H
	ORG $+1
$SG5140	DB	0dH, 0aH, 'A new light found[id = %s].', 0dH, 0aH, 00H
$SG5175	DB	'Failed to set periodic timer object.', 0dH, 0aH, 00H
	ORG $+1
$SG5177	DB	'ylight_search', 00H
	ORG $+2
$SG5178	DB	'%s:failed to create socket.', 0dH, 0aH, 00H
	ORG $+2
$SG5180	DB	'ylight_search', 00H
	ORG $+2
$SG5181	DB	'%s:failed to set sock''s timeout.', 0dH, 0aH, 00H
	ORG $+1
$SG5182	DB	'192.168.169.1', 00H
	ORG $+2
$SG5184	DB	'ylight_search', 00H
	ORG $+2
$SG5185	DB	'%s:failed to set out going interface.', 0dH, 0aH, 00H
$SG5186	DB	'239.255.255.250', 00H
$SG5188	DB	'ylight_search', 00H
	ORG $+2
$SG5189	DB	'%s:failed to join multicast group,err = %d.', 0dH, 0aH, 00H
	ORG $+2
$SG5191	DB	'ylight_search', 00H
	ORG $+2
$SG5192	DB	'%s:failed to bind to local interface.', 0dH, 0aH, 00H
$SG5196	DB	'239.255.255.250', 00H
$SG5197	DB	'M-SEARCH * HTTP/1.1', 0dH, 0aH, 'HOST: 239.255.255.250:1'
	DB	'982', 0dH, 0aH, 'MAN: "ssdp:discover"', 0dH, 0aH, 'ST: wifi_b'
	DB	'ulb', 00H
	ORG $+3
$SG5200	DB	'ylight_search', 00H
	ORG $+2
$SG5201	DB	'%s:failed to send request.', 0dH, 0aH, 00H
	ORG $+3
$SG5209	DB	'Bulb searcher exit.', 0dH, 0aH, 00H
	ORG $+2
$SG5243	DB	'Yeelight controller for HelloX[v%d.%d].', 0dH, 0aH, 00H
	ORG $+2
$SG5244	DB	'YLIGHT_CTRL', 00H
$SG5246	DB	'Failed to create controller thread.', 0dH, 0aH, 00H
	ORG $+2
$SG5247	DB	'YEELIGHT', 00H
	ORG $+3
$SG5249	DB	'Failed to create searching thread.', 0dH, 0aH, 00H
	ORG $+3
$SG5250	DB	'YLIGHT_SRV', 00H
	ORG $+1
$SG5252	DB	'Failed to create server thread.', 0dH, 0aH, 00H
	ORG $+2
$SG5256	DB	'list', 00H
	ORG $+3
$SG5259	DB	'exit', 00H
	ORG $+3
$SG5262	DB	'turnon', 00H
	ORG $+1
$SG5266	DB	'turnoff', 00H
$SG5270	DB	'help', 00H
	ORG $+3
$SG5271	DB	'  list    : Show out all found bulb(s).', 0dH, 0aH, 00H
	ORG $+2
$SG5272	DB	'  turnon  : Turn on a specified bulb.', 0dH, 0aH, 00H
$SG5273	DB	'  turnoff : Turn off a specified bulb.', 0dH, 0aH, 00H
	ORG $+3
$SG5274	DB	'  exit    : Exit the application.', 0dH, 0aH, 00H
$SG5275	DB	'  Unknown command.', 0dH, 0aH, 00H
_DATA	ENDS
PUBLIC	__hx_main
EXTRN	_CreateKernelThread:PROC
EXTRN	_DestroyKernelThread:PROC
EXTRN	_GetMessage:PROC
EXTRN	_SendMessage:PROC
EXTRN	_SetTimer:PROC
EXTRN	_CancelTimer:PROC
EXTRN	_WaitForThisObject:PROC
EXTRN	_getcmd:PROC
EXTRN	___BUG:PROC
EXTRN	_LogHeader:PROC
EXTRN	__hx_printf:PROC
EXTRN	__hx_malloc:PROC
EXTRN	__hx_free:PROC
EXTRN	_atol:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	_strtok:PROC
EXTRN	_ipaddr_addr:PROC
EXTRN	_ipaddr_ntoa:PROC
EXTRN	__hx_htonl:PROC
EXTRN	__hx_htons:PROC
EXTRN	__hx_ntohs:PROC
EXTRN	_bind:PROC
EXTRN	_setsockopt:PROC
EXTRN	_close:PROC
EXTRN	_recvfrom:PROC
EXTRN	_sendto:PROC
EXTRN	_socket:PROC
EXTRN	_ylight_server:PROC
EXTRN	_ylight_controller:PROC
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\src\yeelight.c
;	COMDAT __hx_main
_TEXT	SEGMENT
_cmd_array$ = -48					; size = 16
_msg$ = -32						; size = 8
_i$ = -24						; size = 4
_cmd_num$ = -20						; size = 4
_pLight$ = -16						; size = 4
_hServerThread$ = -12					; size = 4
_hSearchThread$ = -8					; size = 4
_hCtrlThread$ = -4					; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
__hx_main PROC						; COMDAT

; 407  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H

; 408  : 	char* cmd_array[4];
; 409  : 	int cmd_num = 0, i = 0;

  00006	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _cmd_num$[ebp], 0
  0000d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 410  : 	struct yeelight_object* pLight = NULL;

  00014	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _pLight$[ebp], 0

; 411  : 	HANDLE hSearchThread = NULL;

  0001b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _hSearchThread$[ebp], 0

; 412  : 	HANDLE hServerThread = NULL;

  00022	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _hServerThread$[ebp], 0

; 413  : 	HANDLE hCtrlThread = NULL;

  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hCtrlThread$[ebp], 0

; 414  : 	MSG msg;
; 415  : 
; 416  : 	/* Show version info. */
; 417  : 	_hx_printf("Yeelight controller for HelloX[v%d.%d].\r\n", __MAJOR_VER, __MINNOR_VER);

  00030	6a 02		 push	 2
  00032	6a 01		 push	 1
  00034	68 00 00 00 00	 push	 OFFSET $SG5243
  00039	e8 00 00 00 00	 call	 __hx_printf
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 418  : 
; 419  : 	/* Create the controller kernel thread. */
; 420  : 	hCtrlThread = CreateKernelThread(

  00041	68 00 00 00 00	 push	 OFFSET $SG5244
  00046	6a 00		 push	 0
  00048	6a 00		 push	 0
  0004a	68 00 00 00 00	 push	 OFFSET _ylight_controller
  0004f	6a 08		 push	 8
  00051	6a 02		 push	 2
  00053	6a 00		 push	 0
  00055	e8 00 00 00 00	 call	 _CreateKernelThread
  0005a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0005d	89 45 fc	 mov	 DWORD PTR _hCtrlThread$[ebp], eax

; 421  : 		0,
; 422  : 		KERNEL_THREAD_STATUS_READY,
; 423  : 		PRIORITY_LEVEL_NORMAL,
; 424  : 		ylight_controller,
; 425  : 		NULL,
; 426  : 		NULL,
; 427  : 		"YLIGHT_CTRL");
; 428  : 	if (NULL == hCtrlThread)

  00060	83 7d fc 00	 cmp	 DWORD PTR _hCtrlThread$[ebp], 0
  00064	75 1c		 jne	 SHORT $LN6@hx_main

; 429  : 	{
; 430  : 		__LOG("Failed to create controller thread.\r\n");

  00066	6a 00		 push	 0
  00068	e8 00 00 00 00	 call	 _LogHeader
  0006d	83 c4 04	 add	 esp, 4
  00070	68 00 00 00 00	 push	 OFFSET $SG5246
  00075	e8 00 00 00 00	 call	 __hx_printf
  0007a	83 c4 04	 add	 esp, 4

; 431  : 		goto __TERMINAL;

  0007d	e9 ff 01 00 00	 jmp	 $__TERMINAL$27
$LN6@hx_main:

; 432  : 	}
; 433  : 
; 434  : 	/* 
; 435  : 	 * A dedicated kernel thread is running in background, to search and 
; 436  : 	 * manages all bulb(s) in LAN.
; 437  : 	 * Bring up this kernel thread first.
; 438  : 	 */
; 439  : 	hSearchThread = CreateKernelThread(

  00082	68 00 00 00 00	 push	 OFFSET $SG5247
  00087	6a 00		 push	 0
  00089	6a 00		 push	 0
  0008b	68 00 00 00 00	 push	 OFFSET _ylight_search
  00090	6a 08		 push	 8
  00092	6a 02		 push	 2
  00094	6a 00		 push	 0
  00096	e8 00 00 00 00	 call	 _CreateKernelThread
  0009b	83 c4 1c	 add	 esp, 28			; 0000001cH
  0009e	89 45 f8	 mov	 DWORD PTR _hSearchThread$[ebp], eax

; 440  : 		0,
; 441  : 		KERNEL_THREAD_STATUS_READY,
; 442  : 		PRIORITY_LEVEL_NORMAL,
; 443  : 		ylight_search,
; 444  : 		NULL,
; 445  : 		NULL,
; 446  : 		"YEELIGHT");
; 447  : 	if (NULL == hSearchThread)

  000a1	83 7d f8 00	 cmp	 DWORD PTR _hSearchThread$[ebp], 0
  000a5	75 1c		 jne	 SHORT $LN7@hx_main

; 448  : 	{
; 449  : 		__LOG("Failed to create searching thread.\r\n");

  000a7	6a 00		 push	 0
  000a9	e8 00 00 00 00	 call	 _LogHeader
  000ae	83 c4 04	 add	 esp, 4
  000b1	68 00 00 00 00	 push	 OFFSET $SG5249
  000b6	e8 00 00 00 00	 call	 __hx_printf
  000bb	83 c4 04	 add	 esp, 4

; 450  : 		goto __TERMINAL;

  000be	e9 be 01 00 00	 jmp	 $__TERMINAL$27
$LN7@hx_main:

; 451  : 	}
; 452  : 
; 453  : 	/* Create the server thread of controller. */
; 454  : 	hServerThread = CreateKernelThread(

  000c3	68 00 00 00 00	 push	 OFFSET $SG5250
  000c8	6a 00		 push	 0
  000ca	8b 45 fc	 mov	 eax, DWORD PTR _hCtrlThread$[ebp]
  000cd	50		 push	 eax
  000ce	68 00 00 00 00	 push	 OFFSET _ylight_server
  000d3	6a 08		 push	 8
  000d5	6a 02		 push	 2
  000d7	6a 00		 push	 0
  000d9	e8 00 00 00 00	 call	 _CreateKernelThread
  000de	83 c4 1c	 add	 esp, 28			; 0000001cH
  000e1	89 45 f4	 mov	 DWORD PTR _hServerThread$[ebp], eax

; 455  : 		0,
; 456  : 		KERNEL_THREAD_STATUS_READY,
; 457  : 		PRIORITY_LEVEL_NORMAL,
; 458  : 		ylight_server,
; 459  : 		hCtrlThread, /* Send message to controller thread. */
; 460  : 		NULL,
; 461  : 		"YLIGHT_SRV");
; 462  : 	if (NULL == hServerThread)

  000e4	83 7d f4 00	 cmp	 DWORD PTR _hServerThread$[ebp], 0
  000e8	75 1c		 jne	 SHORT $LN2@hx_main

; 463  : 	{
; 464  : 		__LOG("Failed to create server thread.\r\n");

  000ea	6a 00		 push	 0
  000ec	e8 00 00 00 00	 call	 _LogHeader
  000f1	83 c4 04	 add	 esp, 4
  000f4	68 00 00 00 00	 push	 OFFSET $SG5252
  000f9	e8 00 00 00 00	 call	 __hx_printf
  000fe	83 c4 04	 add	 esp, 4

; 465  : 		goto __TERMINAL;

  00101	e9 7b 01 00 00	 jmp	 $__TERMINAL$27
$LN2@hx_main:

; 466  : 	}
; 467  : 
; 468  : 	/* Interactive with user. */
; 469  : 	while (TRUE)

  00106	83 c9 ff	 or	 ecx, -1
  00109	0f 84 72 01 00
	00		 je	 $__TERMINAL$27

; 470  : 	{
; 471  : 		cmd_num = getcmd(cmd_array, 4);

  0010f	6a 04		 push	 4
  00111	8d 55 d0	 lea	 edx, DWORD PTR _cmd_array$[ebp]
  00114	52		 push	 edx
  00115	e8 00 00 00 00	 call	 _getcmd
  0011a	83 c4 08	 add	 esp, 8
  0011d	89 45 ec	 mov	 DWORD PTR _cmd_num$[ebp], eax

; 472  : 		if (cmd_num > 0)

  00120	83 7d ec 00	 cmp	 DWORD PTR _cmd_num$[ebp], 0
  00124	0f 8e 52 01 00
	00		 jle	 $LN9@hx_main

; 473  : 		{
; 474  : 			if (strcmp(cmd_array[0], "list") == 0)

  0012a	68 00 00 00 00	 push	 OFFSET $SG5256
  0012f	b8 04 00 00 00	 mov	 eax, 4
  00134	6b c8 00	 imul	 ecx, eax, 0
  00137	8b 54 0d d0	 mov	 edx, DWORD PTR _cmd_array$[ebp+ecx]
  0013b	52		 push	 edx
  0013c	e8 00 00 00 00	 call	 _strcmp
  00141	83 c4 08	 add	 esp, 8
  00144	85 c0		 test	 eax, eax
  00146	75 13		 jne	 SHORT $LN10@hx_main

; 475  : 			{
; 476  : 				/* Show all found bulb(s). */
; 477  : 				ShowLight(pLightObject);

  00148	a1 00 00 00 00	 mov	 eax, DWORD PTR _pLightObject
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 _ShowLight
  00153	83 c4 04	 add	 esp, 4

; 478  : 			}

  00156	e9 21 01 00 00	 jmp	 $LN9@hx_main
$LN10@hx_main:

; 479  : 			else if (strcmp(cmd_array[0], "exit") == 0)

  0015b	68 00 00 00 00	 push	 OFFSET $SG5259
  00160	b9 04 00 00 00	 mov	 ecx, 4
  00165	6b d1 00	 imul	 edx, ecx, 0
  00168	8b 44 15 d0	 mov	 eax, DWORD PTR _cmd_array$[ebp+edx]
  0016c	50		 push	 eax
  0016d	e8 00 00 00 00	 call	 _strcmp
  00172	83 c4 08	 add	 esp, 8
  00175	85 c0		 test	 eax, eax
  00177	75 0a		 jne	 SHORT $LN12@hx_main

; 480  : 			{
; 481  : 				/* Exit the application. */
; 482  : 				goto __TERMINAL;

  00179	e9 03 01 00 00	 jmp	 $__TERMINAL$27

; 483  : 			}

  0017e	e9 f9 00 00 00	 jmp	 $LN9@hx_main
$LN12@hx_main:

; 484  : 			else if (strcmp(cmd_array[0], "turnon") == 0)

  00183	68 00 00 00 00	 push	 OFFSET $SG5262
  00188	b9 04 00 00 00	 mov	 ecx, 4
  0018d	6b d1 00	 imul	 edx, ecx, 0
  00190	8b 44 15 d0	 mov	 eax, DWORD PTR _cmd_array$[ebp+edx]
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 _strcmp
  0019a	83 c4 08	 add	 esp, 8
  0019d	85 c0		 test	 eax, eax
  0019f	75 30		 jne	 SHORT $LN14@hx_main

; 485  : 			{
; 486  : 				/* 
; 487  : 				 * Turn on the specified light,but we just turn on 
; 488  : 				 * the first light in list,for simplicity.
; 489  : 				 */
; 490  : 				if (pLightObject)

  001a1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _pLightObject, 0
  001a8	74 22		 je	 SHORT $LN16@hx_main

; 491  : 				{
; 492  : 					msg.wCommand = YLIGHT_MSG_TOGGLE;

  001aa	b9 01 04 00 00	 mov	 ecx, 1025		; 00000401H
  001af	66 89 4d e0	 mov	 WORD PTR _msg$[ebp], cx

; 493  : 					msg.dwParam = (DWORD)pLightObject;

  001b3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pLightObject
  001b9	89 55 e4	 mov	 DWORD PTR _msg$[ebp+4], edx

; 494  : 					SendMessage(hCtrlThread, &msg);

  001bc	8d 45 e0	 lea	 eax, DWORD PTR _msg$[ebp]
  001bf	50		 push	 eax
  001c0	8b 4d fc	 mov	 ecx, DWORD PTR _hCtrlThread$[ebp]
  001c3	51		 push	 ecx
  001c4	e8 00 00 00 00	 call	 _SendMessage
  001c9	83 c4 08	 add	 esp, 8
$LN16@hx_main:

; 495  : 				}
; 496  : 			}

  001cc	e9 ab 00 00 00	 jmp	 $LN9@hx_main
$LN14@hx_main:

; 497  : 			else if (strcmp(cmd_array[0], "turnoff") == 0)

  001d1	68 00 00 00 00	 push	 OFFSET $SG5266
  001d6	ba 04 00 00 00	 mov	 edx, 4
  001db	6b c2 00	 imul	 eax, edx, 0
  001de	8b 4c 05 d0	 mov	 ecx, DWORD PTR _cmd_array$[ebp+eax]
  001e2	51		 push	 ecx
  001e3	e8 00 00 00 00	 call	 _strcmp
  001e8	83 c4 08	 add	 esp, 8
  001eb	85 c0		 test	 eax, eax
  001ed	75 2c		 jne	 SHORT $LN17@hx_main

; 498  : 			{
; 499  : 				/* Turn off the first light. */
; 500  : 				if (pLightObject)

  001ef	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _pLightObject, 0
  001f6	74 21		 je	 SHORT $LN19@hx_main

; 501  : 				{
; 502  : 					msg.wCommand = YLIGHT_MSG_TOGGLE;

  001f8	ba 01 04 00 00	 mov	 edx, 1025		; 00000401H
  001fd	66 89 55 e0	 mov	 WORD PTR _msg$[ebp], dx

; 503  : 					msg.dwParam = (DWORD)pLightObject;

  00201	a1 00 00 00 00	 mov	 eax, DWORD PTR _pLightObject
  00206	89 45 e4	 mov	 DWORD PTR _msg$[ebp+4], eax

; 504  : 					SendMessage(hCtrlThread, &msg);

  00209	8d 4d e0	 lea	 ecx, DWORD PTR _msg$[ebp]
  0020c	51		 push	 ecx
  0020d	8b 55 fc	 mov	 edx, DWORD PTR _hCtrlThread$[ebp]
  00210	52		 push	 edx
  00211	e8 00 00 00 00	 call	 _SendMessage
  00216	83 c4 08	 add	 esp, 8
$LN19@hx_main:

; 505  : 				}
; 506  : 			}

  00219	eb 61		 jmp	 SHORT $LN9@hx_main
$LN17@hx_main:

; 507  : 			else if (strcmp(cmd_array[0], "help") == 0)

  0021b	68 00 00 00 00	 push	 OFFSET $SG5270
  00220	b8 04 00 00 00	 mov	 eax, 4
  00225	6b c8 00	 imul	 ecx, eax, 0
  00228	8b 54 0d d0	 mov	 edx, DWORD PTR _cmd_array$[ebp+ecx]
  0022c	52		 push	 edx
  0022d	e8 00 00 00 00	 call	 _strcmp
  00232	83 c4 08	 add	 esp, 8
  00235	85 c0		 test	 eax, eax
  00237	75 36		 jne	 SHORT $LN20@hx_main

; 508  : 			{
; 509  : 				/* Show help information. */
; 510  : 				_hx_printf("  list    : Show out all found bulb(s).\r\n");

  00239	68 00 00 00 00	 push	 OFFSET $SG5271
  0023e	e8 00 00 00 00	 call	 __hx_printf
  00243	83 c4 04	 add	 esp, 4

; 511  : 				_hx_printf("  turnon  : Turn on a specified bulb.\r\n");

  00246	68 00 00 00 00	 push	 OFFSET $SG5272
  0024b	e8 00 00 00 00	 call	 __hx_printf
  00250	83 c4 04	 add	 esp, 4

; 512  : 				_hx_printf("  turnoff : Turn off a specified bulb.\r\n");

  00253	68 00 00 00 00	 push	 OFFSET $SG5273
  00258	e8 00 00 00 00	 call	 __hx_printf
  0025d	83 c4 04	 add	 esp, 4

; 513  : 				_hx_printf("  exit    : Exit the application.\r\n");

  00260	68 00 00 00 00	 push	 OFFSET $SG5274
  00265	e8 00 00 00 00	 call	 __hx_printf
  0026a	83 c4 04	 add	 esp, 4

; 514  : 			}

  0026d	eb 0d		 jmp	 SHORT $LN9@hx_main
$LN20@hx_main:

; 515  : 			else
; 516  : 			{
; 517  : 				/* Unknown command. */
; 518  : 				_hx_printf("  Unknown command.\r\n");

  0026f	68 00 00 00 00	 push	 OFFSET $SG5275
  00274	e8 00 00 00 00	 call	 __hx_printf
  00279	83 c4 04	 add	 esp, 4
$LN9@hx_main:

; 519  : 			}
; 520  : 		}
; 521  : 	}

  0027c	e9 85 fe ff ff	 jmp	 $LN2@hx_main
$__TERMINAL$27:

; 522  : __TERMINAL:
; 523  : 	if (hSearchThread)

  00281	83 7d f8 00	 cmp	 DWORD PTR _hSearchThread$[ebp], 0
  00285	74 31		 je	 SHORT $LN22@hx_main

; 524  : 	{
; 525  : 		/* Notify the searching thread to exit. */
; 526  : 		msg.wCommand = KERNEL_MESSAGE_TERMINAL;

  00287	b8 05 00 00 00	 mov	 eax, 5
  0028c	66 89 45 e0	 mov	 WORD PTR _msg$[ebp], ax

; 527  : 		SendMessage(hSearchThread, &msg);

  00290	8d 4d e0	 lea	 ecx, DWORD PTR _msg$[ebp]
  00293	51		 push	 ecx
  00294	8b 55 f8	 mov	 edx, DWORD PTR _hSearchThread$[ebp]
  00297	52		 push	 edx
  00298	e8 00 00 00 00	 call	 _SendMessage
  0029d	83 c4 08	 add	 esp, 8

; 528  : 		/* Wait for the searching thread run over. */
; 529  : 		WaitForThisObject(hSearchThread);

  002a0	8b 45 f8	 mov	 eax, DWORD PTR _hSearchThread$[ebp]
  002a3	50		 push	 eax
  002a4	e8 00 00 00 00	 call	 _WaitForThisObject
  002a9	83 c4 04	 add	 esp, 4

; 530  : 		/* Destroy it. */
; 531  : 		DestroyKernelThread(hSearchThread);

  002ac	8b 4d f8	 mov	 ecx, DWORD PTR _hSearchThread$[ebp]
  002af	51		 push	 ecx
  002b0	e8 00 00 00 00	 call	 _DestroyKernelThread
  002b5	83 c4 04	 add	 esp, 4
$LN22@hx_main:

; 532  : 	}
; 533  : 	if (hCtrlThread)

  002b8	83 7d fc 00	 cmp	 DWORD PTR _hCtrlThread$[ebp], 0
  002bc	74 31		 je	 SHORT $LN23@hx_main

; 534  : 	{
; 535  : 		/* Trigger the controller thread to exit. */
; 536  : 		msg.wCommand = KERNEL_MESSAGE_TERMINAL;

  002be	ba 05 00 00 00	 mov	 edx, 5
  002c3	66 89 55 e0	 mov	 WORD PTR _msg$[ebp], dx

; 537  : 		SendMessage(hCtrlThread, &msg);

  002c7	8d 45 e0	 lea	 eax, DWORD PTR _msg$[ebp]
  002ca	50		 push	 eax
  002cb	8b 4d fc	 mov	 ecx, DWORD PTR _hCtrlThread$[ebp]
  002ce	51		 push	 ecx
  002cf	e8 00 00 00 00	 call	 _SendMessage
  002d4	83 c4 08	 add	 esp, 8

; 538  : 		/* Wait the controller to exit. */
; 539  : 		WaitForThisObject(hCtrlThread);

  002d7	8b 55 fc	 mov	 edx, DWORD PTR _hCtrlThread$[ebp]
  002da	52		 push	 edx
  002db	e8 00 00 00 00	 call	 _WaitForThisObject
  002e0	83 c4 04	 add	 esp, 4

; 540  : 		DestroyKernelThread(hCtrlThread);

  002e3	8b 45 fc	 mov	 eax, DWORD PTR _hCtrlThread$[ebp]
  002e6	50		 push	 eax
  002e7	e8 00 00 00 00	 call	 _DestroyKernelThread
  002ec	83 c4 04	 add	 esp, 4
$LN23@hx_main:

; 541  : 	}
; 542  : 	if (hServerThread)

  002ef	83 7d f4 00	 cmp	 DWORD PTR _hServerThread$[ebp], 0
  002f3	74 31		 je	 SHORT $LN4@hx_main

; 543  : 	{
; 544  : 		msg.wCommand = KERNEL_MESSAGE_TERMINAL;

  002f5	b9 05 00 00 00	 mov	 ecx, 5
  002fa	66 89 4d e0	 mov	 WORD PTR _msg$[ebp], cx

; 545  : 		SendMessage(hServerThread, &msg);

  002fe	8d 55 e0	 lea	 edx, DWORD PTR _msg$[ebp]
  00301	52		 push	 edx
  00302	8b 45 f4	 mov	 eax, DWORD PTR _hServerThread$[ebp]
  00305	50		 push	 eax
  00306	e8 00 00 00 00	 call	 _SendMessage
  0030b	83 c4 08	 add	 esp, 8

; 546  : 		WaitForThisObject(hServerThread);

  0030e	8b 4d f4	 mov	 ecx, DWORD PTR _hServerThread$[ebp]
  00311	51		 push	 ecx
  00312	e8 00 00 00 00	 call	 _WaitForThisObject
  00317	83 c4 04	 add	 esp, 4

; 547  : 		DestroyKernelThread(hServerThread);

  0031a	8b 55 f4	 mov	 edx, DWORD PTR _hServerThread$[ebp]
  0031d	52		 push	 edx
  0031e	e8 00 00 00 00	 call	 _DestroyKernelThread
  00323	83 c4 04	 add	 esp, 4
$LN4@hx_main:

; 548  : 	}
; 549  : 
; 550  : 	/* Destroy all light object(s). */
; 551  : 	while (pLightObject)

  00326	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _pLightObject, 0
  0032d	74 3d		 je	 SHORT $LN5@hx_main

; 552  : 	{
; 553  : 		pLight = pLightObject;

  0032f	a1 00 00 00 00	 mov	 eax, DWORD PTR _pLightObject
  00334	89 45 f0	 mov	 DWORD PTR _pLight$[ebp], eax

; 554  : 		pLightObject = pLightObject->pNext;

  00337	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pLightObject
  0033d	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00340	89 15 00 00 00
	00		 mov	 DWORD PTR _pLightObject, edx

; 555  : 		/* Close socket if open. */
; 556  : 		if (pLight->sock >= 0)

  00346	8b 45 f0	 mov	 eax, DWORD PTR _pLight$[ebp]
  00349	83 78 2c 00	 cmp	 DWORD PTR [eax+44], 0
  0034d	7c 0f		 jl	 SHORT $LN25@hx_main

; 557  : 		{
; 558  : 			close(pLight->sock);

  0034f	8b 4d f0	 mov	 ecx, DWORD PTR _pLight$[ebp]
  00352	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  00355	52		 push	 edx
  00356	e8 00 00 00 00	 call	 _close
  0035b	83 c4 04	 add	 esp, 4
$LN25@hx_main:

; 559  : 		}
; 560  : 		_hx_free(pLight);

  0035e	8b 45 f0	 mov	 eax, DWORD PTR _pLight$[ebp]
  00361	50		 push	 eax
  00362	e8 00 00 00 00	 call	 __hx_free
  00367	83 c4 04	 add	 esp, 4

; 561  : 	}

  0036a	eb ba		 jmp	 SHORT $LN4@hx_main
$LN5@hx_main:

; 562  : 	
; 563  : 	return 0;

  0036c	33 c0		 xor	 eax, eax

; 564  : }

  0036e	8b e5		 mov	 esp, ebp
  00370	5d		 pop	 ebp
  00371	c3		 ret	 0
__hx_main ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\src\yeelight.c
;	COMDAT _ylight_search
_TEXT	SEGMENT
_gaddr$ = -64						; size = 16
_msg$ = -48						; size = 8
_mreq$ = -40						; size = 8
_ifaddr$ = -32						; size = 4
_timeout$ = -28						; size = 4
tv173 = -24						; size = 4
_len$ = -20						; size = 4
_hTimer$ = -16						; size = 4
_buf$ = -12						; size = 4
_s$ = -8						; size = 4
_ret$ = -4						; size = 4
_pData$ = 8						; size = 4
_ylight_search PROC					; COMDAT

; 263  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 264  : 	int s = -1, ret = -1, len = 0;

  00006	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _s$[ebp], -1
  0000d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -1
  00014	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 265  : 	int timeout = SSDP_WAIT_TIMEOUT;

  0001b	c7 45 e4 d0 07
	00 00		 mov	 DWORD PTR _timeout$[ebp], 2000 ; 000007d0H

; 266  : 	char* buf = NULL;

  00022	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _buf$[ebp], 0

; 267  : 	struct sockaddr_in gaddr;
; 268  : 	struct in_addr ifaddr;
; 269  : 	HANDLE hTimer = NULL;

  00029	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _hTimer$[ebp], 0

; 270  : 	MSG msg;
; 271  : 
; 272  : 	/* Create the periodic timer that trigger light searching. */
; 273  : 	hTimer = SetTimer(YLIGHT_PERIODIC_ID, SSDP_PERIODIC_TIME, NULL, NULL, TIMER_FLAGS_ALWAYS);

  00030	6a 02		 push	 2
  00032	6a 00		 push	 0
  00034	6a 00		 push	 0
  00036	68 b8 0b 00 00	 push	 3000			; 00000bb8H
  0003b	68 e8 03 00 00	 push	 1000			; 000003e8H
  00040	e8 00 00 00 00	 call	 _SetTimer
  00045	83 c4 14	 add	 esp, 20			; 00000014H
  00048	89 45 f0	 mov	 DWORD PTR _hTimer$[ebp], eax

; 274  : 	if (NULL == hTimer)

  0004b	83 7d f0 00	 cmp	 DWORD PTR _hTimer$[ebp], 0
  0004f	75 1c		 jne	 SHORT $LN6@ylight_sea

; 275  : 	{
; 276  : 		__LOG("Failed to set periodic timer object.\r\n");

  00051	6a 00		 push	 0
  00053	e8 00 00 00 00	 call	 _LogHeader
  00058	83 c4 04	 add	 esp, 4
  0005b	68 00 00 00 00	 push	 OFFSET $SG5175
  00060	e8 00 00 00 00	 call	 __hx_printf
  00065	83 c4 04	 add	 esp, 4

; 277  : 		goto __TERMINAL;

  00068	e9 d8 02 00 00	 jmp	 $__TERMINAL$25
$LN6@ylight_sea:

; 278  : 	}
; 279  : 
; 280  : 	/* Create socket to receive multicast data. */
; 281  : 	s = socket(AF_INET, SOCK_DGRAM, 0);

  0006d	6a 00		 push	 0
  0006f	6a 02		 push	 2
  00071	6a 02		 push	 2
  00073	e8 00 00 00 00	 call	 _socket
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007b	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax

; 282  : 	if (s < 0)

  0007e	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  00082	7d 21		 jge	 SHORT $LN7@ylight_sea

; 283  : 	{
; 284  : 		__LOG("%s:failed to create socket.\r\n", __FUNCTION__);

  00084	6a 00		 push	 0
  00086	e8 00 00 00 00	 call	 _LogHeader
  0008b	83 c4 04	 add	 esp, 4
  0008e	68 00 00 00 00	 push	 OFFSET $SG5177
  00093	68 00 00 00 00	 push	 OFFSET $SG5178
  00098	e8 00 00 00 00	 call	 __hx_printf
  0009d	83 c4 08	 add	 esp, 8

; 285  : 		goto __TERMINAL;

  000a0	e9 a0 02 00 00	 jmp	 $__TERMINAL$25
$LN7@ylight_sea:

; 286  : 	}
; 287  : 
; 288  : 	/* Set timeout value for this socket. */
; 289  : 	ret = setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));

  000a5	6a 04		 push	 4
  000a7	8d 45 e4	 lea	 eax, DWORD PTR _timeout$[ebp]
  000aa	50		 push	 eax
  000ab	68 06 10 00 00	 push	 4102			; 00001006H
  000b0	68 ff 0f 00 00	 push	 4095			; 00000fffH
  000b5	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000b8	51		 push	 ecx
  000b9	e8 00 00 00 00	 call	 _setsockopt
  000be	83 c4 14	 add	 esp, 20			; 00000014H
  000c1	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 290  : 	if (ret < 0)

  000c4	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  000c8	7d 21		 jge	 SHORT $LN8@ylight_sea

; 291  : 	{
; 292  : 		__LOG("%s:failed to set sock's timeout.\r\n", __FUNCTION__);

  000ca	6a 00		 push	 0
  000cc	e8 00 00 00 00	 call	 _LogHeader
  000d1	83 c4 04	 add	 esp, 4
  000d4	68 00 00 00 00	 push	 OFFSET $SG5180
  000d9	68 00 00 00 00	 push	 OFFSET $SG5181
  000de	e8 00 00 00 00	 call	 __hx_printf
  000e3	83 c4 08	 add	 esp, 8

; 293  : 		goto __TERMINAL;

  000e6	e9 5a 02 00 00	 jmp	 $__TERMINAL$25
$LN8@ylight_sea:

; 294  : 	}
; 295  : 
; 296  : 	/* Set out going interface of this multicast socket. */
; 297  : 	ifaddr.s_addr = inet_addr(SSDP_LAN_ADDR);

  000eb	68 00 00 00 00	 push	 OFFSET $SG5182
  000f0	e8 00 00 00 00	 call	 _ipaddr_addr
  000f5	83 c4 04	 add	 esp, 4
  000f8	89 45 e0	 mov	 DWORD PTR _ifaddr$[ebp], eax

; 298  : 	ret = setsockopt(s, IPPROTO_IP, IP_MULTICAST_IF, &ifaddr, sizeof(ifaddr));

  000fb	6a 04		 push	 4
  000fd	8d 55 e0	 lea	 edx, DWORD PTR _ifaddr$[ebp]
  00100	52		 push	 edx
  00101	6a 06		 push	 6
  00103	6a 00		 push	 0
  00105	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _setsockopt
  0010e	83 c4 14	 add	 esp, 20			; 00000014H
  00111	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 299  : 	if (ret < 0)

  00114	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00118	7d 21		 jge	 SHORT $LN9@ylight_sea

; 300  : 	{
; 301  : 		__LOG("%s:failed to set out going interface.\r\n", __FUNCTION__);

  0011a	6a 00		 push	 0
  0011c	e8 00 00 00 00	 call	 _LogHeader
  00121	83 c4 04	 add	 esp, 4
  00124	68 00 00 00 00	 push	 OFFSET $SG5184
  00129	68 00 00 00 00	 push	 OFFSET $SG5185
  0012e	e8 00 00 00 00	 call	 __hx_printf
  00133	83 c4 08	 add	 esp, 8

; 302  : 		goto __TERMINAL;

  00136	e9 0a 02 00 00	 jmp	 $__TERMINAL$25
$LN9@ylight_sea:

; 303  : 	}
; 304  : 
; 305  : 	/* Join the multicase group. */
; 306  : 	struct ip_mreq mreq;
; 307  : 	mreq.imr_interface.s_addr = _hx_htonl(INADDR_ANY);

  0013b	6a 00		 push	 0
  0013d	e8 00 00 00 00	 call	 __hx_htonl
  00142	83 c4 04	 add	 esp, 4
  00145	89 45 dc	 mov	 DWORD PTR _mreq$[ebp+4], eax

; 308  : 	mreq.imr_multiaddr.s_addr = inet_addr(SSDP_DEST_ADDR);

  00148	68 00 00 00 00	 push	 OFFSET $SG5186
  0014d	e8 00 00 00 00	 call	 _ipaddr_addr
  00152	83 c4 04	 add	 esp, 4
  00155	89 45 d8	 mov	 DWORD PTR _mreq$[ebp], eax

; 309  : 	ret = setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(struct ip_mreq));

  00158	6a 08		 push	 8
  0015a	8d 4d d8	 lea	 ecx, DWORD PTR _mreq$[ebp]
  0015d	51		 push	 ecx
  0015e	6a 03		 push	 3
  00160	6a 00		 push	 0
  00162	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00165	52		 push	 edx
  00166	e8 00 00 00 00	 call	 _setsockopt
  0016b	83 c4 14	 add	 esp, 20			; 00000014H
  0016e	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 310  : 	if (ret < 0)

  00171	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00175	7d 25		 jge	 SHORT $LN10@ylight_sea

; 311  : 	{
; 312  : 		__LOG("%s:failed to join multicast group,err = %d.\r\n", __FUNCTION__, ret);

  00177	6a 00		 push	 0
  00179	e8 00 00 00 00	 call	 _LogHeader
  0017e	83 c4 04	 add	 esp, 4
  00181	8b 45 fc	 mov	 eax, DWORD PTR _ret$[ebp]
  00184	50		 push	 eax
  00185	68 00 00 00 00	 push	 OFFSET $SG5188
  0018a	68 00 00 00 00	 push	 OFFSET $SG5189
  0018f	e8 00 00 00 00	 call	 __hx_printf
  00194	83 c4 0c	 add	 esp, 12			; 0000000cH

; 313  : 		goto __TERMINAL;

  00197	e9 a9 01 00 00	 jmp	 $__TERMINAL$25
$LN10@ylight_sea:

; 314  : 	}
; 315  : 
; 316  : 	/* Bind to multicast group address. */
; 317  : 	gaddr.sin_family = AF_INET;

  0019c	c6 45 c1 02	 mov	 BYTE PTR _gaddr$[ebp+1], 2

; 318  : 	gaddr.sin_port = _hx_htons(SSDP_DEST_PORT);

  001a0	68 be 07 00 00	 push	 1982			; 000007beH
  001a5	e8 00 00 00 00	 call	 __hx_htons
  001aa	83 c4 04	 add	 esp, 4
  001ad	66 89 45 c2	 mov	 WORD PTR _gaddr$[ebp+2], ax

; 319  : 	gaddr.sin_addr.s_addr = _hx_htonl(INADDR_ANY);

  001b1	6a 00		 push	 0
  001b3	e8 00 00 00 00	 call	 __hx_htonl
  001b8	83 c4 04	 add	 esp, 4
  001bb	89 45 c4	 mov	 DWORD PTR _gaddr$[ebp+4], eax

; 320  : 	memset(gaddr.sin_zero, 0, sizeof(gaddr.sin_zero));

  001be	6a 08		 push	 8
  001c0	6a 00		 push	 0
  001c2	8d 4d c8	 lea	 ecx, DWORD PTR _gaddr$[ebp+8]
  001c5	51		 push	 ecx
  001c6	e8 00 00 00 00	 call	 _memset
  001cb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 321  : 	ret = bind(s, (struct sockaddr*)&gaddr, sizeof(gaddr));

  001ce	6a 10		 push	 16			; 00000010H
  001d0	8d 55 c0	 lea	 edx, DWORD PTR _gaddr$[ebp]
  001d3	52		 push	 edx
  001d4	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  001d7	50		 push	 eax
  001d8	e8 00 00 00 00	 call	 _bind
  001dd	83 c4 0c	 add	 esp, 12			; 0000000cH
  001e0	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 322  : 	if (ret < 0)

  001e3	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  001e7	7d 21		 jge	 SHORT $LN11@ylight_sea

; 323  : 	{
; 324  : 		__LOG("%s:failed to bind to local interface.\r\n", __FUNCTION__);

  001e9	6a 00		 push	 0
  001eb	e8 00 00 00 00	 call	 _LogHeader
  001f0	83 c4 04	 add	 esp, 4
  001f3	68 00 00 00 00	 push	 OFFSET $SG5191
  001f8	68 00 00 00 00	 push	 OFFSET $SG5192
  001fd	e8 00 00 00 00	 call	 __hx_printf
  00202	83 c4 08	 add	 esp, 8

; 325  : 		goto __TERMINAL;

  00205	e9 3b 01 00 00	 jmp	 $__TERMINAL$25
$LN11@ylight_sea:

; 326  : 	}
; 327  : 
; 328  : 	/* Allocate data buffer for this socket. */
; 329  : 	buf = _hx_malloc(1500);

  0020a	68 dc 05 00 00	 push	 1500			; 000005dcH
  0020f	e8 00 00 00 00	 call	 __hx_malloc
  00214	83 c4 04	 add	 esp, 4
  00217	89 45 f4	 mov	 DWORD PTR _buf$[ebp], eax

; 330  : 	if (NULL == buf)

  0021a	83 7d f4 00	 cmp	 DWORD PTR _buf$[ebp], 0
  0021e	75 05		 jne	 SHORT $LN2@ylight_sea

; 331  : 	{
; 332  : 		goto __TERMINAL;

  00220	e9 20 01 00 00	 jmp	 $__TERMINAL$25
$LN2@ylight_sea:

; 333  : 	}
; 334  : 	/* Main message loop. */
; 335  : 	while (TRUE)

  00225	83 c9 ff	 or	 ecx, -1
  00228	0f 84 17 01 00
	00		 je	 $__TERMINAL$25

; 336  : 	{
; 337  : 		if (GetMessage(&msg))

  0022e	8d 55 d0	 lea	 edx, DWORD PTR _msg$[ebp]
  00231	52		 push	 edx
  00232	e8 00 00 00 00	 call	 _GetMessage
  00237	83 c4 04	 add	 esp, 4
  0023a	85 c0		 test	 eax, eax
  0023c	0f 84 fe 00 00
	00		 je	 $LN13@ylight_sea

; 338  : 		{
; 339  : 			switch (msg.wCommand)

  00242	0f b7 45 d0	 movzx	 eax, WORD PTR _msg$[ebp]
  00246	89 45 e8	 mov	 DWORD PTR tv173[ebp], eax
  00249	83 7d e8 05	 cmp	 DWORD PTR tv173[ebp], 5
  0024d	0f 84 eb 00 00
	00		 je	 $LN19@ylight_sea
  00253	83 7d e8 06	 cmp	 DWORD PTR tv173[ebp], 6
  00257	74 05		 je	 SHORT $LN14@ylight_sea
  00259	e9 e2 00 00 00	 jmp	 $LN13@ylight_sea
$LN14@ylight_sea:

; 340  : 			{
; 341  : 			case KERNEL_MESSAGE_TIMER:
; 342  : 				/*
; 343  : 				* Search all WiFi bulbs in local network,send out a request to
; 344  : 				* multicast address to trigger the bulbs to response our request.
; 345  : 				*/
; 346  : 				len = sizeof(gaddr);

  0025e	c7 45 ec 10 00
	00 00		 mov	 DWORD PTR _len$[ebp], 16 ; 00000010H

; 347  : 				gaddr.sin_family = AF_INET;

  00265	c6 45 c1 02	 mov	 BYTE PTR _gaddr$[ebp+1], 2

; 348  : 				gaddr.sin_port = _hx_htons(SSDP_DEST_PORT);

  00269	68 be 07 00 00	 push	 1982			; 000007beH
  0026e	e8 00 00 00 00	 call	 __hx_htons
  00273	83 c4 04	 add	 esp, 4
  00276	66 89 45 c2	 mov	 WORD PTR _gaddr$[ebp+2], ax

; 349  : 				gaddr.sin_addr.s_addr = inet_addr(SSDP_DEST_ADDR);

  0027a	68 00 00 00 00	 push	 OFFSET $SG5196
  0027f	e8 00 00 00 00	 call	 _ipaddr_addr
  00284	83 c4 04	 add	 esp, 4
  00287	89 45 c4	 mov	 DWORD PTR _gaddr$[ebp+4], eax

; 350  : 				memset(gaddr.sin_zero, 0, sizeof(gaddr.sin_zero));

  0028a	6a 08		 push	 8
  0028c	6a 00		 push	 0
  0028e	8d 4d c8	 lea	 ecx, DWORD PTR _gaddr$[ebp+8]
  00291	51		 push	 ecx
  00292	e8 00 00 00 00	 call	 _memset
  00297	83 c4 0c	 add	 esp, 12			; 0000000cH

; 351  : 				strcpy(buf, SSDP_REQ_CMD);

  0029a	68 00 00 00 00	 push	 OFFSET $SG5197
  0029f	8b 55 f4	 mov	 edx, DWORD PTR _buf$[ebp]
  002a2	52		 push	 edx
  002a3	e8 00 00 00 00	 call	 _strcpy
  002a8	83 c4 08	 add	 esp, 8

; 352  : 				ret = sendto(s, buf, strlen(buf), 0, (struct sockaddr*)&gaddr, len);

  002ab	8b 45 ec	 mov	 eax, DWORD PTR _len$[ebp]
  002ae	50		 push	 eax
  002af	8d 4d c0	 lea	 ecx, DWORD PTR _gaddr$[ebp]
  002b2	51		 push	 ecx
  002b3	6a 00		 push	 0
  002b5	8b 55 f4	 mov	 edx, DWORD PTR _buf$[ebp]
  002b8	52		 push	 edx
  002b9	e8 00 00 00 00	 call	 _strlen
  002be	83 c4 04	 add	 esp, 4
  002c1	50		 push	 eax
  002c2	8b 45 f4	 mov	 eax, DWORD PTR _buf$[ebp]
  002c5	50		 push	 eax
  002c6	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  002c9	51		 push	 ecx
  002ca	e8 00 00 00 00	 call	 _sendto
  002cf	83 c4 18	 add	 esp, 24			; 00000018H
  002d2	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 353  : 				if (ret < 0)

  002d5	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  002d9	7d 1e		 jge	 SHORT $LN16@ylight_sea

; 354  : 				{
; 355  : 					__LOG("%s:failed to send request.\r\n", __FUNCTION__);

  002db	6a 00		 push	 0
  002dd	e8 00 00 00 00	 call	 _LogHeader
  002e2	83 c4 04	 add	 esp, 4
  002e5	68 00 00 00 00	 push	 OFFSET $SG5200
  002ea	68 00 00 00 00	 push	 OFFSET $SG5201
  002ef	e8 00 00 00 00	 call	 __hx_printf
  002f4	83 c4 08	 add	 esp, 8

; 356  : 					goto __TERMINAL;

  002f7	eb 4c		 jmp	 SHORT $__TERMINAL$25
$LN16@ylight_sea:

; 357  : 				}
; 358  : 				else
; 359  : 				{
; 360  : 					//_hx_printf("%s:send %d bytes out with multicast.\r\n", __FUNCTION__, ret);
; 361  : 				}
; 362  : 				ret = recvfrom(s, buf, 1500, 0, (struct sockaddr*)&gaddr, &len);

  002f9	8d 55 ec	 lea	 edx, DWORD PTR _len$[ebp]
  002fc	52		 push	 edx
  002fd	8d 45 c0	 lea	 eax, DWORD PTR _gaddr$[ebp]
  00300	50		 push	 eax
  00301	6a 00		 push	 0
  00303	68 dc 05 00 00	 push	 1500			; 000005dcH
  00308	8b 4d f4	 mov	 ecx, DWORD PTR _buf$[ebp]
  0030b	51		 push	 ecx
  0030c	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  0030f	52		 push	 edx
  00310	e8 00 00 00 00	 call	 _recvfrom
  00315	83 c4 18	 add	 esp, 24			; 00000018H
  00318	89 45 fc	 mov	 DWORD PTR _ret$[ebp], eax

; 363  : 				if (ret < 0)

  0031b	83 7d fc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0031f	7d 02		 jge	 SHORT $LN17@ylight_sea

; 364  : 				{
; 365  : 					//_hx_printf("%s:failed to receive data from socket[ret=%d].\r\n", __FUNCTION__,
; 366  : 					//	ret);
; 367  : 				}

  00321	eb 19		 jmp	 SHORT $LN18@ylight_sea
$LN17@ylight_sea:

; 368  : 				else
; 369  : 				{
; 370  : 					//_hx_printf("Recived [%d] byte(s) data from[%s:%d].\r\n", ret,
; 371  : 					//	inet_ntoa(gaddr.sin_addr.s_addr),
; 372  : 					//	_hx_htons(gaddr.sin_port));
; 373  : 					buf[ret] = 0; /* Set terminator of the string. */

  00323	8b 45 f4	 mov	 eax, DWORD PTR _buf$[ebp]
  00326	03 45 fc	 add	 eax, DWORD PTR _ret$[ebp]
  00329	c6 00 00	 mov	 BYTE PTR [eax], 0

; 374  : 					ParseResponse(buf, ret);

  0032c	8b 4d fc	 mov	 ecx, DWORD PTR _ret$[ebp]
  0032f	51		 push	 ecx
  00330	8b 55 f4	 mov	 edx, DWORD PTR _buf$[ebp]
  00333	52		 push	 edx
  00334	e8 00 00 00 00	 call	 _ParseResponse
  00339	83 c4 08	 add	 esp, 8
$LN18@ylight_sea:

; 375  : 				}
; 376  : 				break;

  0033c	eb 02		 jmp	 SHORT $LN13@ylight_sea
$LN19@ylight_sea:

; 377  : 			case KERNEL_MESSAGE_TERMINAL:
; 378  : 				goto __TERMINAL;

  0033e	eb 05		 jmp	 SHORT $__TERMINAL$25
$LN13@ylight_sea:

; 379  : 			default:
; 380  : 				break;
; 381  : 			}
; 382  : 		}
; 383  : 	}

  00340	e9 e0 fe ff ff	 jmp	 $LN2@ylight_sea
$__TERMINAL$25:

; 384  : 
; 385  : __TERMINAL:
; 386  : 	{
; 387  : 		if (hTimer)

  00345	83 7d f0 00	 cmp	 DWORD PTR _hTimer$[ebp], 0
  00349	74 0c		 je	 SHORT $LN21@ylight_sea

; 388  : 		{
; 389  : 			CancelTimer(hTimer);

  0034b	8b 45 f0	 mov	 eax, DWORD PTR _hTimer$[ebp]
  0034e	50		 push	 eax
  0034f	e8 00 00 00 00	 call	 _CancelTimer
  00354	83 c4 04	 add	 esp, 4
$LN21@ylight_sea:

; 390  : 		}
; 391  : 		if (s > 0)

  00357	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  0035b	7e 0c		 jle	 SHORT $LN22@ylight_sea

; 392  : 		{
; 393  : 			close(s);

  0035d	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00360	51		 push	 ecx
  00361	e8 00 00 00 00	 call	 _close
  00366	83 c4 04	 add	 esp, 4
$LN22@ylight_sea:

; 394  : 		}
; 395  : 		if (buf)

  00369	83 7d f4 00	 cmp	 DWORD PTR _buf$[ebp], 0
  0036d	74 0c		 je	 SHORT $LN23@ylight_sea

; 396  : 		{
; 397  : 			_hx_free(buf);

  0036f	8b 55 f4	 mov	 edx, DWORD PTR _buf$[ebp]
  00372	52		 push	 edx
  00373	e8 00 00 00 00	 call	 __hx_free
  00378	83 c4 04	 add	 esp, 4
$LN23@ylight_sea:

; 398  : 		}
; 399  : 	}
; 400  : 	/* Show exit message. */
; 401  : 	__LOG("Bulb searcher exit.\r\n");

  0037b	6a 00		 push	 0
  0037d	e8 00 00 00 00	 call	 _LogHeader
  00382	83 c4 04	 add	 esp, 4
  00385	68 00 00 00 00	 push	 OFFSET $SG5209
  0038a	e8 00 00 00 00	 call	 __hx_printf
  0038f	83 c4 04	 add	 esp, 4

; 402  : 	return 0;

  00392	33 c0		 xor	 eax, eax

; 403  : }

  00394	8b e5		 mov	 esp, ebp
  00396	5d		 pop	 ebp
  00397	c3		 ret	 0
_ylight_search ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\src\yeelight.c
;	COMDAT _ParseResponse
_TEXT	SEGMENT
_bResult$ = -24						; size = 4
_charbuff$ = -20					; size = 4
_pTmpLight$1 = -16					; size = 4
_line$ = -12						; size = 4
_value$ = -8						; size = 4
_pLight$ = -4						; size = 4
_pRespMsg$ = 8						; size = 4
_msglen$ = 12						; size = 4
_ParseResponse PROC					; COMDAT

; 162  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 163  : 	char* charbuff = NULL;

  00006	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _charbuff$[ebp], 0

; 164  : 	struct yeelight_object* pLight = NULL;

  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pLight$[ebp], 0

; 165  : 	BOOL bResult = FALSE;

  00014	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 0

; 166  : 
; 167  : 	charbuff = _hx_malloc(msglen + 1);

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _msglen$[ebp]
  0001e	83 c0 01	 add	 eax, 1
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 __hx_malloc
  00027	83 c4 04	 add	 esp, 4
  0002a	89 45 ec	 mov	 DWORD PTR _charbuff$[ebp], eax

; 168  : 	if (NULL == charbuff)

  0002d	83 7d ec 00	 cmp	 DWORD PTR _charbuff$[ebp], 0
  00031	75 05		 jne	 SHORT $LN6@ParseRespo

; 169  : 	{
; 170  : 		goto __TERMINAL;

  00033	e9 ae 01 00 00	 jmp	 $__TERMINAL$19
$LN6@ParseRespo:

; 171  : 	}
; 172  : 	strcpy(charbuff, pRespMsg);

  00038	8b 4d 08	 mov	 ecx, DWORD PTR _pRespMsg$[ebp]
  0003b	51		 push	 ecx
  0003c	8b 55 ec	 mov	 edx, DWORD PTR _charbuff$[ebp]
  0003f	52		 push	 edx
  00040	e8 00 00 00 00	 call	 _strcpy
  00045	83 c4 08	 add	 esp, 8

; 173  : 	char* line = strtok(charbuff, "\r\n");

  00048	68 00 00 00 00	 push	 OFFSET $SG5126
  0004d	8b 45 ec	 mov	 eax, DWORD PTR _charbuff$[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 _strtok
  00056	83 c4 08	 add	 esp, 8
  00059	89 45 f4	 mov	 DWORD PTR _line$[ebp], eax

; 174  : 	char* value = NULL;

  0005c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _value$[ebp], 0

; 175  : 	if (line && (0 == strcmp(line, okmsg)))

  00063	83 7d f4 00	 cmp	 DWORD PTR _line$[ebp], 0
  00067	0f 84 ef 00 00
	00		 je	 $LN7@ParseRespo
  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _okmsg
  00073	51		 push	 ecx
  00074	8b 55 f4	 mov	 edx, DWORD PTR _line$[ebp]
  00077	52		 push	 edx
  00078	e8 00 00 00 00	 call	 _strcmp
  0007d	83 c4 08	 add	 esp, 8
  00080	85 c0		 test	 eax, eax
  00082	0f 85 d4 00 00
	00		 jne	 $LN7@ParseRespo

; 176  : 	{
; 177  : 		/*
; 178  : 		* Got a valid response,create a new light object
; 179  : 		* to hold values derived from this response.
; 180  : 		*/
; 181  : 		pLight = (struct yeelight_object*)_hx_malloc(sizeof(struct yeelight_object));

  00088	6a 34		 push	 52			; 00000034H
  0008a	e8 00 00 00 00	 call	 __hx_malloc
  0008f	83 c4 04	 add	 esp, 4
  00092	89 45 fc	 mov	 DWORD PTR _pLight$[ebp], eax

; 182  : 		memset(pLight, 0, sizeof(struct yeelight_object));

  00095	6a 34		 push	 52			; 00000034H
  00097	6a 00		 push	 0
  00099	8b 45 fc	 mov	 eax, DWORD PTR _pLight$[ebp]
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 _memset
  000a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 183  : 		pLight->sock = -1; /* No socket opened yet. */

  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _pLight$[ebp]
  000a8	c7 41 2c ff ff
	ff ff		 mov	 DWORD PTR [ecx+44], -1

; 184  : 		if (NULL == pLight)

  000af	83 7d fc 00	 cmp	 DWORD PTR _pLight$[ebp], 0
  000b3	75 05		 jne	 SHORT $LN2@ParseRespo

; 185  : 		{
; 186  : 			goto __TERMINAL;

  000b5	e9 2c 01 00 00	 jmp	 $__TERMINAL$19
$LN2@ParseRespo:

; 187  : 		}
; 188  : 		while (line)

  000ba	83 7d f4 00	 cmp	 DWORD PTR _line$[ebp], 0
  000be	0f 84 98 00 00
	00		 je	 $LN7@ParseRespo

; 189  : 		{
; 190  : 			value = getvalue(line, "Location");

  000c4	68 00 00 00 00	 push	 OFFSET $SG5129
  000c9	8b 55 f4	 mov	 edx, DWORD PTR _line$[ebp]
  000cc	52		 push	 edx
  000cd	e8 00 00 00 00	 call	 _getvalue
  000d2	83 c4 08	 add	 esp, 8
  000d5	89 45 f8	 mov	 DWORD PTR _value$[ebp], eax

; 191  : 			if (value)

  000d8	83 7d f8 00	 cmp	 DWORD PTR _value$[ebp], 0
  000dc	74 13		 je	 SHORT $LN9@ParseRespo

; 192  : 			{
; 193  : 				/* Obtain the light's IP address and port,fill into light object. */
; 194  : 				GetSocketFromLocation(value, &pLight->socket);

  000de	8b 45 fc	 mov	 eax, DWORD PTR _pLight$[ebp]
  000e1	83 c0 18	 add	 eax, 24			; 00000018H
  000e4	50		 push	 eax
  000e5	8b 4d f8	 mov	 ecx, DWORD PTR _value$[ebp]
  000e8	51		 push	 ecx
  000e9	e8 00 00 00 00	 call	 _GetSocketFromLocation
  000ee	83 c4 08	 add	 esp, 8
$LN9@ParseRespo:

; 195  : 			}
; 196  : 			value = getvalue(line, "id");

  000f1	68 00 00 00 00	 push	 OFFSET $SG5131
  000f6	8b 55 f4	 mov	 edx, DWORD PTR _line$[ebp]
  000f9	52		 push	 edx
  000fa	e8 00 00 00 00	 call	 _getvalue
  000ff	83 c4 08	 add	 esp, 8
  00102	89 45 f8	 mov	 DWORD PTR _value$[ebp], eax

; 197  : 			if (value)

  00105	83 7d f8 00	 cmp	 DWORD PTR _value$[ebp], 0
  00109	74 26		 je	 SHORT $LN10@ParseRespo

; 198  : 			{
; 199  : 				if (strlen(value) > LIGHT_ID_LENGTH) /* Invalid ID value. */

  0010b	8b 45 f8	 mov	 eax, DWORD PTR _value$[ebp]
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 _strlen
  00114	83 c4 04	 add	 esp, 4
  00117	83 f8 14	 cmp	 eax, 20			; 00000014H
  0011a	7e 05		 jle	 SHORT $LN11@ParseRespo

; 200  : 				{
; 201  : 					goto __TERMINAL;

  0011c	e9 c5 00 00 00	 jmp	 $__TERMINAL$19
$LN11@ParseRespo:

; 202  : 				}
; 203  : 				/* Save ID to light object. */
; 204  : 				strcpy(pLight->id, value);

  00121	8b 4d f8	 mov	 ecx, DWORD PTR _value$[ebp]
  00124	51		 push	 ecx
  00125	8b 55 fc	 mov	 edx, DWORD PTR _pLight$[ebp]
  00128	52		 push	 edx
  00129	e8 00 00 00 00	 call	 _strcpy
  0012e	83 c4 08	 add	 esp, 8
$LN10@ParseRespo:

; 205  : 			}
; 206  : 			value = getvalue(line, "name");

  00131	68 00 00 00 00	 push	 OFFSET $SG5134
  00136	8b 45 f4	 mov	 eax, DWORD PTR _line$[ebp]
  00139	50		 push	 eax
  0013a	e8 00 00 00 00	 call	 _getvalue
  0013f	83 c4 08	 add	 esp, 8
  00142	89 45 f8	 mov	 DWORD PTR _value$[ebp], eax

; 207  : 			if (value)
; 208  : 			{
; 209  : 				/* Save bulb name. */
; 210  : 			}
; 211  : 			line = strtok(NULL, "\r\n");

  00145	68 00 00 00 00	 push	 OFFSET $SG5136
  0014a	6a 00		 push	 0
  0014c	e8 00 00 00 00	 call	 _strtok
  00151	83 c4 08	 add	 esp, 8
  00154	89 45 f4	 mov	 DWORD PTR _line$[ebp], eax

; 212  : 		}

  00157	e9 5e ff ff ff	 jmp	 $LN2@ParseRespo
$LN7@ParseRespo:

; 213  : 	}
; 214  : 	/* Check if the response is from a known light. */
; 215  : 	if (pLight)

  0015c	83 7d fc 00	 cmp	 DWORD PTR _pLight$[ebp], 0
  00160	0f 84 80 00 00
	00		 je	 $__TERMINAL$19

; 216  : 	{
; 217  : 		struct yeelight_object* pTmpLight = pLightObject;

  00166	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _pLightObject
  0016c	89 4d f0	 mov	 DWORD PTR _pTmpLight$1[ebp], ecx
$LN4@ParseRespo:

; 218  : 		while (pTmpLight)

  0016f	83 7d f0 00	 cmp	 DWORD PTR _pTmpLight$1[ebp], 0
  00173	74 3f		 je	 SHORT $LN5@ParseRespo

; 219  : 		{
; 220  : 			/*
; 221  : 			* The light object is already in list of their
; 222  : 			* IDs are same.
; 223  : 			*/
; 224  : 			if (0 == strcmp(pLight->id, pTmpLight->id))

  00175	8b 55 f0	 mov	 edx, DWORD PTR _pTmpLight$1[ebp]
  00178	52		 push	 edx
  00179	8b 45 fc	 mov	 eax, DWORD PTR _pLight$[ebp]
  0017c	50		 push	 eax
  0017d	e8 00 00 00 00	 call	 _strcmp
  00182	83 c4 08	 add	 esp, 8
  00185	85 c0		 test	 eax, eax
  00187	75 20		 jne	 SHORT $LN14@ParseRespo

; 225  : 			{
; 226  : 				/*
; 227  : 				* Replace old light object's attributes by the
; 228  : 				* newly one.
; 229  : 				* May lead issue in multi-thread environment here,
; 230  : 				* since the global light list is reachable from
; 231  : 				* all threads,and no mutex is applied here for easy.
; 232  : 				*/
; 233  : 				pLight->pNext = pTmpLight->pNext;

  00189	8b 4d fc	 mov	 ecx, DWORD PTR _pLight$[ebp]
  0018c	8b 55 f0	 mov	 edx, DWORD PTR _pTmpLight$1[ebp]
  0018f	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  00192	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 234  : 				memcpy(pTmpLight, pLight, sizeof(*pLight));

  00195	6a 34		 push	 52			; 00000034H
  00197	8b 4d fc	 mov	 ecx, DWORD PTR _pLight$[ebp]
  0019a	51		 push	 ecx
  0019b	8b 55 f0	 mov	 edx, DWORD PTR _pTmpLight$1[ebp]
  0019e	52		 push	 edx
  0019f	e8 00 00 00 00	 call	 _memcpy
  001a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 235  : 				break;

  001a7	eb 0b		 jmp	 SHORT $LN5@ParseRespo
$LN14@ParseRespo:

; 236  : 			}
; 237  : 			pTmpLight = pTmpLight->pNext;

  001a9	8b 45 f0	 mov	 eax, DWORD PTR _pTmpLight$1[ebp]
  001ac	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  001af	89 4d f0	 mov	 DWORD PTR _pTmpLight$1[ebp], ecx

; 238  : 		}

  001b2	eb bb		 jmp	 SHORT $LN4@ParseRespo
$LN5@ParseRespo:

; 239  : 		if (NULL == pTmpLight) /* A new light. */

  001b4	83 7d f0 00	 cmp	 DWORD PTR _pTmpLight$1[ebp], 0
  001b8	75 2c		 jne	 SHORT $__TERMINAL$19

; 240  : 		{
; 241  : 			/* Just link the new found light into global list. */
; 242  : 			pLight->pNext = pLightObject;

  001ba	8b 55 fc	 mov	 edx, DWORD PTR _pLight$[ebp]
  001bd	a1 00 00 00 00	 mov	 eax, DWORD PTR _pLightObject
  001c2	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 243  : 			pLightObject = pLight;

  001c5	8b 4d fc	 mov	 ecx, DWORD PTR _pLight$[ebp]
  001c8	89 0d 00 00 00
	00		 mov	 DWORD PTR _pLightObject, ecx

; 244  : 			_hx_printf("\r\nA new light found[id = %s].\r\n",

  001ce	8b 55 fc	 mov	 edx, DWORD PTR _pLight$[ebp]
  001d1	52		 push	 edx
  001d2	68 00 00 00 00	 push	 OFFSET $SG5140
  001d7	e8 00 00 00 00	 call	 __hx_printf
  001dc	83 c4 08	 add	 esp, 8

; 245  : 				pLight->id);
; 246  : 			bResult = TRUE;

  001df	c7 45 e8 ff ff
	ff ff		 mov	 DWORD PTR _bResult$[ebp], -1
$__TERMINAL$19:

; 247  : 		}
; 248  : 	}
; 249  : __TERMINAL:
; 250  : 	if (!bResult)

  001e6	83 7d e8 00	 cmp	 DWORD PTR _bResult$[ebp], 0
  001ea	75 12		 jne	 SHORT $LN16@ParseRespo

; 251  : 	{
; 252  : 		if (pLight)

  001ec	83 7d fc 00	 cmp	 DWORD PTR _pLight$[ebp], 0
  001f0	74 0c		 je	 SHORT $LN16@ParseRespo

; 253  : 		{
; 254  : 			_hx_free(pLight);

  001f2	8b 45 fc	 mov	 eax, DWORD PTR _pLight$[ebp]
  001f5	50		 push	 eax
  001f6	e8 00 00 00 00	 call	 __hx_free
  001fb	83 c4 04	 add	 esp, 4
$LN16@ParseRespo:

; 255  : 		}
; 256  : 	}
; 257  : 	_hx_free(charbuff);

  001fe	8b 4d ec	 mov	 ecx, DWORD PTR _charbuff$[ebp]
  00201	51		 push	 ecx
  00202	e8 00 00 00 00	 call	 __hx_free
  00207	83 c4 04	 add	 esp, 4

; 258  : 	return bResult;

  0020a	8b 45 e8	 mov	 eax, DWORD PTR _bResult$[ebp]

; 259  : }

  0020d	8b e5		 mov	 esp, ebp
  0020f	5d		 pop	 ebp
  00210	c3		 ret	 0
_ParseResponse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\src\yeelight.c
;	COMDAT _ShowLight
_TEXT	SEGMENT
_pLight$ = 8						; size = 4
_ShowLight PROC						; COMDAT

; 150  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
$LN2@ShowLight:

; 151  : 	while (pLight)

  00003	83 7d 08 00	 cmp	 DWORD PTR _pLight$[ebp], 0
  00007	74 67		 je	 SHORT $LN1@ShowLight

; 152  : 	{
; 153  : 		_hx_printf("--------------------\r\n");

  00009	68 00 00 00 00	 push	 OFFSET $SG5094
  0000e	e8 00 00 00 00	 call	 __hx_printf
  00013	83 c4 04	 add	 esp, 4

; 154  : 		_hx_printf("id: %s\r\n", pLight->id);

  00016	8b 45 08	 mov	 eax, DWORD PTR _pLight$[ebp]
  00019	50		 push	 eax
  0001a	68 00 00 00 00	 push	 OFFSET $SG5095
  0001f	e8 00 00 00 00	 call	 __hx_printf
  00024	83 c4 08	 add	 esp, 8

; 155  : 		_hx_printf("ip: %s\r\n", inet_ntoa(pLight->socket.sin_addr));

  00027	8b 4d 08	 mov	 ecx, DWORD PTR _pLight$[ebp]
  0002a	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 _ipaddr_ntoa
  00033	83 c4 04	 add	 esp, 4
  00036	50		 push	 eax
  00037	68 00 00 00 00	 push	 OFFSET $SG5096
  0003c	e8 00 00 00 00	 call	 __hx_printf
  00041	83 c4 08	 add	 esp, 8

; 156  : 		_hx_printf("port: %d\r\n", _hx_ntohs(pLight->socket.sin_port));

  00044	8b 55 08	 mov	 edx, DWORD PTR _pLight$[ebp]
  00047	0f b7 42 1a	 movzx	 eax, WORD PTR [edx+26]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 __hx_ntohs
  00051	83 c4 04	 add	 esp, 4
  00054	0f b7 c8	 movzx	 ecx, ax
  00057	51		 push	 ecx
  00058	68 00 00 00 00	 push	 OFFSET $SG5097
  0005d	e8 00 00 00 00	 call	 __hx_printf
  00062	83 c4 08	 add	 esp, 8

; 157  : 		pLight = pLight->pNext;

  00065	8b 55 08	 mov	 edx, DWORD PTR _pLight$[ebp]
  00068	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0006b	89 45 08	 mov	 DWORD PTR _pLight$[ebp], eax

; 158  : 	}

  0006e	eb 93		 jmp	 SHORT $LN2@ShowLight
$LN1@ShowLight:

; 159  : }

  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
_ShowLight ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\src\yeelight.c
;	COMDAT _GetSocketFromLocation
_TEXT	SEGMENT
_addr$ = -48						; size = 32
_bResult$ = -16						; size = 4
_sock_str$ = -12					; size = 4
_len$ = -8						; size = 4
_port$ = -4						; size = 2
_location$ = 8						; size = 4
_pSock$ = 12						; size = 4
_GetSocketFromLocation PROC				; COMDAT

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H

; 82   : 	char* sock_str = NULL;

  00006	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _sock_str$[ebp], 0

; 83   : 	BOOL bResult = FALSE;

  0000d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 0

; 84   : 	char addr[32];
; 85   : 	int len = 0;

  00014	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 86   : 	unsigned short port = 0;

  0001b	33 c0		 xor	 eax, eax
  0001d	66 89 45 fc	 mov	 WORD PTR _port$[ebp], ax

; 87   : 
; 88   : 	BUG_ON(NULL == location);

  00021	83 7d 08 00	 cmp	 DWORD PTR _location$[ebp], 0
  00025	75 0f		 jne	 SHORT $LN2@GetSocketF
  00027	6a 58		 push	 88			; 00000058H
  00029	68 00 00 00 00	 push	 OFFSET $SG5077
  0002e	e8 00 00 00 00	 call	 ___BUG
  00033	83 c4 08	 add	 esp, 8
$LN2@GetSocketF:
  00036	33 c9		 xor	 ecx, ecx
  00038	74 02		 je	 SHORT $LN3@GetSocketF
  0003a	eb fa		 jmp	 SHORT $LN2@GetSocketF
$LN3@GetSocketF:

; 89   : 	BUG_ON(NULL == pSock);

  0003c	83 7d 0c 00	 cmp	 DWORD PTR _pSock$[ebp], 0
  00040	75 0f		 jne	 SHORT $LN4@GetSocketF
  00042	6a 59		 push	 89			; 00000059H
  00044	68 00 00 00 00	 push	 OFFSET $SG5079
  00049	e8 00 00 00 00	 call	 ___BUG
  0004e	83 c4 08	 add	 esp, 8
$LN4@GetSocketF:
  00051	33 d2		 xor	 edx, edx
  00053	74 02		 je	 SHORT $LN5@GetSocketF
  00055	eb fa		 jmp	 SHORT $LN4@GetSocketF
$LN5@GetSocketF:

; 90   : 
; 91   : 	/* Get socket string(IP and port) from string. */
; 92   : 	sock_str = getvalue(location, "yeelight");

  00057	68 00 00 00 00	 push	 OFFSET $SG5080
  0005c	8b 45 08	 mov	 eax, DWORD PTR _location$[ebp]
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 _getvalue
  00065	83 c4 08	 add	 esp, 8
  00068	89 45 f4	 mov	 DWORD PTR _sock_str$[ebp], eax

; 93   : 	if (NULL == sock_str)

  0006b	83 7d f4 00	 cmp	 DWORD PTR _sock_str$[ebp], 0
  0006f	75 05		 jne	 SHORT $LN6@GetSocketF

; 94   : 	{
; 95   : 		goto __TERMINAL;

  00071	e9 4f 01 00 00	 jmp	 $__TERMINAL$23
$LN6@GetSocketF:

; 96   : 	}
; 97   : 	/* skip all slash line. */
; 98   : 	while (*sock_str == '/')

  00076	8b 4d f4	 mov	 ecx, DWORD PTR _sock_str$[ebp]
  00079	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0007c	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  0007f	75 0b		 jne	 SHORT $LN7@GetSocketF

; 99   : 	{
; 100  : 		sock_str++;

  00081	8b 45 f4	 mov	 eax, DWORD PTR _sock_str$[ebp]
  00084	83 c0 01	 add	 eax, 1
  00087	89 45 f4	 mov	 DWORD PTR _sock_str$[ebp], eax

; 101  : 	}

  0008a	eb ea		 jmp	 SHORT $LN6@GetSocketF
$LN7@GetSocketF:

; 102  : 	//_hx_printf("sock_str = %s.\r\n", sock_str);
; 103  : 	len = 0;

  0008c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
$LN8@GetSocketF:

; 104  : 	while (sock_str[len] && (sock_str[len] != ':') && (len < 31))

  00093	8b 4d f4	 mov	 ecx, DWORD PTR _sock_str$[ebp]
  00096	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  00099	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0009c	85 d2		 test	 edx, edx
  0009e	74 2e		 je	 SHORT $LN9@GetSocketF
  000a0	8b 45 f4	 mov	 eax, DWORD PTR _sock_str$[ebp]
  000a3	03 45 f8	 add	 eax, DWORD PTR _len$[ebp]
  000a6	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000a9	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  000ac	74 20		 je	 SHORT $LN9@GetSocketF
  000ae	83 7d f8 1f	 cmp	 DWORD PTR _len$[ebp], 31 ; 0000001fH
  000b2	7d 1a		 jge	 SHORT $LN9@GetSocketF

; 105  : 	{
; 106  : 		addr[len] = sock_str[len];

  000b4	8b 55 f4	 mov	 edx, DWORD PTR _sock_str$[ebp]
  000b7	03 55 f8	 add	 edx, DWORD PTR _len$[ebp]
  000ba	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  000bd	8a 0a		 mov	 cl, BYTE PTR [edx]
  000bf	88 4c 05 d0	 mov	 BYTE PTR _addr$[ebp+eax], cl

; 107  : 		len++;

  000c3	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  000c6	83 c2 01	 add	 edx, 1
  000c9	89 55 f8	 mov	 DWORD PTR _len$[ebp], edx

; 108  : 	}

  000cc	eb c5		 jmp	 SHORT $LN8@GetSocketF
$LN9@GetSocketF:

; 109  : 	if (len >= 31) /* Can not obtain IP address from location string. */

  000ce	83 7d f8 1f	 cmp	 DWORD PTR _len$[ebp], 31 ; 0000001fH
  000d2	7c 05		 jl	 SHORT $LN17@GetSocketF

; 110  : 	{
; 111  : 		goto __TERMINAL;

  000d4	e9 ec 00 00 00	 jmp	 $__TERMINAL$23
$LN17@GetSocketF:

; 112  : 	}
; 113  : 	addr[len] = 0;

  000d9	8b 45 f8	 mov	 eax, DWORD PTR _len$[ebp]
  000dc	c6 44 05 d0 00	 mov	 BYTE PTR _addr$[ebp+eax], 0

; 114  : 	sock_str += len;

  000e1	8b 4d f4	 mov	 ecx, DWORD PTR _sock_str$[ebp]
  000e4	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  000e7	89 4d f4	 mov	 DWORD PTR _sock_str$[ebp], ecx

; 115  : 	//_hx_printf("IP addr = %s\r\n", addr);
; 116  : 	pSock->sin_addr.s_addr = inet_addr(addr);

  000ea	8d 55 d0	 lea	 edx, DWORD PTR _addr$[ebp]
  000ed	52		 push	 edx
  000ee	e8 00 00 00 00	 call	 _ipaddr_addr
  000f3	83 c4 04	 add	 esp, 4
  000f6	8b 4d 0c	 mov	 ecx, DWORD PTR _pSock$[ebp]
  000f9	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 117  : 	if (0 == pSock->sin_addr.s_addr)

  000fc	8b 55 0c	 mov	 edx, DWORD PTR _pSock$[ebp]
  000ff	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00103	75 05		 jne	 SHORT $LN10@GetSocketF

; 118  : 	{
; 119  : 		goto __TERMINAL;

  00105	e9 bb 00 00 00	 jmp	 $__TERMINAL$23
$LN10@GetSocketF:

; 120  : 	}
; 121  : 	//_hx_printf("IP addr: %s.\r\n", inet_ntoa(pSock->sin_addr));
; 122  : 	/* skip all space and colon. */
; 123  : 	while (*sock_str && ((*sock_str == ' ') || (*sock_str == ':')))

  0010a	8b 45 f4	 mov	 eax, DWORD PTR _sock_str$[ebp]
  0010d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00110	85 c9		 test	 ecx, ecx
  00112	74 21		 je	 SHORT $LN11@GetSocketF
  00114	8b 55 f4	 mov	 edx, DWORD PTR _sock_str$[ebp]
  00117	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0011a	83 f8 20	 cmp	 eax, 32			; 00000020H
  0011d	74 0b		 je	 SHORT $LN19@GetSocketF
  0011f	8b 4d f4	 mov	 ecx, DWORD PTR _sock_str$[ebp]
  00122	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00125	83 fa 3a	 cmp	 edx, 58			; 0000003aH
  00128	75 0b		 jne	 SHORT $LN11@GetSocketF
$LN19@GetSocketF:

; 124  : 	{
; 125  : 		sock_str++;

  0012a	8b 45 f4	 mov	 eax, DWORD PTR _sock_str$[ebp]
  0012d	83 c0 01	 add	 eax, 1
  00130	89 45 f4	 mov	 DWORD PTR _sock_str$[ebp], eax

; 126  : 	}

  00133	eb d5		 jmp	 SHORT $LN10@GetSocketF
$LN11@GetSocketF:

; 127  : 	len = 0;

  00135	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
$LN12@GetSocketF:

; 128  : 	while (sock_str[len] && (sock_str[len] != '\r') && (sock_str[len] != '\n') && len < 31)

  0013c	8b 4d f4	 mov	 ecx, DWORD PTR _sock_str$[ebp]
  0013f	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  00142	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00145	85 d2		 test	 edx, edx
  00147	74 3c		 je	 SHORT $LN13@GetSocketF
  00149	8b 45 f4	 mov	 eax, DWORD PTR _sock_str$[ebp]
  0014c	03 45 f8	 add	 eax, DWORD PTR _len$[ebp]
  0014f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00152	83 f9 0d	 cmp	 ecx, 13			; 0000000dH
  00155	74 2e		 je	 SHORT $LN13@GetSocketF
  00157	8b 55 f4	 mov	 edx, DWORD PTR _sock_str$[ebp]
  0015a	03 55 f8	 add	 edx, DWORD PTR _len$[ebp]
  0015d	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00160	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00163	74 20		 je	 SHORT $LN13@GetSocketF
  00165	83 7d f8 1f	 cmp	 DWORD PTR _len$[ebp], 31 ; 0000001fH
  00169	7d 1a		 jge	 SHORT $LN13@GetSocketF

; 129  : 	{
; 130  : 		addr[len] = sock_str[len];

  0016b	8b 4d f4	 mov	 ecx, DWORD PTR _sock_str$[ebp]
  0016e	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  00171	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  00174	8a 01		 mov	 al, BYTE PTR [ecx]
  00176	88 44 15 d0	 mov	 BYTE PTR _addr$[ebp+edx], al

; 131  : 		len++;

  0017a	8b 4d f8	 mov	 ecx, DWORD PTR _len$[ebp]
  0017d	83 c1 01	 add	 ecx, 1
  00180	89 4d f8	 mov	 DWORD PTR _len$[ebp], ecx

; 132  : 	}

  00183	eb b7		 jmp	 SHORT $LN12@GetSocketF
$LN13@GetSocketF:

; 133  : 	if (len >= 31)

  00185	83 7d f8 1f	 cmp	 DWORD PTR _len$[ebp], 31 ; 0000001fH
  00189	7c 02		 jl	 SHORT $LN20@GetSocketF

; 134  : 	{
; 135  : 		goto __TERMINAL;

  0018b	eb 38		 jmp	 SHORT $__TERMINAL$23
$LN20@GetSocketF:

; 136  : 	}
; 137  : 	addr[len] = 0;

  0018d	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  00190	c6 44 15 d0 00	 mov	 BYTE PTR _addr$[ebp+edx], 0

; 138  : 	//_hx_printf("port = %s\r\n", addr);
; 139  : 	pSock->sin_port = _hx_htons((__u16)atol(addr));

  00195	8d 45 d0	 lea	 eax, DWORD PTR _addr$[ebp]
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 _atol
  0019e	83 c4 04	 add	 esp, 4
  001a1	50		 push	 eax
  001a2	e8 00 00 00 00	 call	 __hx_htons
  001a7	83 c4 04	 add	 esp, 4
  001aa	8b 4d 0c	 mov	 ecx, DWORD PTR _pSock$[ebp]
  001ad	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 140  : 	if (0 == pSock->sin_port)

  001b1	8b 55 0c	 mov	 edx, DWORD PTR _pSock$[ebp]
  001b4	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  001b8	85 c0		 test	 eax, eax
  001ba	75 02		 jne	 SHORT $LN21@GetSocketF

; 141  : 	{
; 142  : 		goto __TERMINAL;

  001bc	eb 07		 jmp	 SHORT $__TERMINAL$23
$LN21@GetSocketF:

; 143  : 	}
; 144  : 	bResult = TRUE;

  001be	c7 45 f0 ff ff
	ff ff		 mov	 DWORD PTR _bResult$[ebp], -1
$__TERMINAL$23:

; 145  : __TERMINAL:
; 146  : 	return bResult;

  001c5	8b 45 f0	 mov	 eax, DWORD PTR _bResult$[ebp]

; 147  : }

  001c8	8b e5		 mov	 esp, ebp
  001ca	5d		 pop	 ebp
  001cb	c3		 ret	 0
_GetSocketFromLocation ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\hellox\personal\hellox_os\app\yeelight\src\yeelight.c
;	COMDAT _getvalue
_TEXT	SEGMENT
_ret$ = -8						; size = 4
_i$ = -4						; size = 4
_str$ = 8						; size = 4
_key$ = 12						; size = 4
_getvalue PROC						; COMDAT

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 46   : 	char* ret = NULL;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0

; 47   : 	int i = 0;

  0000d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0

; 48   : 
; 49   : 	if ((NULL == str) || (NULL == key))

  00014	83 7d 08 00	 cmp	 DWORD PTR _str$[ebp], 0
  00018	74 06		 je	 SHORT $LN8@getvalue
  0001a	83 7d 0c 00	 cmp	 DWORD PTR _key$[ebp], 0
  0001e	75 05		 jne	 SHORT $LN7@getvalue
$LN8@getvalue:

; 50   : 	{
; 51   : 		goto __TERMINAL;

  00020	e9 ae 00 00 00	 jmp	 $__TERMINAL$15
$LN7@getvalue:

; 52   : 	}
; 53   : 	for (i = 0; str[i] && key[i]; i++)

  00025	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002c	eb 09		 jmp	 SHORT $LN4@getvalue
$LN2@getvalue:
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00031	83 c0 01	 add	 eax, 1
  00034	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@getvalue:
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0003a	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  0003d	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00040	85 d2		 test	 edx, edx
  00042	74 27		 je	 SHORT $LN3@getvalue
  00044	8b 45 0c	 mov	 eax, DWORD PTR _key$[ebp]
  00047	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0004a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0004d	85 c9		 test	 ecx, ecx
  0004f	74 1a		 je	 SHORT $LN3@getvalue

; 54   : 	{
; 55   : 		if (str[i] != key[i])

  00051	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  00054	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  00057	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0005a	8b 4d 0c	 mov	 ecx, DWORD PTR _key$[ebp]
  0005d	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  00060	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00063	3b c2		 cmp	 eax, edx
  00065	74 02		 je	 SHORT $LN9@getvalue

; 56   : 		{
; 57   : 			break;

  00067	eb 02		 jmp	 SHORT $LN3@getvalue
$LN9@getvalue:

; 58   : 		}
; 59   : 	}

  00069	eb c3		 jmp	 SHORT $LN2@getvalue
$LN3@getvalue:

; 60   : 	/* Key can not match the proceeding part of str? */
; 61   : 	if ((0 == str[i]) || (key[i]))

  0006b	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  0006e	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00071	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00074	85 c9		 test	 ecx, ecx
  00076	74 0d		 je	 SHORT $LN11@getvalue
  00078	8b 55 0c	 mov	 edx, DWORD PTR _key$[ebp]
  0007b	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  0007e	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00081	85 c0		 test	 eax, eax
  00083	74 02		 je	 SHORT $LN5@getvalue
$LN11@getvalue:

; 62   : 	{
; 63   : 		goto __TERMINAL;

  00085	eb 4c		 jmp	 SHORT $__TERMINAL$15
$LN5@getvalue:

; 64   : 	}
; 65   : 	/* Skip all spaces and colons. */
; 66   : 	while (str[i] && ((' ' == str[i]) || (':' == str[i])))

  00087	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  0008a	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  0008d	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00090	85 d2		 test	 edx, edx
  00092	74 27		 je	 SHORT $LN6@getvalue
  00094	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  00097	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  0009a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0009d	83 f9 20	 cmp	 ecx, 32			; 00000020H
  000a0	74 0e		 je	 SHORT $LN12@getvalue
  000a2	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  000a5	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000a8	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000ab	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  000ae	75 0b		 jne	 SHORT $LN6@getvalue
$LN12@getvalue:

; 67   : 	{
; 68   : 		i++;

  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000b3	83 c1 01	 add	 ecx, 1
  000b6	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx

; 69   : 	}

  000b9	eb cc		 jmp	 SHORT $LN5@getvalue
$LN6@getvalue:

; 70   : 	if (0 == str[i])

  000bb	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]
  000be	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  000c1	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000c4	85 c0		 test	 eax, eax
  000c6	75 02		 jne	 SHORT $LN13@getvalue

; 71   : 	{
; 72   : 		goto __TERMINAL;

  000c8	eb 09		 jmp	 SHORT $__TERMINAL$15
$LN13@getvalue:

; 73   : 	}
; 74   : 	ret = &str[i];

  000ca	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]
  000cd	03 4d fc	 add	 ecx, DWORD PTR _i$[ebp]
  000d0	89 4d f8	 mov	 DWORD PTR _ret$[ebp], ecx
$__TERMINAL$15:

; 75   : __TERMINAL:
; 76   : 	return ret;

  000d3	8b 45 f8	 mov	 eax, DWORD PTR _ret$[ebp]

; 77   : }

  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c3		 ret	 0
_getvalue ENDP
_TEXT	ENDS
END
