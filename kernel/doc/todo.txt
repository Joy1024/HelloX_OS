1. Test the speed of routing only with 2 PCs,the initial test result is 100M(the bottleneck
   may lead by the physical speed of USB ethernet);
2. E1000E driver souce code has revised:
   2.1 Set the maximal sending queue's size to 256 from 64;
   2.2 Distinguish tx queue full or cloning ethernet buffer failure;
   2.3 To check if 'txq full or clone eth buff fail' warning still
       raise;
3. Start ping test when do intensive performance testing,to check the delay or packet
   loss;
4. Apply the following test case:
   4.1 Pure L3 routing with 2 PCs with GE interfaces;
   4.2 L3 routing plus NAT;
5. Trouble shootting the checksum failure of TCP when total packet length is 40(in most case);
6. easynat source code revised,more information(old checksum and new checksum) will be
   showed out when checksum validation fail;

 /*
 * Next step:
 * 1. Debug the genif hirarchy mechanism under windows;
 * 2. Revise show int command to show out all genif in hellox;
 * 3. Implement GetGenifInfo routine;
 * 4. Connect genif and lwip together using protocol-binding; -- OK
 * 5. Revise e1000 driver using genif,change name to e1000ex.h/c file;--OK
 * 6. Create and register genif after AddEthernetInterface routine,check
 *    the output of showgif; --OK
 *    20200501: Copy e1000e.h/c file to e1000ex.h/c file,replace the net
 *              driver entry point in ethentry.c file with _EX_ version;
 *              Create and register genif after AddEthernetInterface routine
 *              in e1000ex.c file,input/output routines are added in file;
 *              showgif command added in shell/network.c file,this will
 *              replace the showint&iflist routines;
 * 7. Revise the implementation of lwIP's genif new routines; -- sames OK
 * 8. Revise e1000ex files to support genif;
 *    20200502:
 *    genif added into e1000e's priv structure;
 *    specific show appended into genif and implemented in e1000ex.c file;
 *    20200517:
 *    __process_rx_pkt is revised to support genif;
 *    memory leak sames exist when the incoming path is diverted to genif;
 *    TO-DO:
 *    Revise e1000_genif_output routine as commented in it; --OK
 *    Make the output path to genif; --OK
 *    Remove AddEthernetInterface routine and all it's dependencies; --OK
 *    Test the new e1000e's genif implementation; --sames OK
 *    TO-DO:
 *    Revise pppoe's implementation using genif; --sames OK
 *    Consider enhance the performance of pppoe by distributing rx/tx to
 *      differnet threads;
 *    Put dhcp server into user space...
 *
 *    20200525:
 *    AddGenifAddress implemented and tested,sames OK;
 *    Setgif command added into network program;
 *    TO-DO:
 *    Consider how to implement the interactive between user application and
 *      kernel shell,when a user application is loaded into memory,a dedicated
 *      thread is created and runs as service,how to call it to shell from background?
 *    Solve the routing table looking up algorithm's issue,i.e,the interface without
 *      ip address/mask been set also is included in looking up process;
 *    Replace netif in dhcpd by using genif;--OK
 *    Invoke AddGenifAddress to configure ip address in dhcpd;--OK
 *    Remove dhcpserver flag in netif,use build in data structure to check re-enter;--OK
 *    Move dhcpd into user space;
 *    Try to trouble shooting the hang of ping;
 *    
 * 9. put GetGenifInfo routine into user space;
 * 10. Implement AddGenifAddress routine and put it at user space;
 * 11. Move sockets API into user space;
 * 12. Move dhcp server code into user space;
 * 13. Add binding mechanism between genif and layer3 stack; --sames OK
 * 14. Replace ethernet mechanism by using genif in intel nic driver; --OK
 * 15. Whole testing through black box;
 *
 * 20200608:
 * DONE:
 * 1. Implemented the xfer mechanism of syscall when parameters more than 5;
 * 2. Test the mechanism of above with a additional syscall(SYSCALL_TESTPARAMXFER);
 * 3. Kernel part of socket API implemented;
 *
 * 20200621:
 * 1. Implemented GetNetworkInfo system call,and tested it in examapp;
 * 2. Memory leaks(about ~100 bytes) when above app is executed;
 *
 * 20200625:
 * 1. Implemented GetGenifInfo/AddGenifAddress system call,and tested it in examapp;
 * 2. malloc and string's operation also tested in examapp;
 *
 * 20200712:
 * 1. Socket source code ported to user land;
 * 2. socket/bind/setsockopt/sendto/recvfrom routines implemented in user land;
 * 3. The dhcp server code in user land linked OK;
 *
 * TODO(After 20200712):
 * 1. Debug the dhcp server function since it passed linkage,but the entry
 *    should be revised in examapp.c to direct to dhcp server's entry;
 * 2. Other socket routines should be implemented,if pass debugging;
 * 3. Consider simplify the syscall mechanism,use eax as return code,and
 *    use MACRO(such as SYSCALL_PARAM_XX(vector,ret,param1,...) to simplify coding;
 * 
 * TODO:
 * 1. User part of socket API's implementation; --OK
 *    1.1 showgif command shows interface's status as DOWN/FULL/1000M when up and down again;
 * 2. socket/network header files in user mode, should copy some from kernel mode; --OK
 * 3. Clone dhcp server code into user mode and build as application; --OK
 * 4. Test the user mode dhcp server in virtual box;
 *    4.1 Make a configure file of dhcp server,read the port list from it when the server
 *        initialized;
 * 5. Optimize the file I/O and fcntl.h accordingly;
 *    5.1 Consider how to install hellox into harddisk;
 *    5.2 Consider the alignment of memory when xfer memory block
 *        between user and kernel;
 * 6. Port c4 compiler to hellox as user application;
 * 7. Thoroughly test under black box or new router;
 * 8. Release version 1.86 and initiate the next version;
 * 9. Look forward and consider the next BIG BIG step...
 *    Consider how to implement the interactive between user application and
 *      kernel shell,when a user application is loaded into memory,a dedicated
 *      thread is created and runs as service,how to call it to shell from background?
 *    Solve the routing table looking up algorithm's issue,i.e,the interface without
 *      ip address/mask been set also is included in looking up process;
 * 10. dhcp server's if index; --OK,done
 * 11. Simplify the output of showgif; --OK,done
 * 12. Backspace/ctrl input of console(COM);
 * 13. Enhance of ioctrl command; -- OK;
 * 14. User space application:
 *     Soleve the issue that pag fault raises when access user space in kernel thread,
 *     since the kernel thread's page table is global and no user page table installed
 *     in the global page table.
 * 15. memcpy in kernel should be optimized to improve efficiency;
 * 20200816:
 * 1. user mode dhcp server's interaction with command line;
 * 2. how to manage dhcp server like services under hellox? --done
 * 3. Rewrite file system's implementation in hellox,as next step;
 * 4. loadapp's implementation code has commented partly,should resolve it;
 */

 TO DO LIST AFTER NEW BOOT STAGE I IMPLEMENTED(2021/06/11):
 1. Make a usb booting stick and load IBM thinkpad/DELL PC in Beijing, to verify
    the new boot loader;
 2. Fix usb stick's FS error(introduced by make_usb_boot) under windows, and
    reload the PCs to check if it's OK;
 3. Install hellox into harddisk of PC, according steps in doc/install.txt file,
    and load PC to test it;
 4. Implement the system logging service and make all logging information persisted;
 5. Do some intensive testing of FS and storage function, and make some optimization;
 6. Release the V1.88 version, and begin next version...

 20210627:
 1. fat32bs could load from fat32 partition whose size is 4G,but could not load
    if the partition's size is 80G,should trouble shooting it;
 2. System crash when disk is accessed at the same time, such as syslog is writting
    and showing the logfile at the same time, should trouble shooting it;
	-- When code lines in 305 of ahciio.c executed, error arise;
	-- The _hx_printf clause in 305 of ahciio.c file, appear 2 times when crash;
	-- So the issue may lead by re-enter of ahci accessing;
	-- 20210711: Sames solved, pending to test the performance of AHCI in Multiple Thread;

 20210807:
 Trouble shooting of packet loopback(lead mailbox full):
 1. LAND filter of ingress direction of pp interface captures the ICMP packet 
    with size is 56, same as icmp_send_response;
 2. The packet sames sent by local host, may triggered by IP fragment timeout, should
    print out the ICMP type; --in progress;
 3. ICMP type is 11, code is 0, it maybe caused by TTL = 0 in ip_forward() routine;
 4. Should check why the ppp/pppoe module sends out packet with TTL=1?
    -- hx-gw forwards the multicase packets with address(224.0.0.251,252, 224.255.255.250),
	   the packets length are too large that lead to fragment;
	-- These packets should be originated by local host, windows system,...;
	-- why hx-gw forwards the multicast packets? and use the pppoe interface's address
	   as source address ?
	-- The path maybe:
	   a. Windows system sends out MDNS or Service discovery packets;
	   b. HelloX GW does essential checks, then forwards these packets by looking up route table;
	   c. Default interface pp is matched(ip_route is not revised yet) and returned;
	   d. Apply NAT on the packet, replace source address as pp's address;
	   e. Decrement the TTL, but reaches 0, then the ip_forward routine notices source;
	   f. icmp_time_exceed is invoked, then response ICMP packet is send back to pp;
	   g. It's a local address, so the loopback sending routine netif_loop_output invoked;
	   h. It send a mail into tcp/ip thread, when mailbox full, tcp/ip thread pends;
	   i. Dead loop raise...
	   j. Solution: Ignore multicast address in ip_route routine;
	   -- Issue sames resolved.


Following issues pending when implement the TFTP server:
1. sendto system call will fail with sockaddr is changed in sendto routine, triggers
   the bug in sockets.c file;
   1) Code line is 840 in sockets.c file under kernel;
   2) The sendto target address is revised, may by the recvfrom routine. this lead to
      the __BUG macro;
2. More than 1 request submitted to AHCI controller, and __cancel_port_request is invoked
   but with NULL implementation, and then lead system crash. It's maybe the following cause:
   1) request cancelled but still linked in the list, since __cancel_xxx is not implemented
      yet. But the corresponding DRCB is released;
	  -- Revised the interrupt handler of AHCI, change if(port->is) to while(port->is),
	     the issue same resolved;
	  -- Should exam if the solution is OK, should consider if there are other unhandled
	     interrupts exist, and it may lead to deadloop if so;
	  -- Should test it under physical PCs if above revision eventually committed;
   2) when interrupt raise, the already destroyed request is processed, so lead system crash;
3. exit() system call in user land does not work since current thread handle is specified
   and the system bottom half will check it, and just return if the handle is NULL;

Debugging procedures:
1. Load examapp.exe from C:, could stop syslog function before it;
2. Start tftp client under windows CMD line, get cpuid.exe from server;
3. Error may appear;

Progress in 2021/08/22:
1. tftp_send_data works OK, returns the byte value that sent, but the client sames
   does not received;
   -- The destination port is correct, from the output of netstat -s -p UDP command, since
      there is not port error counter when tftp client present;
   -- But the UDP packet may error since the recv error counter is increasing when tftp
      client present;
   -- The UDP packet is sent out by hellox, and received by windows, port is OK, but 
      some unknown-thing wrong that leads tftp client could not received the server's response;
   -- Source port/addr and dest port/addr same all OK from the output of udp.c, should install
      wireshark to capture packet to diagnose it;
   -- Issue solved: caused by windows firewall, drops all packets that are not initiated from 
      inside direction;
2. tftp_recv_message from client enters waiting state and give up because of timeout,
   the sockaddr maybe revised by the recvfrom routine, thus lead the BUGS described above. This
   should be confirmed, just put a print clause in recvfrom routine of kernel, maybe before 689
   line of sockets.c file;
   -- The sockaddr is revised by recvfrom syscall's agent in kernel side, we revised it and the
      issue is solved;
3. TFTP put functions seems OK, enter the releasing procedure of V1.88;

TFTP server optimization-20210907 all done:
1. Resolve the issue of fwrite failure, which lead the exit() routine invoked;
2. Test the trying mechanism both for get and for put;
3. Test it under physical pc, test the quit function to make sure the application
   is re-enterable;
4. Trouble the issue that thread is not killed after exit, then lead memory leaking;
