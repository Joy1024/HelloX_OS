需要深入思考和细化的主要思想：
1. 对象思想，所有内核对象都通过Object Manager管理，创建，销毁，增加引用计数，等等。这样在销毁对象的时候就不需要知道对象的具体信息，
只要调用一个DestroyObject函数即可；
2. 多CPU下的竞争，这是多核操作系统实现中的难度最大的问题。必须用spin lock保护，如果代码的顺序不对，会产生竞争导致死锁，等等；
3. HANDLE机制，所有process user级别的对象，都通过HANDLE来封装。user space的代码看不到内核对象的任何信息，包括在内存中的地址。通过
HANDLE机制，查找handle table，进一步找到内核对象，然后进行相应的操作。之所以不能看到内核对象的内存地址，除安全因素外，还有多线程同步
的原因，考虑一个内核对象被一个线程删除，但是另一个线程却有可能再次引用这个内核对象。这样就会引发问题。而HANDLE机制则不存在该问题，查找
handle table失败后，直接引发异常。同样的思路也应用到Object Manager里面，所有的内核对象都记录在案，任何对内核对象的操作，首先确认这
个内核对象是存在的（通过查找对象表），然后再引用；
4. 保护机制，user level的代码，只能通过系统调用进入内核模式。如果user level试图直接访问内核空间，则会引发硬件异常，操作系统会直接
终止程序。所有process创建的资源，包括内核对象，内存page，等等，都记录在handle table中，随着process的结束或者终止而被内核销毁。因此
process user级别的异常，不会导致内存泄漏；
5. HelloX支持增强的沙盒机制，包括存储空间，内存空间，打开的设备，等等，都是与其它所有process和内核隔离的。这样一个恶意进程不会影响
其它process，也不会影响内核；
6. “第一个”问题，第一个内核线程的产生，第一个用户进程的产生，创建用户process时，第一次如何进入user space，等等问题和处理方法；
7. 操作系统的精髓在于用户模式和内核模式的协同，只有引入用户模式，才真正发现handle机制，保护机制，内核stack等概念的价值和巧妙；
8. 微内核与宏内核。微内核架构简洁，便于维护。宏内核架构高效，更高性能。但这两者的优势，正是各自的不足。通过内核线程机制，来最大化的
解决这两者的不足，做到内核架构简洁和高效。因为内核线程机制避免了用户模式与内核模式的context switching；
9. 关于机制和策略（或者算法）的分离。比如Object Manager实现了机制部分，包括内核对象的管理机制，创建，销毁，等等。而具体内核对象的
Initialize和Uninitialize函数实现了具体的策略，即对象的初始化和销毁；
10. HelloX作为客户端模式运行时，不开放任何端口，通过随机端口访问管理服务器，而且访问结束后立即关闭链接。另一次访问，使用的端口可能
会变化。这样类似DNS配置信息篡改等问题就得到解决；
11. 